<!doctype html><html class="" data-reactroot=""><head>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:title" content="深入剖析Vue源码"/><meta data-react-helmet="true" property="og:description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary"/>
<title data-react-helmet="true">深入剖析Vue源码</title>
<link data-react-helmet="true" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/In-depth-analysis-of-Vue/assets/prism_tomorrow.css";
    }
  </script>
</head><body><header><h1 class="hide_on_mobile"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1><nav><ul><li class="show_on_mobile flex_center"><a class="czs-menu-l" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-menu-l.svg&quot;)"></a></li><li class="show_on_mobile"><h1 class="mobile_title"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1></li><li class="hide_on_mobile"><a href="https://cn.vuejs.org/index.html" target="_blank">Vue2.x文档</a></li><li class="hide_on_mobile"><a href="https://book.penblog.cn/" target="_blank">历史地址</a></li><li class="hide_on_mobile"><a>赞助作者</a></li><li style="flex-grow:1"></li><li class="flex_center"><a class="czs-github-logo" href="https://github.com/Ocean1509/In-depth-analysis-of-Vue" target="_blank" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-github-logo.svg&quot;)"></a></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon-l.svg&quot;)"></span></li></ul></nav></header><aside class="sidebar"><ol class="list_style_none"><li class=""><a href="/In-depth-analysis-of-Vue/src/0.Introduction.html" class="nav_link">目录</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/1.丰富的选项合并策略.html" class="nav_link">1.丰富的选项合并策略</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/2.基础的数据代理检测.html" class="nav_link">2.基础的数据代理检测</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/3.实例挂载流程和模板编译.html" class="nav_link">3.实例挂载流程和模板编译</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/4.完整渲染流程.html" class="nav_link">4.完整渲染流程</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/5.组件基础剖析.html" class="nav_link">5.组件基础剖析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/6.组件高级用法.html" class="nav_link">6.组件高级用法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-上.html" class="nav_link">7.深入响应式系统构建-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-中.html" class="nav_link active">7.深入响应式系统构建-中</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-下.html" class="nav_link">7.深入响应式系统构建-下</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/8.来，跟我一起实现diff算法.html" class="nav_link">8.来，跟我一起实现diff算法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/9.揭秘Vue的事件机制.html" class="nav_link">9.揭秘Vue的事件机制</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/10.vue插槽，你想了解的都在这里.html" class="nav_link">10.vue插槽，你想了解的都在这里</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/11.你真的了解v-model的语法糖了吗.html" class="nav_link">11.你真的了解v-model的语法糖了吗</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/12.动态组件的深入分析.html" class="nav_link">12.动态组件的深入分析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-上.html" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-下.html" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-下</a></li></ol></aside><section class="main"><div class="main_article"><article><blockquote>
<p>为了深入介绍响应式系统的内部实现原理，我们花了一整节的篇幅介绍了数据(包括<code>data, computed,props</code>)如何初始化成为响应式对象的过程。有了响应式数据对象的知识，上一节的后半部分我们还在保留源码结构的基础上构建了一个以<code>data</code>为数据的响应式系统，而这一节，我们继续深入响应式系统内部构建的细节，详细分析<code>Vue</code>在响应式系统中对<code>data,computed</code>的处理。</p>
</blockquote>
<h2 id="78-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">7.8 相关概念<a class="anchor" href="#78-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">§</a></h2>
<p>在构建简易式响应式系统的时候，我们引出了几个重要的概念，他们都是响应式原理设计的核心，我们先简单回顾一下：</p>
<ul>
<li><code>Observer</code>类，实例化一个<code>Observer</code>类会通过<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行改写，在<code>getter</code>阶段进行<strong>依赖的收集</strong>,在数据发生更新阶段，触发<code>setter</code>方法进行<strong>依赖的更新</strong></li>
<li><code>watcher</code>类，实例化<code>watcher</code>类相当于创建一个依赖，简单的理解是数据在哪里被使用就需要产生了一个依赖。当数据发生改变时，会通知到每个依赖进行更新，前面提到的渲染<code>wathcer</code>便是渲染<code>dom</code>时使用数据产生的依赖。</li>
<li><code>Dep</code>类，既然<code>watcher</code>理解为每个数据需要监听的依赖，那么对这些依赖的收集和通知则需要另一个类来管理，这个类便是<code>Dep</code>,<code>Dep</code>需要做的只有两件事，收集依赖和派发更新依赖。</li>
</ul>
<p>这是响应式系统构建的三个基本核心概念，也是这一节的基础，如果还没有印象，请先回顾上一节对<strong>极简风响应式系统的构建</strong>。</p>
<h2 id="79-data">7.9 data<a class="anchor" href="#79-data">§</a></h2>
<h3 id="791-%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83">7.9.1 问题思考<a class="anchor" href="#791-%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83">§</a></h3>
<p>在开始分析<code>data</code>之前，我们先抛出几个问题让读者思考，而答案都包含在接下来内容分析中。</p>
<ul>
<li>
<p>前面已经知道，<code>Dep</code>是作为管理依赖的容器，那么这个容器在什么时候产生？也就是实例化<code>Dep</code>发生在什么时候？</p>
</li>
<li>
<p><code>Dep</code>收集了什么类型的依赖？即<code>watcher</code>作为依赖的分类有哪些，分别是什么场景，以及区别在哪里？</p>
</li>
<li>
<p><code>Observer</code>这个类具体对<code>getter,setter</code>方法做了哪些事情？</p>
</li>
<li>
<p>手写的<code>watcher</code>和页面数据渲染监听的<code>watch</code>如果同时监听到数据的变化，优先级怎么排？</p>
</li>
<li>
<p>有了依赖的收集是不是还有依赖的解除，依赖解除的意义在哪里？</p>
</li>
</ul>
<p>带着这几个问题，我们开始对<code>data</code>的响应式细节展开分析。</p>
<h3 id="792-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.9.2 依赖收集<a class="anchor" href="#792-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">§</a></h3>
<p><code>data</code>在初始化阶段会实例化一个<code>Observer</code>类，这个类的定义如下(忽略数组类型的<code>data</code>):</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// initData </span>
<span class="token keyword">function</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// observe</span>
<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> asRootData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
  ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> ob
<span class="token punctuation">}</span>

<span class="token comment">// 观察者类，对象只要设置成拥有观察属性，则对象下的所有属性都会重写getter和setter方法，而getter，setting方法会进行依赖的收集和派发更新</span>
<span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">Observer</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Observer</span></span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ···
    <span class="token comment">// 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。</span>
    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 数组处理</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ···
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对象处理</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">def</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> enumerable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> val<span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span>enumerable<span class="token punctuation">,</span> <span class="token comment">// 是否可枚举</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>Observer</code>会为<code>data</code>添加一个<code>__ob__</code>属性， <code>__ob__</code>属性是作为响应式对象的标志，同时<code>def</code>方法确保了该属性是不可枚举属性，即外界无法通过遍历获取该属性值。除了标志响应式对象外，<code>Observer</code>类还调用了原型上的<code>walk</code>方法，遍历对象上每个属性进行<code>getter,setter</code>的改写。</p>
<pre class="language-js"><code class="language-js"><span class="token class-name">Observer</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">walk</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">walk</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取对象所有属性，遍历调用defineReactive###1进行改写</span>
    <span class="token keyword">var</span> keys <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        defineReactive###<span class="token number">1</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>defineReactive###1</code>是响应式构建的核心，它会先<strong>实例化一个<code>Dep</code>类，即为每个数据都创建一个依赖的管理</strong>，之后利用<code>Object.defineProperty</code>重写<code>getter,setter</code>方法。这里我们只分析依赖收集的代码。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> defineReactive###<span class="token number">1</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">,</span>customSetter<span class="token punctuation">,</span>shallow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每个数据实例化一个Dep类，创建一个依赖的管理</span>
    <span class="token keyword">var</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> property <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 属性必须满足可配置</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span><span class="token property-access">configurable</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// cater for pre-defined getter/setters</span>
    <span class="token keyword">var</span> getter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span><span class="token property-access">get</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> setter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span><span class="token property-access">set</span><span class="token punctuation">;</span>
    <span class="token comment">// 这一部分的逻辑是针对深层次的对象，如果对象的属性是一个对象，则会递归调用实例化Observe类，让其属性值也转换为响应式对象</span>
    <span class="token keyword">var</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>s
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> getter<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 为当前watcher添加dep数据</span>
          dep<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            childOb<span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">dependArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword control-flow">return</span> value
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>主要看<code>getter</code>的逻辑，我们知道当<code>data</code>中属性值被访问时，会被<code>getter</code>函数拦截，根据我们旧有的知识体系可以知道，实例挂载前会创建一个渲染<code>watcher</code>。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">before</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">_isMounted</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span><span class="token property-access">_isDestroyed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>与此同时，<code>updateComponent</code>的逻辑会执行实例的挂载，在这个过程中，模板会被优先解析为<code>render</code>函数，而<code>render</code>函数转换成<code>Vnode</code>时，会访问到定义的<code>data</code>数据，这个时候会触发<code>gettter</code>进行依赖收集。而此时数据收集的依赖就是这个渲染<code>watcher</code>本身。</p>
<p>代码中依赖收集阶段会做下面几件事：</p>
<ol>
<li><strong>为当前的<code>watcher</code>(该场景下是渲染<code>watcher</code>)添加拥有的数据</strong>。</li>
<li><strong>为当前的数据收集需要监听的依赖</strong></li>
</ol>
<p>如何理解这两点？我们先看代码中的实现。<code>getter</code>阶段会执行<code>dep.depend()</code>,这是<code>Dep</code>这个类定义在原型上的方法。</p>
<pre class="language-js"><code class="language-js">dep<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">depend</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">.</span><span class="token method function property-access">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>Dep.target</code>为当前执行的<code>watcher</code>,在渲染阶段，<code>Dep.target</code>为组件挂载时实例化的渲染<code>watcher</code>,因此<code>depend</code>方法又会调用当前<code>watcher</code>的<code>addDep</code>方法为<code>watcher</code>添加依赖的数据。</p>
<pre class="language-js"><code class="language-js"><span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">addDep</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">addDep</span> <span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> id <span class="token operator">=</span> dep<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDepIds</span><span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// newDepIds和newDeps记录watcher拥有的数据</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDepIds</span><span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDeps</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 避免重复添加同一个data收集器</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">depIds</span><span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token method function property-access">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>其中<code>newDepIds</code>是具有唯一成员是<code>Set</code>数据结构，<code>newDeps</code>是数组，他们用来记录当前<code>watcher</code>所拥有的数据，这一过程会进行逻辑判断，避免同一数据添加多次。</p>
<p><code>addSub</code>为每个数据依赖收集器添加需要被监听的<code>watcher</code>。</p>
<pre class="language-js"><code class="language-js"><span class="token class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">addSub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">addSub</span> <span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//将当前watcher添加到数据依赖收集器中</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ol start="3">
<li><strong><code>getter</code>如果遇到属性值为对象时，会为该对象的每个值收集依赖</strong></li>
</ol>
<p>这句话也很好理解，如果我们将一个值为基本类型的响应式数据改变成一个对象，此时新增对象里的属性，也需要设置成响应式数据。</p>
<ol start="4">
<li><strong>遇到属性值为数组时，进行特殊处理</strong>，这点放到后面讲。</li>
</ol>
<p><strong>通俗的总结一下依赖收集的过程，每个数据就是一个依赖管理器，而每个使用数据的地方就是一个依赖。当访问到数据时，会将当前访问的场景作为一个依赖收集到依赖管理器中，同时也会为这个场景的依赖收集拥有的数据。</strong></p>
<h3 id="793-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.9.3 派发更新<a class="anchor" href="#793-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">§</a></h3>
<p>在分析依赖收集的过程中，可能会有不少困惑，为什么要维护这么多的关系？在数据更新时，这些关系会起到什么作用？带着疑惑，我们来看看派发更新的过程。
在数据发生改变时，会执行定义好的<code>setter</code>方法，我们先看源码。</p>
<pre class="language-js"><code class="language-js"><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  ···
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> getter<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>
      <span class="token comment">// 新值和旧值相等时，跳出操作</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>newVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span>
      <span class="token punctuation">}</span>
      ···
      <span class="token comment">// 新值为对象时，会为新对象进行依赖收集过程</span>
      childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
      dep<span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>派发更新阶段会做以下几件事：</p>
<ul>
<li><strong>判断数据更改前后是否一致，如果数据相等则不进行任何派发更新操作</strong>。</li>
<li><strong>新值为对象时，会对该值的属性进行依赖收集过程</strong>。</li>
<li><strong>通知该数据收集的<code>watcher</code>依赖,遍历每个<code>watcher</code>进行数据更新</strong>,这个阶段是调用该数据依赖收集器的<code>dep.notify</code>方法进行更新的派发。</li>
</ul>
<pre class="language-js"><code class="language-js"><span class="token class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">notify</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">notify</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token property-access">async</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 根据依赖的id进行排序</span>
      subs<span class="token punctuation">.</span><span class="token method function property-access">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> a<span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">-</span> b<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 遍历每个依赖，进行更新数据操作。</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li><strong>更新时会将每个<code>watcher</code>推到队列中，等待下一个<code>tick</code>到来时取出每个<code>watcher</code>进行<code>run</code>操作</strong></li>
</ul>
<pre class="language-js"><code class="language-js"> <span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ···
    <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>queueWatcher</code>方法的调用，会将数据所收集的依赖依次推到<code>queue</code>数组中,数组会在下一个事件循环<code>'tick'</code>中根据缓冲结果进行视图更新。而在执行视图更新过程中，难免会因为数据的改变而在渲染模板上添加新的依赖，这样又会执行<code>queueWatcher</code>的过程。所以需要有一个标志位来记录是否处于异步更新过程的队列中。这个标志位为<code>flushing</code>,当处于异步更新过程时，新增的<code>watcher</code>会插入到<code>queue</code>中。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">queueWatcher</span> <span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> id <span class="token operator">=</span> watcher<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>
    <span class="token comment">// 保证同一个watcher只执行一次</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flushing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        queue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> index <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">></span> watcher<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          i<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        queue<span class="token punctuation">.</span><span class="token method function property-access">splice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      ···
      <span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<p><code>nextTick</code>的原理和实现先不讲，概括来说，<code>nextTick</code>会缓冲多个数据处理过程，等到下一个事件循环<code>tick</code>中再去执行<code>DOM</code>操作，<strong>它的原理，本质是利用事件循环的微任务队列实现异步更新</strong>。</p>
<p>当下一个<code>tick</code>到来时，会执行<code>flushSchedulerQueue</code>方法，它会拿到收集的<code>queue</code>数组(这是一个<code>watcher</code>的集合),并对数组依赖进行排序。为什么进行排序呢？源码中解释了三点：</p>
<blockquote>
<ul>
<li>组件创建是先父后子，所以组件的更新也是先父后子，因此需要保证父的渲染<code>watcher</code>优先于子的渲染<code>watcher</code>更新。</li>
<li><strong>用户自定义的<code>watcher</code>,称为<code>user watcher</code>。 <code>user watcher</code>和<code>render watcher</code>执行也有先后，由于<code>user watchers</code>比<code>render watcher</code>要先创建，所以<code>user watcher</code>要优先执行</strong>。</li>
<li>如果一个组件在父组件的 <code>watcher</code> 执行阶段被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过。</li>
</ul>
</blockquote>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">flushSchedulerQueue</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentFlushTimestamp <span class="token operator">=</span> <span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    flushing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> watcher<span class="token punctuation">,</span> id<span class="token punctuation">;</span>
    <span class="token comment">// 对queue的watcher进行排序</span>
    queue<span class="token punctuation">.</span><span class="token method function property-access">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> a<span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">-</span> b<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环执行queue.length，为了确保由于渲染时添加新的依赖导致queue的长度不断改变。</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 如果watcher定义了before的配置，则优先执行before方法</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span><span class="token property-access">before</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        watcher<span class="token punctuation">.</span><span class="token method function property-access">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      id <span class="token operator">=</span> watcher<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>
      has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
      watcher<span class="token punctuation">.</span><span class="token method function property-access">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// in dev build, check and stop circular updates.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        circular<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>circular<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>circular<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token constant">MAX_UPDATE_COUNT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token string">'You may have an infinite update loop '</span> <span class="token operator">+</span> <span class="token punctuation">(</span>
              watcher<span class="token punctuation">.</span><span class="token property-access">user</span>
                <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">"in watcher with expression \""</span> <span class="token operator">+</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span><span class="token property-access">expression</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span>
                <span class="token operator">:</span> <span class="token string">"in a component render function."</span>
            <span class="token punctuation">)</span><span class="token punctuation">,</span>
            watcher<span class="token punctuation">.</span><span class="token property-access">vm</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword control-flow">break</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// keep copies of post queues before resetting state</span>
    <span class="token keyword">var</span> activatedQueue <span class="token operator">=</span> activatedChildren<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> updatedQueue <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 重置恢复状态，清空队列</span>
    <span class="token function">resetSchedulerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 视图改变后，调用其他钩子</span>
    <span class="token function">callActivatedHooks</span><span class="token punctuation">(</span>activatedQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callUpdatedHooks</span><span class="token punctuation">(</span>updatedQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// devtool hook</span>
    <span class="token comment">/* istanbul ignore if */</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>devtools <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span><span class="token property-access">devtools</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      devtools<span class="token punctuation">.</span><span class="token method function property-access">emit</span><span class="token punctuation">(</span><span class="token string">'flush'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<p><code>flushSchedulerQueue</code>阶段，重要的过程可以总结为四点：</p>
<blockquote>
<ul>
<li>对<code>queue</code>中的<code>watcher</code>进行排序，原因上面已经总结。</li>
<li>遍历<code>watcher</code>,如果当前<code>watcher</code>有<code>before</code>配置，则执行<code>before</code>方法，对应前面的渲染<code>watcher</code>:在渲染<code>watcher</code>实例化时，我们传递了<code>before</code>函数，即在下个<code>tick</code>更新视图前，会调用<code>beforeUpdate</code>生命周期钩子。</li>
<li>执行<code>watcher.run</code>进行修改的操作。</li>
<li>重置恢复状态，这个阶段会将一些流程控制的状态变量恢复为初始值，并清空记录<code>watcher</code>的队列。</li>
</ul>
</blockquote>
<pre class="language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">before</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">_isMounted</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span><span class="token property-access">_isDestroyed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>重点看看<code>watcher.run()</code>的操作。</p>
<pre class="language-js"><code class="language-js"><span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">run</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">active</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span> value <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">||</span> <span class="token function">isObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deep</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置新值</span>
        <span class="token keyword">var</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token comment">// 针对user watcher，暂时不分析</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">cb</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">vm</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">vm</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"callback for watcher \""</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">expression</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">cb</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">vm</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>首先会执行<code>watcher.prototype.get</code>的方法，得到数据变化后的当前值，之后会对新值做判断，如果判断满足条件，则执行<code>cb</code>,<code>cb</code>为实例化<code>watcher</code>时传入的回调。</p>
<p>在分析<code>get</code>方法前，回头看看<code>watcher</code>构造函数的几个属性定义</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">watcher</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Watcher</span></span><span class="token punctuation">(</span>
  vm<span class="token punctuation">,</span> <span class="token comment">// 组件实例</span>
  expOrFn<span class="token punctuation">,</span> <span class="token comment">// 执行函数</span>
  cb<span class="token punctuation">,</span> <span class="token comment">// 回调</span>
  options<span class="token punctuation">,</span> <span class="token comment">// 配置</span>
  isRenderWatcher <span class="token comment">// 是否为渲染watcher</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">vm</span> <span class="token operator">=</span> vm<span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>isRenderWatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token property-access">_watcher</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vm<span class="token punctuation">.</span><span class="token property-access">_watchers</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// options</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deep</span> <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span><span class="token property-access">deep</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">user</span> <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazy</span> <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span><span class="token property-access">lazy</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">sync</span> <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span><span class="token property-access">sync</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">before</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">before</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deep</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">user</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazy</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">sync</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cb</span> <span class="token operator">=</span> cb<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">=</span> <span class="token operator">++</span>uid$<span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// uid for batching</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">active</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">dirty</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazy</span><span class="token punctuation">;</span> <span class="token comment">// for lazy watchers</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deps</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDeps</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">depIds</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">_Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDepIds</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">_Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">expression</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">.</span><span class="token method function property-access">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// parse expression for getter</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> expOrFn <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> noop<span class="token punctuation">;</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token string">"Failed watching path: \""</span> <span class="token operator">+</span> expOrFn <span class="token operator">+</span> <span class="token string">"\" "</span> <span class="token operator">+</span>
          <span class="token string">'Watcher only accepts simple dot-delimited paths. '</span> <span class="token operator">+</span>
          <span class="token string">'For full control, use a function instead.'</span><span class="token punctuation">,</span>
          vm
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// lazy为计算属性标志，当watcher为计算watcher时，不会理解执行get方法进行求值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazy</span>
      <span class="token operator">?</span> <span class="token keyword nil">undefined</span>
      <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
<span class="token punctuation">}</span>
</code></pre>
<p>方法<code>get</code>的定义如下：</p>
<pre class="language-js"><code class="language-js"><span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> value<span class="token punctuation">;</span>
    <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">vm</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
      value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getter</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     ···
    <span class="token punctuation">}</span> <span class="token keyword control-flow">finally</span> <span class="token punctuation">{</span>
      ···
      <span class="token comment">// 把Dep.target恢复到上一个状态，依赖收集过程完成</span>
      <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">cleanupDeps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> value
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>get</code>方法会执行<code>this.getter</code>进行求值，在当前渲染<code>watcher</code>的条件下,<code>getter</code>会执行视图更新的操作。这一阶段会<strong>重新渲染页面组件</strong></p>
<pre class="language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function-variable function">before</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token method function property-access">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token method function property-access">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>执行完<code>getter</code>方法后，最后一步会进行依赖的清除，也就是<code>cleanupDeps</code>的过程。</p>
<blockquote>
<p>关于依赖清除的作用，我们列举一个场景： 我们经常会使用<code>v-if</code>来进行模板的切换，切换过程中会执行不同的模板渲染，如果A模板监听a数据，B模板监听b数据，当渲染模板B时，如果不进行旧依赖的清除，在B模板的场景下，a数据的变化同样会引起依赖的重新渲染更新，这会造成性能的浪费。因此旧依赖的清除在优化阶段是有必要。</p>
</blockquote>
<pre class="language-js"><code class="language-js"><span class="token comment">// 依赖清除的过程</span>
  <span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">cleanupDeps</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">cleanupDeps</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deps</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> dep <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deps</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDepIds</span><span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>dep<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token method function property-access">removeSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">depIds</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">depIds</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDepIds</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDepIds</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDepIds</span><span class="token punctuation">.</span><span class="token method function property-access">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deps</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">deps</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDeps</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDeps</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">newDeps</span><span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>把上面分析的总结成依赖派发更新的最后两个点</p>
<ul>
<li><strong>执行<code>run</code>操作会执行<code>getter</code>方法,也就是重新计算新值，针对渲染<code>watcher</code>而言，会重新执行<code>updateComponent</code>进行视图更新</strong></li>
<li><strong>重新计算<code>getter</code>后，会进行依赖的清除</strong></li>
</ul>
<h2 id="710-computed">7.10 computed<a class="anchor" href="#710-computed">§</a></h2>
<p>计算属性设计的初衷是用于简单运算的，毕竟在模板中放入太多的逻辑会让模板过重且难以维护。在分析<code>computed</code>时，我们依旧遵循依赖收集和派发更新两个过程进行分析。</p>
<h3 id="7101-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.10.1 依赖收集<a class="anchor" href="#7101-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">§</a></h3>
<p><code>computed</code>的初始化过程，<strong>会遍历<code>computed</code>的每一个属性值，并为每一个属性实例化一个<code>computed watcher</code></strong>，其中<code>{ lazy: true}</code>是<code>computed watcher</code>的标志，最终会调用<code>defineComputed</code>将数据设置为响应式数据，对应源码如下：</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initComputed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
  <span class="token keyword control-flow">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>
        vm<span class="token punctuation">,</span>
        getter <span class="token operator">||</span> noop<span class="token punctuation">,</span>
        noop<span class="token punctuation">,</span>
        computedWatcherOptions
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// computed watcher的标志，lazy属性为true</span>
<span class="token keyword">var</span> computedWatcherOptions <span class="token operator">=</span> <span class="token punctuation">{</span> lazy<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>defineComputed</code>的逻辑和分析<code>data</code>的逻辑相似，最终调用<code>Object.defineProperty</code>进行数据拦截。具体的定义如下：</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">defineComputed</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>userDef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 非服务端渲染会对getter进行缓存</span>
  <span class="token keyword">var</span> shouldCache <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// </span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token property-access">get</span> <span class="token operator">=</span> shouldCache
      <span class="token operator">?</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">createGetterInvoker</span><span class="token punctuation">(</span>userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token property-access">set</span> <span class="token operator">=</span> noop<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token property-access">get</span> <span class="token operator">=</span> userDef<span class="token punctuation">.</span><span class="token property-access">get</span>
      <span class="token operator">?</span> shouldCache <span class="token operator">&amp;&amp;</span> userDef<span class="token punctuation">.</span><span class="token property-access">cache</span> <span class="token operator">!==</span> <span class="token boolean">false</span>
        <span class="token operator">?</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">createGetterInvoker</span><span class="token punctuation">(</span>userDef<span class="token punctuation">.</span><span class="token property-access">get</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> noop<span class="token punctuation">;</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token property-access">set</span> <span class="token operator">=</span> userDef<span class="token punctuation">.</span><span class="token property-access">set</span> <span class="token operator">||</span> noop<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>sharedPropertyDefinition<span class="token punctuation">.</span><span class="token property-access">set</span> <span class="token operator">===</span> noop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token punctuation">(</span><span class="token string">"Computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" was assigned to but it has no setter."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">this</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在非服务端渲染的情形，计算属性的计算结果会被缓存，缓存的意义在于，<strong>只有在相关响应式数据发生变化时，<code>computed</code>才会重新求值，其余情况多次访问计算属性的值都会返回之前计算的结果，这就是缓存的优化</strong>，<code>computed</code>属性有两种写法，一种是函数，另一种是对象，其中对象的写法需要提供<code>getter</code>和<code>setter</code>方法。</p>
<p>当访问到<code>computed</code>属性时，会触发<code>getter</code>方法进行依赖收集，看看<code>createComputedGetter</code>的实现。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createComputedGetter</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">function</span> <span class="token function">computedGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">_computedWatchers</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">_computedWatchers</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span><span class="token property-access">dirty</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          watcher<span class="token punctuation">.</span><span class="token method function property-access">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          watcher<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword control-flow">return</span> watcher<span class="token punctuation">.</span><span class="token property-access">value</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<p><code>createComputedGetter</code>返回的函数在执行过程中会先拿到属性的<code>computed watcher</code>,<code>dirty</code>是标志是否已经执行过计算结果，如果执行过则不会执行<code>watcher.evaluate</code>重复计算，这也是缓存的原理。</p>
<pre class="language-js"><code class="language-js"><span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">evaluate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">evaluate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于计算属性而言 evaluate的作用是执行计算回调</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">dirty</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>get</code>方法前面介绍过，会调用实例化<code>watcher</code>时传递的执行函数，在<code>computer watcher</code>的场景下，执行函数是计算属性的计算函数，他可以是一个函数，也可以是对象的<code>getter</code>方法。</p>
<blockquote>
<p>列举一个场景避免和<code>data</code>的处理脱节，<code>computed</code>在计算阶段，如果访问到<code>data</code>数据的属性值，会触发<code>data</code>数据的<code>getter</code>方法进行依赖收集，根据前面分析，<code>data</code>的<code>Dep</code>收集器会将当前<code>watcher</code>作为依赖进行收集，而这个<code>watcher</code>就是<code>computed watcher</code>，并且会为当前的<code>watcher</code>添加访问的数据<code>Dep</code></p>
</blockquote>
<p>回到计算执行函数的<code>this.get()</code>方法，<code>getter</code>执行完成后同样会进行依赖的清除，原理和目的参考<code>data</code>阶段的分析。<code>get</code>执行完毕后会进入<code>watcher.depend</code>进行依赖的收集。收集过程和<code>data</code>一致,将当前的<code>computed watcher</code>作为依赖收集到数据的依赖收集器<code>Dep</code>中。</p>
<p>这就是<code>computed</code>依赖收集的完整过程，对比<code>data</code>的依赖收集，<code>computed</code>会对运算的结果进行缓存，避免重复执行运算过程。</p>
<h3 id="7102-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.10.2 派发更新<a class="anchor" href="#7102-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">§</a></h3>
<p>派发更新的条件是<code>data</code>中数据发生改变，所以大部分的逻辑和分析<code>data</code>时一致，我们做一个总结。</p>
<ul>
<li>当计算属性依赖的数据发生更新时，由于数据的<code>Dep</code>收集过<code>computed watch</code>这个依赖，所以会调用<code>dep</code>的<code>notify</code>方法，对依赖进行状态更新。</li>
<li>此时<code>computed watcher</code>和之前介绍的<code>watcher</code>不同，它不会立刻执行依赖的更新操作，而是通过一个<code>dirty</code>进行标记。我们再回头看<code>依赖更新</code>的代码。</li>
</ul>
<pre class="language-js"><code class="language-js"><span class="token class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">notify</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
   <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 计算属性分支  </span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">dirty</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">sync</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>由于<code>lazy</code>属性的存在，<code>update</code>过程不会执行状态更新的操作，只会将<code>dirty</code>标记为<code>true</code>。</p>
<ul>
<li>由于<code>data</code>数据拥有渲染<code>watcher</code>这个依赖，所以同时会执行<code>updateComponent</code>进行视图重新渲染,而<code>render</code>过程中会访问到计算属性,此时由于<code>this.dirty</code>值为<code>true</code>,又会对计算属性重新求值。</li>
</ul>
<h2 id="711-%E5%B0%8F%E7%BB%93">7.11 小结<a class="anchor" href="#711-%E5%B0%8F%E7%BB%93">§</a></h2>
<p>我们在上一节的理论基础上深入分析了<code>Vue</code>如何利用<code>data,computed</code>构建响应式系统。响应式系统的核心是利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>进行拦截处理，处理的核心是在访问数据时对数据所在场景的依赖进行收集，在数据发生更改时，通知收集过的依赖进行更新。这一节我们详细的介绍了<code>data,computed</code>对响应式的处理，两者处理逻辑存在很大的相似性但却各有的特性。源码中会<code>computed</code>的计算结果进行缓存，避免了在多个地方使用时频繁重复计算的问题。由于篇幅有限，对于用户自定义的<code>watcher</code>我们会放到下一小节分析。文章还留有一个疑惑，依赖收集时如果遇到的数据是数组时应该怎么处理，这些疑惑都会在之后的文章一一解开。</p></article><div class="prev_next"><a class="prev button" href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-上.html">«  <!-- -->7.深入响应式系统构建-上</a><a class="next button" href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-下.html">7.深入响应式系统构建-下<!-- -->  »</a></div></div><aside class="main_toc_container nav_link_container"><div class="main_toc"><nav class="toc"><ol><li><a href="#78-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">7.8 相关概念</a></li><li><a href="#79-data">7.9 data</a><ol><li><a href="#791-%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83">7.9.1 问题思考</a></li><li><a href="#792-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.9.2 依赖收集</a></li><li><a href="#793-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.9.3 派发更新</a></li></ol></li><li><a href="#710-computed">7.10 computed</a><ol><li><a href="#7101-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.10.1 依赖收集</a></li><li><a href="#7102-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.10.2 派发更新</a></li></ol></li><li><a href="#711-%E5%B0%8F%E7%BB%93">7.11 小结</a></li></ol></nav></div></aside></section><footer>Powered by&amp;nbsp;<a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><div class="tools flex_center hide_on_mobile"><a class="czs-angle-up-l button" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-angle-up-l.svg&quot;)"></a></div><script src="https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/In-depth-analysis-of-Vue/index.js"></script></body></html>