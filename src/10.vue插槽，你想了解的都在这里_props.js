import projectConfig from '/In-depth-analysis-of-Vue/pagic.config.js';
export default {
    'prev': {
        "text": "9.揭秘Vue的事件机制",
        "link": "src/9.揭秘Vue的事件机制.html"
    },
    'next': {
        "text": "11.你真的了解v-model的语法糖了吗",
        "link": "src/11.你真的了解v-model的语法糖了吗.html"
    },
    config: { "root": "/", ...projectConfig, branch: 'pagic' },
    'pagePath': "src/10.vue插槽，你想了解的都在这里.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "src/10.vue插槽，你想了解的都在这里.html",
    'title': undefined,
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>Vue组件的另一个重要概念是插槽，它允许你以一种不同于严格的父子关系的方式组合组件。插槽为你提供了一个将内容放置到新位置或使组件更通用的出口。这一节将围绕官网对插槽内容的介绍思路，按照普通插槽，具名插槽，再到作用域插槽的思路，逐步深入内部的实现原理,有对插槽使用不熟悉的，可以先参考官网对<a href="https://cn.vuejs.org/v2/guide/components-slots.html">插槽</a>的介绍。</p>\n</blockquote>\n<h2 id="101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD">10.1 普通插槽<a class="anchor" href="#101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>插槽将<code>&lt;slot&gt;&lt;/slot&gt;</code>作为子组件承载分发的载体，简单的用法如下</p>\n<h3 id="1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">10.1.1 基础用法<a class="anchor" href="#1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">§</a></h3>\n<pre class="language-autoit"><code class="language-autoit">var child <span class="token operator">=</span> {\n  template<span class="token punctuation">:</span> `<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span><span class="token operator">&lt;</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>`\n}\nvar vm <span class="token operator">=</span> new <span class="token function">Vue</span><span class="token punctuation">(</span>{\n  el<span class="token punctuation">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token punctuation">:</span> {\n    child\n  }<span class="token punctuation">,</span>\n  template<span class="token punctuation">:</span> `<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span><span class="token operator">&lt;</span>child<span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>`\n}<span class="token punctuation">)</span>\n<span class="token operator">/</span><span class="token operator">/</span> 最终渲染结果\n<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre>\n<h3 id="1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86">10.1.2 组件挂载原理<a class="anchor" href="#1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86">§</a></h3>\n<p>插槽的原理，贯穿了整个组件系统编译到渲染的过程，所以首先需要回顾一下对组件相关编译渲染流程，简单总结一下几点：</p>\n<ol>\n<li>从根实例入手进行实例的挂载，如果有手写的<code>render</code>函数，则直接进入<code>$mount</code>挂载流程。</li>\n<li>只有<code>template</code>模板则需要对模板进行解析，这里分为两个阶段，一个是将模板解析为<code>AST</code>树，另一个是根据不同平台生成执行代码，例如<code>render</code>函数。</li>\n<li><code>$mount</code>流程也分为两步，第一步是将<code>render</code>函数生成<code>Vnode</code>树，如果遇到子组件会先生成子组件，子组件会以<code>vue-componet-</code>为<code>tag</code>标记，另一步是把<code>Vnode</code>渲染成真正的DOM节点。</li>\n<li>创建真实节点过程中，如果遇到子的占位符组件会进行子组件的实例化过程，这个过程又将回到流程的第一步。</li>\n</ol>\n<p>接下来我们对<code>slot</code>的分析将围绕这四个具体的流程展开。</p>\n<h3 id="1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86">10.1.3 父组件处理<a class="anchor" href="#1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86">§</a></h3>\n<p>回到组件实例流程中，父组件会优先于子组件进行实例的挂载，模板的解析和<code>render</code>函数的生成阶段在处理上没有特殊的差异，这里就不展开分析。接下来是<code>render</code>函数生成<code>Vnode</code>的过程，在这个阶段会遇到子的占位符节点(即：<code>child</code>),因此会为子组件创建子的<code>Vnode</code>。<code>createComponent</code>执行了创建子占位节点<code>Vnode</code>的过程。我们把重点放在最终<code>Vnode</code>代码的生成。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 创建子Vnode过程</span>\n  <span class="token keyword">function</span> <span class="token function">createComponent</span> <span class="token punctuation">(</span>\n    <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> <span class="token comment">// 子类构造器</span>\n    data<span class="token punctuation">,</span>\n    context<span class="token punctuation">,</span> <span class="token comment">// vm实例</span>\n    children<span class="token punctuation">,</span> <span class="token comment">// 父组件需要分发的内容</span>\n    tag <span class="token comment">// 子组件占位符</span>\n  <span class="token punctuation">)</span><span class="token punctuation">{</span>\n    ···\n    <span class="token comment">// 创建子vnode，其中父保留的children属性会以选项的形式传递给Vnode</span>\n    <span class="token keyword">var</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>\n      <span class="token punctuation">(</span><span class="token string">"vue-component-"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">cid</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>name <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      data<span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>\n      <span class="token punctuation">{</span> <span class="token maybe-class-name">Ctor</span><span class="token operator">:</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> propsData<span class="token operator">:</span> propsData<span class="token punctuation">,</span> listeners<span class="token operator">:</span> listeners<span class="token punctuation">,</span> tag<span class="token operator">:</span> tag<span class="token punctuation">,</span> children<span class="token operator">:</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      asyncFactory\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token comment">// Vnode构造器</span>\n<span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">VNode</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">VNode</span></span> <span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span>data<span class="token punctuation">,</span>children<span class="token punctuation">,</span>text<span class="token punctuation">,</span>elm<span class="token punctuation">,</span>context<span class="token punctuation">,</span>componentOptions<span class="token punctuation">,</span>asyncFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">componentOptions</span> <span class="token operator">=</span> componentOptions<span class="token punctuation">;</span> <span class="token comment">// 子组件的选项相关</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>createComponent</code>函数接收的第四个参数<code>children</code>就是父组件需要分发的内容。在创建子<code>Vnode</code>过程中，会以会<code>componentOptions</code>配置传入<code>Vnode</code>构造器中。<strong>最终<code>Vnode</code>中父组件需要分发的内容以<code>componentOptions</code>属性的形式存在，这是插槽分析的第一步</strong>。</p>\n<h3 id="1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B">10.1.4 子组件流程<a class="anchor" href="#1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B">§</a></h3>\n<p>父组件的最后一个阶段是将<code>Vnode</code>渲染为真正的DOM节点，在这个过程中如果遇到子<code>Vnode</code>会优先实例化子组件并进行一系列子组件的渲染流程。子组件初始化会先调用<code>_init</code>方法，并且和父组件不同的是，子组件会调用<code>initInternalComponent</code>方法拿到父组件拥有的相关配置信息，并赋值给子组件自身的配置选项。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 子组件的初始化</span>\n<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span><span class="token property-access">_isComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">initInternalComponent</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">constructor</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> parentVnode <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">parent</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">parent</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span> <span class="token operator">=</span> parentVnode<span class="token punctuation">;</span>\n    <span class="token comment">// componentOptions为子vnode记录的相关信息</span>\n    <span class="token keyword">var</span> vnodeComponentOptions <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span><span class="token property-access">componentOptions</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">propsData</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">propsData</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_parentListeners</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">listeners</span><span class="token punctuation">;</span>\n    <span class="token comment">// 父组件需要分发的内容赋值给子选项配置的_renderChildren</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_renderChildren</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_componentTag</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">tag</span><span class="token punctuation">;</span>\n\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">render</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      opts<span class="token punctuation">.</span><span class="token property-access">render</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">render</span><span class="token punctuation">;</span>\n      opts<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>最终在<strong>子组件实例的配置中拿到了父组件保存的分发内容，记录在组件实例<code>$options._renderChildren</code>中，这是第二步的重点</strong>。</p>\n<p>接下来是子组件的实例化会进入<code>initRender</code>阶段，在这个过程会<strong>将配置的<code>_renderChildren</code>属性做规范化处理，并将他赋值给子实例上的<code>$slot</code>属性，这是第三步的重点</strong>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initRender</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  vm<span class="token punctuation">.</span><span class="token property-access">$slots</span> <span class="token operator">=</span> <span class="token function">resolveSlots</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">_renderChildren</span><span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// $slots拿到了子占位符节点的_renderchildren(即需要分发的内容)，保留作为子实例的属性</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">resolveSlots</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span>context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// children是父组件需要分发到子组件的Vnode节点，如果不存在，则没有分发内容</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>children <span class="token operator">||</span> <span class="token operator">!</span>children<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">var</span> slots <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> data <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>\n      <span class="token comment">// remove slot attribute if the node is resolved as a Vue slot node</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">delete</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// named slots should only be respected if the vnode was rendered in the</span>\n      <span class="token comment">// same context.</span>\n      <span class="token comment">// 分支1为具名插槽的逻辑，放后分析</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">context</span> <span class="token operator">===</span> context <span class="token operator">||</span> child<span class="token punctuation">.</span><span class="token property-access">fnContext</span> <span class="token operator">===</span> context<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>\n        data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">slot</span> <span class="token operator">!=</span> <span class="token keyword null nil">null</span>\n      <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">var</span> name <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>\n        <span class="token keyword">var</span> slot <span class="token operator">=</span> <span class="token punctuation">(</span>slots<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>slots<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">tag</span> <span class="token operator">===</span> <span class="token string">\'template\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          slot<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> child<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n          slot<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 普通插槽的重点，核心逻辑是构造{ default: [children] }对象返回</span>\n        <span class="token punctuation">(</span>slots<span class="token punctuation">.</span><span class="token keyword module">default</span> <span class="token operator">||</span> <span class="token punctuation">(</span>slots<span class="token punctuation">.</span><span class="token keyword module">default</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> slots\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>其中普通插槽的处理逻辑核心在<code>(slots.default || (slots.default = [])).push(child);</code>，即以数组的形式赋值给<code>default</code>属性，并以<code>$slot</code>属性的形式保存在子组件的实例中。</p>\n<p>随后子组件也会走挂载的流程，同样会经历<code>template</code>模板到<code>render</code>函数，再到<code>Vnode</code>,最后渲染真实<code>DOM</code>的过程。解析<code>AST</code>阶段，<code>slot</code>标签和其他普通标签处理相同，<strong>不同之处在于<code>AST</code>生成<code>render</code>函数阶段，对<code>slot</code>标签的处理，会使用<code>_t函数</code>进行包裹。这是关键步骤的第四步</strong></p>\n<p>子组件渲染的大致流程简单梳理如下:</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// ast 生成 render函数</span>\n<span class="token keyword">var</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// generate实现</span>\n<span class="token keyword">function</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token parameter">ast<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> state <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CodegenState</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> code <span class="token operator">=</span> ast <span class="token operator">?</span> <span class="token function">genElement</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'_c("div")\'</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n    render<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token string">"with(this){return "</span> <span class="token operator">+</span> code <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    staticRenderFns<span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// genElement实现</span>\n<span class="token keyword">function</span> <span class="token function">genElement</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 针对slot标签的处理走```genSlot```分支</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span><span class="token property-access">tag</span> <span class="token operator">===</span> <span class="token string">\'slot\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token function">genSlot</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 核心genSlot原理</span>\n<span class="token keyword">function</span> <span class="token function">genSlot</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// slotName记录着插槽的唯一标志名，默认为default</span>\n    <span class="token keyword">var</span> slotName <span class="token operator">=</span> el<span class="token punctuation">.</span><span class="token property-access">slotName</span> <span class="token operator">||</span> <span class="token string">\'"default"\'</span><span class="token punctuation">;</span>\n    <span class="token comment">// 如果子组件的插槽还有子元素，则会递归调执行子元素的创建过程</span>\n    <span class="token keyword">var</span> children <span class="token operator">=</span> <span class="token function">genChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 通过_t函数包裹</span>\n    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token string">"_t("</span> <span class="token operator">+</span> slotName <span class="token operator">+</span> <span class="token punctuation">(</span>children <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">","</span> <span class="token operator">+</span> children<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 具名插槽的其他处理</span>\n    ···    \n    <span class="token keyword control-flow">return</span> res <span class="token operator">+</span> <span class="token string">\')\'</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>最终子组件的<code>render</code>函数为：</p>\n<pre class="language-js"><code class="language-js"><span class="token string">"with(this){return _c(\'div\',{staticClass:"</span>child<span class="token string">"},[_t("</span><span class="token keyword module">default</span><span class="token string">")],2)}"</span>\n</code></pre>\n<p><strong>第五步到了子组件渲染为<code>Vnode</code>的过程。<code>render</code>函数执行阶段会执行<code>_t()</code>函数，<code>_t</code>函数是<code>renderSlot</code>函数简写，它会在<code>Vnode</code>树中进行分发内容的替换</strong>，具体看看实现逻辑。</p>\n<pre class="language-js"><code class="language-js">\n<span class="token comment">// target._t = renderSlot;</span>\n\n<span class="token comment">// render函数渲染Vnode函数</span>\n<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> _parentVnode <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>_parentVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// slots的规范化处理并赋值给$scopedSlots属性。</span>\n    vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span> <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>\n      _parentVnode<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">.</span><span class="token property-access">scopedSlots</span><span class="token punctuation">,</span>\n      vm<span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">,</span> <span class="token comment">// 记录父组件的插槽内容</span>\n      vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>normalizeScopedSlots</code>的逻辑较长，但并不是本节的重点。拿到<code>$scopedSlots</code>属性后会执行真正的<code>render</code>函数,其中<code>_t</code>的执行逻辑如下：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 渲染slot组件内容</span>\n  <span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>\n    name<span class="token punctuation">,</span>\n    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容(针对后备内容)</span>\n    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值(作用域插槽)</span>\n    bindObject\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// scopedSlotFn拿到父组件插槽的执行函数，默认slotname为default</span>\n    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>\n    <span class="token comment">// 具名插槽分支(暂时忽略)</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>\n      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">\'slot v-bind without argument expects an Object\'</span><span class="token punctuation">,</span>\n            <span class="token keyword">this</span>\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>\n      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果父占位符组件没有插槽内容，this.$slots不会有值，此时vnode节点为后备内容节点。</span>\n      nodes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">var</span> target <span class="token operator">=</span> props <span class="token operator">&amp;&amp;</span> props<span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$createElement</span><span class="token punctuation">(</span><span class="token string">\'template\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> slot<span class="token operator">:</span> target <span class="token punctuation">}</span><span class="token punctuation">,</span> nodes<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> nodes\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p><code>renderSlot</code>执行过程会拿到父组件需要分发的内容，最终<code>Vnode</code>树将父元素的插槽替换掉子组件的<code>slot</code>组件。</p>\n<p><strong>最后一步就是子组件真实节点的渲染了，这点没有什么特别点，和以往介绍的流程一致</strong>。</p>\n<p>至此，一个完整且简单的插槽流程分析完毕。接下来看插槽深层次的用法。</p>\n<h2 id="102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD">10.2 具有后备内容的插槽<a class="anchor" href="#102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。查看源码发现后备内容插槽的逻辑也很好理解。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div class="child">&lt;slot>后备内容&lt;/slot>&lt;/div></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token operator">:</span> <span class="token punctuation">{</span>\n    child\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 父没有插槽内容，子的slot会渲染后备内容</span>\n<span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span>后备内容<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre>\n<p>父组件没有需要分发的内容，子组件会默认显示插槽里面的内容。源码中的不同体现在下面的几点。</p>\n<ol>\n<li>父组件渲染过程由于没有需要分发的子节点，所以不再需要拥有<code>componentOptions.children</code>属性来记录内容。</li>\n<li>因此子组件也拿不到<code>$slot</code>属性的内容.</li>\n<li>子组件的<code>render</code>函数最后在<code>_t</code>函数参数会携带第二个参数，该参数以数组的形式传入<code>slot</code>插槽的后备内容。例<code>with(this){return _c(\'div\',{staticClass:&quot;child&quot;},[_t(&quot;default&quot;,[_v(&quot;test&quot;)])],2)}</code></li>\n<li>渲染子<code>Vnode</code>会执行<code>renderSlot(即：_t)</code>函数时，第二个参数<code>fallback</code>有值，且<code>this.$slots</code>没值，<code>vnode</code>会直接返回后备内容作为渲染对象。</li>\n</ol>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>\n    name<span class="token punctuation">,</span>\n    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容(针对后备内容)</span>\n    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值(作用域插槽)</span>\n    bindObject\n<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      ···\n    <span class="token punctuation">}</span><span class="token keyword control-flow">else</span><span class="token punctuation">{</span>\n      <span class="token comment">//fallback为后备内容</span>\n      <span class="token comment">// 如果父占位符组件没有插槽内容，this.$slots不会有值，此时vnode节点为后备内容节点。</span>\n      nodes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n    \n</code></pre>\n<p>最终，在父组件没有提供内容时，<code>slot</code>的后备内容被渲染。</p>\n<p>有了这些基础，我们再来看官网给的一条规则。</p>\n<blockquote>\n<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>\n</blockquote>\n<p>父组件模板的内容在父组件编译阶段就确定了,并且保存在<code>componentOptions</code>属性中，而子组件有自身初始化<code>init</code>的过程，这个过程同样会进行子作用域的模板编译，因此两部分内容是相对独立的。</p>\n<h2 id="103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">10.3 具名插槽<a class="anchor" href="#103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>往往我们需要灵活的使用插槽进行通用组件的开发，要求父组件每个模板对应子组件中每个插槽，这时我们可以使用<code>&lt;slot&gt;</code>的<code>name</code>属性，同样举个简单的例子。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div class="child">&lt;slot name="header">&lt;/slot>&lt;slot name="footer">&lt;/slot>&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token operator">:</span> <span class="token punctuation">{</span>\n    child\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;template v-slot:header>&lt;span>头部&lt;/span>&lt;/template>&lt;template v-slot:footer>&lt;span>底部&lt;/span>&lt;/template>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>渲染结果：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>头部<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>底部<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre>\n<p>接下来我们在普通插槽的基础上，看看源码在具名插槽实现上的区别。</p>\n<h3 id="1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB">10.3.1 模板编译的差别<a class="anchor" href="#1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB">§</a></h3>\n<p>父组件在编译<code>AST</code>阶段和普通节点的过程不同，具名插槽一般会在<code>template</code>模板中用<code>v-slot:</code>来标注指定插槽，这一阶段会在编译阶段特殊处理。最终的<code>AST</code>树会携带<code>scopedSlots</code>用来记录具名插槽的内容</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n  scopedSlots： <span class="token punctuation">{</span>\n    footer<span class="token operator">:</span> <span class="token punctuation">{</span> ··· <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    header<span class="token operator">:</span> <span class="token punctuation">{</span> ··· <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>AST</code>生成<code>render</code>函数的过程也不详细分析了，我们只分析父组件最终返回的结果(如果对<code>parse, generate</code>感兴趣的同学，可以直接看源码分析,编译阶段冗长且难以讲解，跳过这部分分析)</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>scopedSlots<span class="token operator">:</span><span class="token function">_u</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"header"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'span\'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">"头部"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>proxy<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"footer"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'span\'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">"底部"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>proxy<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<p>很明显，父组件的插槽内容用<code>_u</code>函数封装成数组的形式，并赋值到<code>scopedSlots</code>属性中，而每一个插槽以对象形式描述，<code>key</code>代表插槽名，<code>fn</code>是一个返回执行结果的函数。</p>\n<h3 id="1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">10.3.2 父组件vnode生成阶段<a class="anchor" href="#1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">§</a></h3>\n<p>照例进入父组件生成<code>Vnode</code>阶段，其中<code>_u</code>函数的原形是<code>resolveScopedSlots</code>,其中第一个参数就是插槽数组。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// vnode生成阶段针对具名插槽的处理 _u      (target._u = resolveScopedSlots)</span>\n  <span class="token keyword">function</span> <span class="token function">resolveScopedSlots</span> <span class="token punctuation">(</span><span class="token parameter">fns<span class="token punctuation">,</span>res<span class="token punctuation">,</span>hasDynamicKeys<span class="token punctuation">,</span>contentHashKey</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    res <span class="token operator">=</span> res <span class="token operator">||</span> <span class="token punctuation">{</span> $stable<span class="token operator">:</span> <span class="token operator">!</span>hasDynamicKeys <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fns<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> slot <span class="token operator">=</span> fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token comment">// fn是数组需要递归处理。</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>slot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">resolveScopedSlots</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> res<span class="token punctuation">,</span> hasDynamicKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// marker for reverse proxying v-slot without scope on this.$slots</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">.</span><span class="token property-access">proxy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//  针对proxy的处理</span>\n          slot<span class="token punctuation">.</span><span class="token property-access">fn</span><span class="token punctuation">.</span><span class="token property-access">proxy</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 最终返回一个对象，对象以slotname作为属性，以fn作为值</span>\n        res<span class="token punctuation">[</span>slot<span class="token punctuation">.</span><span class="token property-access">key</span><span class="token punctuation">]</span> <span class="token operator">=</span> slot<span class="token punctuation">.</span><span class="token property-access">fn</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>contentHashKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">$key</span> <span class="token operator">=</span> contentHashKey<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> res\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>最终父组件的<code>vnode</code>节点的<code>data</code>属性上多了<code>scopedSlots</code>数组。<strong>回顾一下，具名插槽和普通插槽实现上有明显的不同，普通插槽是以<code>componentOptions.child</code>的形式保留在父组件中，而具名插槽是以<code>scopedSlots</code>属性的形式存储到<code>data</code>属性中。</strong></p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// vnode</span>\n<span class="token punctuation">{</span>\n  scopedSlots<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n    <span class="token string">\'header\'</span><span class="token operator">:</span> fn<span class="token punctuation">,</span>\n    <span class="token string">\'footer\'</span><span class="token operator">:</span> fn\n  <span class="token punctuation">}</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B">10.3.3 子组件渲染Vnode过程<a class="anchor" href="#1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B">§</a></h3>\n<p>子组件在解析成<code>AST</code>树阶段的不同，在于对<code>slot</code>标签的<code>name</code>属性的解析,而在<code>render</code>生成<code>Vnode</code>过程中，<code>slot</code>的规范化处理针对具名插槽会进行特殊的处理，回到<code>normalizeScopedSlots</code>的代码</p>\n<pre class="language-js"><code class="language-js">vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span> <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>\n  _parentVnode<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">.</span><span class="token property-access">scopedSlots</span><span class="token punctuation">,</span> <span class="token comment">// 此时的第一个参数会拿到父组件插槽相关的数据</span>\n  vm<span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">,</span> <span class="token comment">// 记录父组件的插槽内容</span>\n  vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre>\n<p>最终子组件实例上的<code>$scopedSlots</code>属性会携带父组件插槽相关的内容。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 子组件Vnode</span>\n<span class="token punctuation">{</span>\n  $scopedSlots<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n    <span class="token string">\'header\'</span><span class="token operator">:</span> f<span class="token punctuation">,</span>\n    <span class="token string">\'footer\'</span><span class="token operator">:</span> f\n  <span class="token punctuation">}</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom">10.3.4 子组件渲染真实dom<a class="anchor" href="#1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom">§</a></h3>\n<p>和普通插槽类似，子组件渲染真实节点的过程会执行子<code>render</code>函数中的<code>_t</code>方法，这部分的源码会和普通插槽走不同的分支，其中<code>this.$scopedSlots</code>根据上面分析会记录着父组件插槽内容相关的数据，所以会和普通插槽走不同的分支。而最终的核心是执行<code>nodes = scopedSlotFn(props)</code>,也就是执行<code>function(){return [_c(\'span\',[_v(&quot;头部&quot;)])]}</code>,具名插槽之所以是函数的形式执行而不是直接返回结果，我们在后面揭晓。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>\n    name<span class="token punctuation">,</span>\n    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容</span>\n    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值</span>\n    bindObject\n  <span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>\n    <span class="token comment">// 针对具名插槽，特点是$scopedSlots有值</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>\n      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">\'slot v-bind without argument expects an Object\'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>\n      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>···\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>至此子组件通过<code>slotName</code>找到了对应父组件的插槽内容。</p>\n<h2 id="104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">10.4 作用域插槽<a class="anchor" href="#104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>最后说说作用域插槽，我们可以利用作用域插槽让父组件的插槽内容访问到子组件的数据，具体的用法是在子组件中以属性的方式记录在子组件中，父组件通过<code>v-slot:[name]=[props]</code>的形式拿到子组件传递的值。子组件<code>&lt;slot&gt;</code>元素上的特性称为<strong>插槽<code>Props</code></strong>,另外，vue2.6以后的版本已经弃用了<code>slot-scoped</code>，采用<code>v-slot</code>代替。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>&lt;slot :user="user">&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n      user<span class="token operator">:</span> <span class="token punctuation">{</span>\n        firstname<span class="token operator">:</span> <span class="token string">\'test\'</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token operator">:</span> <span class="token punctuation">{</span>\n    child\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;template v-slot:default="slotProps">{{slotProps.user.firstname}}&lt;/template>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>作用域插槽和具名插槽的原理类似，我们接着往下看。</p>\n<h3 id="1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">10.4.1 父组件编译阶段<a class="anchor" href="#1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">§</a></h3>\n<p>作用域插槽和具名插槽在父组件的用法基本相同，区别在于<code>v-slot</code>定义了一个插槽<code>props</code>的名字，参考对于具名插槽的分析，生成<code>render</code>函数阶段<code>fn</code>函数会携带<code>props</code>参数传入。即：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>scopedSlots<span class="token operator">:</span><span class="token function">_u</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">slotProps</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>slotProps<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">.</span><span class="token property-access">firstname</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<h3 id="1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">10.4.2 子组件渲染<a class="anchor" href="#1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">§</a></h3>\n<p>在子组件编译阶段，<code>:user=&quot;user&quot;</code>会以属性的形式解析，最终在<code>render</code>函数生成阶段以对象参数的形式传递<code>_t</code>函数。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_t</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"user"</span><span class="token operator">:</span>user<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<p>子组件渲染Vnode阶段，根据前面分析会执行<code>renderSlot</code>函数，这个函数前面分析过，对于作用域插槽的处理，集中体现在函数传入的第三个参数。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 渲染slot组件vnode</span>\n<span class="token keyword">function</span> <span class="token function">renderSlot</span><span class="token punctuation">(</span>\n  name<span class="token punctuation">,</span>\n  fallback<span class="token punctuation">,</span>\n  props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值 { user: user }</span>\n  bindObject\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// scopedSlotFn拿到父组件插槽的执行函数，默认slotname为default</span>\n    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>\n    <span class="token comment">// 具名插槽分支</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>\n      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">\'slot v-bind without argument expects an Object\'</span><span class="token punctuation">,</span>\n            <span class="token keyword">this</span>\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 合并props</span>\n        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>\n      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre>\n<p>最终将子组件的插槽<code>props</code>作为参数传递给执行函数执行。<strong>回过头看看为什么具名插槽是函数的形式执行而不是直接返回结果。学完作用域插槽我们发现这就是设计巧妙的地方，函数的形式让执行过程更加灵活，作用域插槽只需要以参数的形式将插槽<code>props</code>传入便可以得到想要的结果。</strong></p>\n<h3 id="1043-%E6%80%9D%E8%80%83">10.4.3 思考<a class="anchor" href="#1043-%E6%80%9D%E8%80%83">§</a></h3>\n<p>作用域插槽这个概念一开始我很难理解，单纯从定义和源码的结论上看，父组件的插槽内容可以访问到子组件的数据，这不是明显的子父之间的信息通信吗，在事件章节我们知道，子父组件之间的通信完全可以通过事件<code>$emit,$on</code>的形式来完成，那么为什么还需要增加一个插槽<code>props</code>的概念呢。我们看看作者的解释。</p>\n<blockquote>\n<p>插槽 <code>prop</code> 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 <code>prop</code> 渲染出不同的内容</p>\n</blockquote>\n<p>从我自身的角度理解，作用域插槽提供了一种方式，当你需要封装一个通用，可复用的逻辑模块，并且这个模块给外部使用者提供了一个便利，允许你在使用组件时自定义部分布局，这时候作用域插槽就派上大用场了，再到具体的思想，我们可以看看几个工具库<a href="https://github.com/Akryum/vue-virtual-scroller">Vue Virtual Scroller</a>, <a href="https://github.com/posva/vue-promised">Vue Promised</a>对这一思想的应用。</p>'
        } }),
    'head': null,
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://unpkg.com/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://unpkg.com/react-dom@17/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/In-depth-analysis-of-Vue/index.js", type: "module" })),
    'footer': React.createElement("footer", null,
        "Powered by\u00A0",
        React.createElement("a", { href: "https://github.com/xcatliu/pagic", target: "_blank" }, "Pagic")),
    'contentTitle': undefined,
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>Vue组件的另一个重要概念是插槽，它允许你以一种不同于严格的父子关系的方式组合组件。插槽为你提供了一个将内容放置到新位置或使组件更通用的出口。这一节将围绕官网对插槽内容的介绍思路，按照普通插槽，具名插槽，再到作用域插槽的思路，逐步深入内部的实现原理,有对插槽使用不熟悉的，可以先参考官网对<a href="https://cn.vuejs.org/v2/guide/components-slots.html">插槽</a>的介绍。</p>\n</blockquote>\n<h2 id="101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD">10.1 普通插槽<a class="anchor" href="#101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>插槽将<code>&lt;slot&gt;&lt;/slot&gt;</code>作为子组件承载分发的载体，简单的用法如下</p>\n<h3 id="1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">10.1.1 基础用法<a class="anchor" href="#1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">§</a></h3>\n<pre class="language-autoit"><code class="language-autoit">var child <span class="token operator">=</span> {\n  template<span class="token punctuation">:</span> `<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span><span class="token operator">&lt;</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>`\n}\nvar vm <span class="token operator">=</span> new <span class="token function">Vue</span><span class="token punctuation">(</span>{\n  el<span class="token punctuation">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token punctuation">:</span> {\n    child\n  }<span class="token punctuation">,</span>\n  template<span class="token punctuation">:</span> `<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span><span class="token operator">&lt;</span>child<span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>`\n}<span class="token punctuation">)</span>\n<span class="token operator">/</span><span class="token operator">/</span> 最终渲染结果\n<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre>\n<h3 id="1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86">10.1.2 组件挂载原理<a class="anchor" href="#1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86">§</a></h3>\n<p>插槽的原理，贯穿了整个组件系统编译到渲染的过程，所以首先需要回顾一下对组件相关编译渲染流程，简单总结一下几点：</p>\n<ol>\n<li>从根实例入手进行实例的挂载，如果有手写的<code>render</code>函数，则直接进入<code>$mount</code>挂载流程。</li>\n<li>只有<code>template</code>模板则需要对模板进行解析，这里分为两个阶段，一个是将模板解析为<code>AST</code>树，另一个是根据不同平台生成执行代码，例如<code>render</code>函数。</li>\n<li><code>$mount</code>流程也分为两步，第一步是将<code>render</code>函数生成<code>Vnode</code>树，如果遇到子组件会先生成子组件，子组件会以<code>vue-componet-</code>为<code>tag</code>标记，另一步是把<code>Vnode</code>渲染成真正的DOM节点。</li>\n<li>创建真实节点过程中，如果遇到子的占位符组件会进行子组件的实例化过程，这个过程又将回到流程的第一步。</li>\n</ol>\n<p>接下来我们对<code>slot</code>的分析将围绕这四个具体的流程展开。</p>\n<h3 id="1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86">10.1.3 父组件处理<a class="anchor" href="#1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86">§</a></h3>\n<p>回到组件实例流程中，父组件会优先于子组件进行实例的挂载，模板的解析和<code>render</code>函数的生成阶段在处理上没有特殊的差异，这里就不展开分析。接下来是<code>render</code>函数生成<code>Vnode</code>的过程，在这个阶段会遇到子的占位符节点(即：<code>child</code>),因此会为子组件创建子的<code>Vnode</code>。<code>createComponent</code>执行了创建子占位节点<code>Vnode</code>的过程。我们把重点放在最终<code>Vnode</code>代码的生成。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 创建子Vnode过程</span>\n  <span class="token keyword">function</span> <span class="token function">createComponent</span> <span class="token punctuation">(</span>\n    <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> <span class="token comment">// 子类构造器</span>\n    data<span class="token punctuation">,</span>\n    context<span class="token punctuation">,</span> <span class="token comment">// vm实例</span>\n    children<span class="token punctuation">,</span> <span class="token comment">// 父组件需要分发的内容</span>\n    tag <span class="token comment">// 子组件占位符</span>\n  <span class="token punctuation">)</span><span class="token punctuation">{</span>\n    ···\n    <span class="token comment">// 创建子vnode，其中父保留的children属性会以选项的形式传递给Vnode</span>\n    <span class="token keyword">var</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>\n      <span class="token punctuation">(</span><span class="token string">"vue-component-"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">cid</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>name <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      data<span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>\n      <span class="token punctuation">{</span> <span class="token maybe-class-name">Ctor</span><span class="token operator">:</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> propsData<span class="token operator">:</span> propsData<span class="token punctuation">,</span> listeners<span class="token operator">:</span> listeners<span class="token punctuation">,</span> tag<span class="token operator">:</span> tag<span class="token punctuation">,</span> children<span class="token operator">:</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      asyncFactory\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token comment">// Vnode构造器</span>\n<span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">VNode</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">VNode</span></span> <span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span>data<span class="token punctuation">,</span>children<span class="token punctuation">,</span>text<span class="token punctuation">,</span>elm<span class="token punctuation">,</span>context<span class="token punctuation">,</span>componentOptions<span class="token punctuation">,</span>asyncFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">componentOptions</span> <span class="token operator">=</span> componentOptions<span class="token punctuation">;</span> <span class="token comment">// 子组件的选项相关</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>createComponent</code>函数接收的第四个参数<code>children</code>就是父组件需要分发的内容。在创建子<code>Vnode</code>过程中，会以会<code>componentOptions</code>配置传入<code>Vnode</code>构造器中。<strong>最终<code>Vnode</code>中父组件需要分发的内容以<code>componentOptions</code>属性的形式存在，这是插槽分析的第一步</strong>。</p>\n<h3 id="1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B">10.1.4 子组件流程<a class="anchor" href="#1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B">§</a></h3>\n<p>父组件的最后一个阶段是将<code>Vnode</code>渲染为真正的DOM节点，在这个过程中如果遇到子<code>Vnode</code>会优先实例化子组件并进行一系列子组件的渲染流程。子组件初始化会先调用<code>_init</code>方法，并且和父组件不同的是，子组件会调用<code>initInternalComponent</code>方法拿到父组件拥有的相关配置信息，并赋值给子组件自身的配置选项。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 子组件的初始化</span>\n<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span><span class="token property-access">_isComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">initInternalComponent</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">constructor</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> parentVnode <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">parent</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">parent</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span> <span class="token operator">=</span> parentVnode<span class="token punctuation">;</span>\n    <span class="token comment">// componentOptions为子vnode记录的相关信息</span>\n    <span class="token keyword">var</span> vnodeComponentOptions <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span><span class="token property-access">componentOptions</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">propsData</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">propsData</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_parentListeners</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">listeners</span><span class="token punctuation">;</span>\n    <span class="token comment">// 父组件需要分发的内容赋值给子选项配置的_renderChildren</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_renderChildren</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">;</span>\n    opts<span class="token punctuation">.</span><span class="token property-access">_componentTag</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">tag</span><span class="token punctuation">;</span>\n\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">render</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      opts<span class="token punctuation">.</span><span class="token property-access">render</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">render</span><span class="token punctuation">;</span>\n      opts<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>最终在<strong>子组件实例的配置中拿到了父组件保存的分发内容，记录在组件实例<code>$options._renderChildren</code>中，这是第二步的重点</strong>。</p>\n<p>接下来是子组件的实例化会进入<code>initRender</code>阶段，在这个过程会<strong>将配置的<code>_renderChildren</code>属性做规范化处理，并将他赋值给子实例上的<code>$slot</code>属性，这是第三步的重点</strong>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initRender</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  vm<span class="token punctuation">.</span><span class="token property-access">$slots</span> <span class="token operator">=</span> <span class="token function">resolveSlots</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">_renderChildren</span><span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// $slots拿到了子占位符节点的_renderchildren(即需要分发的内容)，保留作为子实例的属性</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">resolveSlots</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span>context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// children是父组件需要分发到子组件的Vnode节点，如果不存在，则没有分发内容</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>children <span class="token operator">||</span> <span class="token operator">!</span>children<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">var</span> slots <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> data <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>\n      <span class="token comment">// remove slot attribute if the node is resolved as a Vue slot node</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">delete</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// named slots should only be respected if the vnode was rendered in the</span>\n      <span class="token comment">// same context.</span>\n      <span class="token comment">// 分支1为具名插槽的逻辑，放后分析</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">context</span> <span class="token operator">===</span> context <span class="token operator">||</span> child<span class="token punctuation">.</span><span class="token property-access">fnContext</span> <span class="token operator">===</span> context<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>\n        data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">slot</span> <span class="token operator">!=</span> <span class="token keyword null nil">null</span>\n      <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">var</span> name <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>\n        <span class="token keyword">var</span> slot <span class="token operator">=</span> <span class="token punctuation">(</span>slots<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>slots<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">tag</span> <span class="token operator">===</span> <span class="token string">\'template\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          slot<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> child<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n          slot<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 普通插槽的重点，核心逻辑是构造{ default: [children] }对象返回</span>\n        <span class="token punctuation">(</span>slots<span class="token punctuation">.</span><span class="token keyword module">default</span> <span class="token operator">||</span> <span class="token punctuation">(</span>slots<span class="token punctuation">.</span><span class="token keyword module">default</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> slots\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>其中普通插槽的处理逻辑核心在<code>(slots.default || (slots.default = [])).push(child);</code>，即以数组的形式赋值给<code>default</code>属性，并以<code>$slot</code>属性的形式保存在子组件的实例中。</p>\n<p>随后子组件也会走挂载的流程，同样会经历<code>template</code>模板到<code>render</code>函数，再到<code>Vnode</code>,最后渲染真实<code>DOM</code>的过程。解析<code>AST</code>阶段，<code>slot</code>标签和其他普通标签处理相同，<strong>不同之处在于<code>AST</code>生成<code>render</code>函数阶段，对<code>slot</code>标签的处理，会使用<code>_t函数</code>进行包裹。这是关键步骤的第四步</strong></p>\n<p>子组件渲染的大致流程简单梳理如下:</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// ast 生成 render函数</span>\n<span class="token keyword">var</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// generate实现</span>\n<span class="token keyword">function</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token parameter">ast<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> state <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CodegenState</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> code <span class="token operator">=</span> ast <span class="token operator">?</span> <span class="token function">genElement</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'_c("div")\'</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n    render<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token string">"with(this){return "</span> <span class="token operator">+</span> code <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    staticRenderFns<span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// genElement实现</span>\n<span class="token keyword">function</span> <span class="token function">genElement</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 针对slot标签的处理走```genSlot```分支</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span><span class="token property-access">tag</span> <span class="token operator">===</span> <span class="token string">\'slot\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token function">genSlot</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 核心genSlot原理</span>\n<span class="token keyword">function</span> <span class="token function">genSlot</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// slotName记录着插槽的唯一标志名，默认为default</span>\n    <span class="token keyword">var</span> slotName <span class="token operator">=</span> el<span class="token punctuation">.</span><span class="token property-access">slotName</span> <span class="token operator">||</span> <span class="token string">\'"default"\'</span><span class="token punctuation">;</span>\n    <span class="token comment">// 如果子组件的插槽还有子元素，则会递归调执行子元素的创建过程</span>\n    <span class="token keyword">var</span> children <span class="token operator">=</span> <span class="token function">genChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 通过_t函数包裹</span>\n    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token string">"_t("</span> <span class="token operator">+</span> slotName <span class="token operator">+</span> <span class="token punctuation">(</span>children <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">","</span> <span class="token operator">+</span> children<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 具名插槽的其他处理</span>\n    ···    \n    <span class="token keyword control-flow">return</span> res <span class="token operator">+</span> <span class="token string">\')\'</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>最终子组件的<code>render</code>函数为：</p>\n<pre class="language-js"><code class="language-js"><span class="token string">"with(this){return _c(\'div\',{staticClass:"</span>child<span class="token string">"},[_t("</span><span class="token keyword module">default</span><span class="token string">")],2)}"</span>\n</code></pre>\n<p><strong>第五步到了子组件渲染为<code>Vnode</code>的过程。<code>render</code>函数执行阶段会执行<code>_t()</code>函数，<code>_t</code>函数是<code>renderSlot</code>函数简写，它会在<code>Vnode</code>树中进行分发内容的替换</strong>，具体看看实现逻辑。</p>\n<pre class="language-js"><code class="language-js">\n<span class="token comment">// target._t = renderSlot;</span>\n\n<span class="token comment">// render函数渲染Vnode函数</span>\n<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> _parentVnode <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>_parentVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// slots的规范化处理并赋值给$scopedSlots属性。</span>\n    vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span> <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>\n      _parentVnode<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">.</span><span class="token property-access">scopedSlots</span><span class="token punctuation">,</span>\n      vm<span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">,</span> <span class="token comment">// 记录父组件的插槽内容</span>\n      vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>normalizeScopedSlots</code>的逻辑较长，但并不是本节的重点。拿到<code>$scopedSlots</code>属性后会执行真正的<code>render</code>函数,其中<code>_t</code>的执行逻辑如下：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 渲染slot组件内容</span>\n  <span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>\n    name<span class="token punctuation">,</span>\n    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容(针对后备内容)</span>\n    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值(作用域插槽)</span>\n    bindObject\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// scopedSlotFn拿到父组件插槽的执行函数，默认slotname为default</span>\n    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>\n    <span class="token comment">// 具名插槽分支(暂时忽略)</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>\n      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">\'slot v-bind without argument expects an Object\'</span><span class="token punctuation">,</span>\n            <span class="token keyword">this</span>\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>\n      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果父占位符组件没有插槽内容，this.$slots不会有值，此时vnode节点为后备内容节点。</span>\n      nodes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">var</span> target <span class="token operator">=</span> props <span class="token operator">&amp;&amp;</span> props<span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$createElement</span><span class="token punctuation">(</span><span class="token string">\'template\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> slot<span class="token operator">:</span> target <span class="token punctuation">}</span><span class="token punctuation">,</span> nodes<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> nodes\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p><code>renderSlot</code>执行过程会拿到父组件需要分发的内容，最终<code>Vnode</code>树将父元素的插槽替换掉子组件的<code>slot</code>组件。</p>\n<p><strong>最后一步就是子组件真实节点的渲染了，这点没有什么特别点，和以往介绍的流程一致</strong>。</p>\n<p>至此，一个完整且简单的插槽流程分析完毕。接下来看插槽深层次的用法。</p>\n<h2 id="102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD">10.2 具有后备内容的插槽<a class="anchor" href="#102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。查看源码发现后备内容插槽的逻辑也很好理解。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div class="child">&lt;slot>后备内容&lt;/slot>&lt;/div></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token operator">:</span> <span class="token punctuation">{</span>\n    child\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 父没有插槽内容，子的slot会渲染后备内容</span>\n<span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span>后备内容<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre>\n<p>父组件没有需要分发的内容，子组件会默认显示插槽里面的内容。源码中的不同体现在下面的几点。</p>\n<ol>\n<li>父组件渲染过程由于没有需要分发的子节点，所以不再需要拥有<code>componentOptions.children</code>属性来记录内容。</li>\n<li>因此子组件也拿不到<code>$slot</code>属性的内容.</li>\n<li>子组件的<code>render</code>函数最后在<code>_t</code>函数参数会携带第二个参数，该参数以数组的形式传入<code>slot</code>插槽的后备内容。例<code>with(this){return _c(\'div\',{staticClass:&quot;child&quot;},[_t(&quot;default&quot;,[_v(&quot;test&quot;)])],2)}</code></li>\n<li>渲染子<code>Vnode</code>会执行<code>renderSlot(即：_t)</code>函数时，第二个参数<code>fallback</code>有值，且<code>this.$slots</code>没值，<code>vnode</code>会直接返回后备内容作为渲染对象。</li>\n</ol>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>\n    name<span class="token punctuation">,</span>\n    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容(针对后备内容)</span>\n    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值(作用域插槽)</span>\n    bindObject\n<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      ···\n    <span class="token punctuation">}</span><span class="token keyword control-flow">else</span><span class="token punctuation">{</span>\n      <span class="token comment">//fallback为后备内容</span>\n      <span class="token comment">// 如果父占位符组件没有插槽内容，this.$slots不会有值，此时vnode节点为后备内容节点。</span>\n      nodes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n    \n</code></pre>\n<p>最终，在父组件没有提供内容时，<code>slot</code>的后备内容被渲染。</p>\n<p>有了这些基础，我们再来看官网给的一条规则。</p>\n<blockquote>\n<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>\n</blockquote>\n<p>父组件模板的内容在父组件编译阶段就确定了,并且保存在<code>componentOptions</code>属性中，而子组件有自身初始化<code>init</code>的过程，这个过程同样会进行子作用域的模板编译，因此两部分内容是相对独立的。</p>\n<h2 id="103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">10.3 具名插槽<a class="anchor" href="#103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>往往我们需要灵活的使用插槽进行通用组件的开发，要求父组件每个模板对应子组件中每个插槽，这时我们可以使用<code>&lt;slot&gt;</code>的<code>name</code>属性，同样举个简单的例子。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div class="child">&lt;slot name="header">&lt;/slot>&lt;slot name="footer">&lt;/slot>&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token operator">:</span> <span class="token punctuation">{</span>\n    child\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;template v-slot:header>&lt;span>头部&lt;/span>&lt;/template>&lt;template v-slot:footer>&lt;span>底部&lt;/span>&lt;/template>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>渲染结果：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>头部<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>底部<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre>\n<p>接下来我们在普通插槽的基础上，看看源码在具名插槽实现上的区别。</p>\n<h3 id="1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB">10.3.1 模板编译的差别<a class="anchor" href="#1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB">§</a></h3>\n<p>父组件在编译<code>AST</code>阶段和普通节点的过程不同，具名插槽一般会在<code>template</code>模板中用<code>v-slot:</code>来标注指定插槽，这一阶段会在编译阶段特殊处理。最终的<code>AST</code>树会携带<code>scopedSlots</code>用来记录具名插槽的内容</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n  scopedSlots： <span class="token punctuation">{</span>\n    footer<span class="token operator">:</span> <span class="token punctuation">{</span> ··· <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    header<span class="token operator">:</span> <span class="token punctuation">{</span> ··· <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>AST</code>生成<code>render</code>函数的过程也不详细分析了，我们只分析父组件最终返回的结果(如果对<code>parse, generate</code>感兴趣的同学，可以直接看源码分析,编译阶段冗长且难以讲解，跳过这部分分析)</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>scopedSlots<span class="token operator">:</span><span class="token function">_u</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"header"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'span\'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">"头部"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>proxy<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"footer"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'span\'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">"底部"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>proxy<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<p>很明显，父组件的插槽内容用<code>_u</code>函数封装成数组的形式，并赋值到<code>scopedSlots</code>属性中，而每一个插槽以对象形式描述，<code>key</code>代表插槽名，<code>fn</code>是一个返回执行结果的函数。</p>\n<h3 id="1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">10.3.2 父组件vnode生成阶段<a class="anchor" href="#1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">§</a></h3>\n<p>照例进入父组件生成<code>Vnode</code>阶段，其中<code>_u</code>函数的原形是<code>resolveScopedSlots</code>,其中第一个参数就是插槽数组。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// vnode生成阶段针对具名插槽的处理 _u      (target._u = resolveScopedSlots)</span>\n  <span class="token keyword">function</span> <span class="token function">resolveScopedSlots</span> <span class="token punctuation">(</span><span class="token parameter">fns<span class="token punctuation">,</span>res<span class="token punctuation">,</span>hasDynamicKeys<span class="token punctuation">,</span>contentHashKey</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    res <span class="token operator">=</span> res <span class="token operator">||</span> <span class="token punctuation">{</span> $stable<span class="token operator">:</span> <span class="token operator">!</span>hasDynamicKeys <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fns<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> slot <span class="token operator">=</span> fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token comment">// fn是数组需要递归处理。</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>slot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">resolveScopedSlots</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> res<span class="token punctuation">,</span> hasDynamicKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// marker for reverse proxying v-slot without scope on this.$slots</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">.</span><span class="token property-access">proxy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//  针对proxy的处理</span>\n          slot<span class="token punctuation">.</span><span class="token property-access">fn</span><span class="token punctuation">.</span><span class="token property-access">proxy</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 最终返回一个对象，对象以slotname作为属性，以fn作为值</span>\n        res<span class="token punctuation">[</span>slot<span class="token punctuation">.</span><span class="token property-access">key</span><span class="token punctuation">]</span> <span class="token operator">=</span> slot<span class="token punctuation">.</span><span class="token property-access">fn</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>contentHashKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">$key</span> <span class="token operator">=</span> contentHashKey<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> res\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>最终父组件的<code>vnode</code>节点的<code>data</code>属性上多了<code>scopedSlots</code>数组。<strong>回顾一下，具名插槽和普通插槽实现上有明显的不同，普通插槽是以<code>componentOptions.child</code>的形式保留在父组件中，而具名插槽是以<code>scopedSlots</code>属性的形式存储到<code>data</code>属性中。</strong></p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// vnode</span>\n<span class="token punctuation">{</span>\n  scopedSlots<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n    <span class="token string">\'header\'</span><span class="token operator">:</span> fn<span class="token punctuation">,</span>\n    <span class="token string">\'footer\'</span><span class="token operator">:</span> fn\n  <span class="token punctuation">}</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B">10.3.3 子组件渲染Vnode过程<a class="anchor" href="#1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B">§</a></h3>\n<p>子组件在解析成<code>AST</code>树阶段的不同，在于对<code>slot</code>标签的<code>name</code>属性的解析,而在<code>render</code>生成<code>Vnode</code>过程中，<code>slot</code>的规范化处理针对具名插槽会进行特殊的处理，回到<code>normalizeScopedSlots</code>的代码</p>\n<pre class="language-js"><code class="language-js">vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span> <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>\n  _parentVnode<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">.</span><span class="token property-access">scopedSlots</span><span class="token punctuation">,</span> <span class="token comment">// 此时的第一个参数会拿到父组件插槽相关的数据</span>\n  vm<span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">,</span> <span class="token comment">// 记录父组件的插槽内容</span>\n  vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre>\n<p>最终子组件实例上的<code>$scopedSlots</code>属性会携带父组件插槽相关的内容。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 子组件Vnode</span>\n<span class="token punctuation">{</span>\n  $scopedSlots<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n    <span class="token string">\'header\'</span><span class="token operator">:</span> f<span class="token punctuation">,</span>\n    <span class="token string">\'footer\'</span><span class="token operator">:</span> f\n  <span class="token punctuation">}</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom">10.3.4 子组件渲染真实dom<a class="anchor" href="#1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom">§</a></h3>\n<p>和普通插槽类似，子组件渲染真实节点的过程会执行子<code>render</code>函数中的<code>_t</code>方法，这部分的源码会和普通插槽走不同的分支，其中<code>this.$scopedSlots</code>根据上面分析会记录着父组件插槽内容相关的数据，所以会和普通插槽走不同的分支。而最终的核心是执行<code>nodes = scopedSlotFn(props)</code>,也就是执行<code>function(){return [_c(\'span\',[_v(&quot;头部&quot;)])]}</code>,具名插槽之所以是函数的形式执行而不是直接返回结果，我们在后面揭晓。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>\n    name<span class="token punctuation">,</span>\n    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容</span>\n    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值</span>\n    bindObject\n  <span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>\n    <span class="token comment">// 针对具名插槽，特点是$scopedSlots有值</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>\n      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">\'slot v-bind without argument expects an Object\'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>\n      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>···\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>至此子组件通过<code>slotName</code>找到了对应父组件的插槽内容。</p>\n<h2 id="104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">10.4 作用域插槽<a class="anchor" href="#104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">§</a></h2>\n<p>最后说说作用域插槽，我们可以利用作用域插槽让父组件的插槽内容访问到子组件的数据，具体的用法是在子组件中以属性的方式记录在子组件中，父组件通过<code>v-slot:[name]=[props]</code>的形式拿到子组件传递的值。子组件<code>&lt;slot&gt;</code>元素上的特性称为<strong>插槽<code>Props</code></strong>,另外，vue2.6以后的版本已经弃用了<code>slot-scoped</code>，采用<code>v-slot</code>代替。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>&lt;slot :user="user">&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n      user<span class="token operator">:</span> <span class="token punctuation">{</span>\n        firstname<span class="token operator">:</span> <span class="token string">\'test\'</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token operator">:</span> <span class="token punctuation">{</span>\n    child\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;template v-slot:default="slotProps">{{slotProps.user.firstname}}&lt;/template>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>作用域插槽和具名插槽的原理类似，我们接着往下看。</p>\n<h3 id="1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">10.4.1 父组件编译阶段<a class="anchor" href="#1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">§</a></h3>\n<p>作用域插槽和具名插槽在父组件的用法基本相同，区别在于<code>v-slot</code>定义了一个插槽<code>props</code>的名字，参考对于具名插槽的分析，生成<code>render</code>函数阶段<code>fn</code>函数会携带<code>props</code>参数传入。即：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>scopedSlots<span class="token operator">:</span><span class="token function">_u</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">slotProps</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>slotProps<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">.</span><span class="token property-access">firstname</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<h3 id="1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">10.4.2 子组件渲染<a class="anchor" href="#1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">§</a></h3>\n<p>在子组件编译阶段，<code>:user=&quot;user&quot;</code>会以属性的形式解析，最终在<code>render</code>函数生成阶段以对象参数的形式传递<code>_t</code>函数。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_t</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"user"</span><span class="token operator">:</span>user<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<p>子组件渲染Vnode阶段，根据前面分析会执行<code>renderSlot</code>函数，这个函数前面分析过，对于作用域插槽的处理，集中体现在函数传入的第三个参数。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 渲染slot组件vnode</span>\n<span class="token keyword">function</span> <span class="token function">renderSlot</span><span class="token punctuation">(</span>\n  name<span class="token punctuation">,</span>\n  fallback<span class="token punctuation">,</span>\n  props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值 { user: user }</span>\n  bindObject\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// scopedSlotFn拿到父组件插槽的执行函数，默认slotname为default</span>\n    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>\n    <span class="token comment">// 具名插槽分支</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>\n      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">\'slot v-bind without argument expects an Object\'</span><span class="token punctuation">,</span>\n            <span class="token keyword">this</span>\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 合并props</span>\n        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>\n      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre>\n<p>最终将子组件的插槽<code>props</code>作为参数传递给执行函数执行。<strong>回过头看看为什么具名插槽是函数的形式执行而不是直接返回结果。学完作用域插槽我们发现这就是设计巧妙的地方，函数的形式让执行过程更加灵活，作用域插槽只需要以参数的形式将插槽<code>props</code>传入便可以得到想要的结果。</strong></p>\n<h3 id="1043-%E6%80%9D%E8%80%83">10.4.3 思考<a class="anchor" href="#1043-%E6%80%9D%E8%80%83">§</a></h3>\n<p>作用域插槽这个概念一开始我很难理解，单纯从定义和源码的结论上看，父组件的插槽内容可以访问到子组件的数据，这不是明显的子父之间的信息通信吗，在事件章节我们知道，子父组件之间的通信完全可以通过事件<code>$emit,$on</code>的形式来完成，那么为什么还需要增加一个插槽<code>props</code>的概念呢。我们看看作者的解释。</p>\n<blockquote>\n<p>插槽 <code>prop</code> 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 <code>prop</code> 渲染出不同的内容</p>\n</blockquote>\n<p>从我自身的角度理解，作用域插槽提供了一种方式，当你需要封装一个通用，可复用的逻辑模块，并且这个模块给外部使用者提供了一个便利，允许你在使用组件时自定义部分布局，这时候作用域插槽就派上大用场了，再到具体的思想，我们可以看看几个工具库<a href="https://github.com/Akryum/vue-virtual-scroller">Vue Virtual Scroller</a>, <a href="https://github.com/posva/vue-promised">Vue Promised</a>对这一思想的应用。</p>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD" }, "10.1 \u666E\u901A\u63D2\u69FD"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" }, "10.1.1 \u57FA\u7840\u7528\u6CD5")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86" }, "10.1.2 \u7EC4\u4EF6\u6302\u8F7D\u539F\u7406")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86" }, "10.1.3 \u7236\u7EC4\u4EF6\u5904\u7406")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B" }, "10.1.4 \u5B50\u7EC4\u4EF6\u6D41\u7A0B")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD" }, "10.2 \u5177\u6709\u540E\u5907\u5185\u5BB9\u7684\u63D2\u69FD")),
            React.createElement("li", null,
                React.createElement("a", { href: "#103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD" }, "10.3 \u5177\u540D\u63D2\u69FD"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB" }, "10.3.1 \u6A21\u677F\u7F16\u8BD1\u7684\u5DEE\u522B")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5" }, "10.3.2 \u7236\u7EC4\u4EF6vnode\u751F\u6210\u9636\u6BB5")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B" }, "10.3.3 \u5B50\u7EC4\u4EF6\u6E32\u67D3Vnode\u8FC7\u7A0B")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom" }, "10.3.4 \u5B50\u7EC4\u4EF6\u6E32\u67D3\u771F\u5B9Edom")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD" }, "10.4 \u4F5C\u7528\u57DF\u63D2\u69FD"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" }, "10.4.1 \u7236\u7EC4\u4EF6\u7F16\u8BD1\u9636\u6BB5")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93" }, "10.4.2 \u5B50\u7EC4\u4EF6\u6E32\u67D3")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1043-%E6%80%9D%E8%80%83" }, "10.4.3 \u601D\u8003")))))),
    'author': "wyp",
    'contributors': [
        "wyp",
        "hyfun"
    ],
    'date': "2019-10-29T06:12:00.000Z",
    'updated': "2021-09-15T02:34:36.000Z",
    'excerpt': "10.1 普通插槽 插槽将<slot></slot>作为子组件承载分发的载体，简单的用法如下 10.1.1 基础用法 var child = { template: `<div class=\"child\"><slot></slot></div>` } var vm = new Vue({ el: '#app', components: { child },...",
    'cover': undefined,
    'sidebar': [
        {
            "text": "Introduction",
            "link": "introduction/index.html",
            "pagePath": "introduction/README.md"
        },
        {
            "text": "1.丰富的选项合并策略",
            "link": "src/1.丰富的选项合并策略.html",
            "pagePath": "src/1.丰富的选项合并策略.md"
        },
        {
            "text": "2.基础的数据代理检测",
            "link": "src/2.基础的数据代理检测.html",
            "pagePath": "src/2.基础的数据代理检测.md"
        },
        {
            "text": "3.实例挂载流程和模板编译",
            "link": "src/3.实例挂载流程和模板编译.html",
            "pagePath": "src/3.实例挂载流程和模板编译.md"
        },
        {
            "text": "4.完整渲染流程",
            "link": "src/4.完整渲染流程.html",
            "pagePath": "src/4.完整渲染流程.md"
        },
        {
            "text": "5.组件基础剖析",
            "link": "src/5.组件基础剖析.html",
            "pagePath": "src/5.组件基础剖析.md"
        },
        {
            "text": "6.组件高级用法",
            "link": "src/6.组件高级用法.html",
            "pagePath": "src/6.组件高级用法.md"
        },
        {
            "text": "7.深入响应式系统构建-上",
            "link": "src/7.深入响应式系统构建-上.html",
            "pagePath": "src/7.深入响应式系统构建-上.md"
        },
        {
            "text": "7.深入响应式系统构建-中",
            "link": "src/7.深入响应式系统构建-中.html",
            "pagePath": "src/7.深入响应式系统构建-中.md"
        },
        {
            "text": "7.深入响应式系统构建-下",
            "link": "src/7.深入响应式系统构建-下.html",
            "pagePath": "src/7.深入响应式系统构建-下.md"
        },
        {
            "text": "8.来，跟我一起实现diff算法",
            "link": "src/8.来，跟我一起实现diff算法.html",
            "pagePath": "src/8.来，跟我一起实现diff算法.md"
        },
        {
            "text": "9.揭秘Vue的事件机制",
            "link": "src/9.揭秘Vue的事件机制.html",
            "pagePath": "src/9.揭秘Vue的事件机制.md"
        },
        {
            "text": "10.vue插槽，你想了解的都在这里",
            "link": "src/10.vue插槽，你想了解的都在这里.html",
            "pagePath": "src/10.vue插槽，你想了解的都在这里.md"
        },
        {
            "text": "11.你真的了解v-model的语法糖了吗",
            "link": "src/11.你真的了解v-model的语法糖了吗.html",
            "pagePath": "src/11.你真的了解v-model的语法糖了吗.md"
        },
        {
            "text": "12.动态组件的深入分析",
            "link": "src/12.动态组件的深入分析.html",
            "pagePath": "src/12.动态组件的深入分析.md"
        },
        {
            "text": "13.彻底搞懂Vue中keep-alive的魔法-上",
            "link": "src/13.彻底搞懂Vue中keep-alive的魔法-上.html",
            "pagePath": "src/13.彻底搞懂Vue中keep-alive的魔法-上.md"
        },
        {
            "text": "13.彻底搞懂Vue中keep-alive的魔法-下",
            "link": "src/13.彻底搞懂Vue中keep-alive的魔法-下.html",
            "pagePath": "src/13.彻底搞懂Vue中keep-alive的魔法-下.md"
        }
    ]
};
