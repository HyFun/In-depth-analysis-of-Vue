<!doctype html><html class="" data-reactroot=""><head>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:title" content="深入剖析Vue源码"/><meta data-react-helmet="true" property="og:description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary"/>
<title data-react-helmet="true">深入剖析Vue源码</title>
<link data-react-helmet="true" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/In-depth-analysis-of-Vue/assets/prism_tomorrow.css";
    }
  </script>
</head><body><header><h1 class="hide_on_mobile"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1><nav><ul><li class="show_on_mobile flex_center"><a class="czs-menu-l" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-menu-l.svg&quot;)"></a></li><li class="show_on_mobile"><h1 class="mobile_title"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1></li><li class="hide_on_mobile"><a href="https://cn.vuejs.org/index.html" target="_blank">Vue2.x文档</a></li><li class="hide_on_mobile"><a href="https://book.penblog.cn/" target="_blank">历史地址</a></li><li class="hide_on_mobile"><a>赞助作者</a></li><li style="flex-grow:1"></li><li class="flex_center"><a class="czs-github-logo" href="https://github.com/Ocean1509/In-depth-analysis-of-Vue" target="_blank" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-github-logo.svg&quot;)"></a></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon-l.svg&quot;)"></span></li></ul></nav></header><aside class="sidebar"><ol class="list_style_none"><li class=""><a href="/In-depth-analysis-of-Vue/introduction/index.html" class="nav_link">Introduction</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/1.丰富的选项合并策略.html" class="nav_link active">1.丰富的选项合并策略</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/2.基础的数据代理检测.html" class="nav_link">2.基础的数据代理检测</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/3.实例挂载流程和模板编译.html" class="nav_link">3.实例挂载流程和模板编译</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/4.完整渲染流程.html" class="nav_link">4.完整渲染流程</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/5.组件基础剖析.html" class="nav_link">5.组件基础剖析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/6.组件高级用法.html" class="nav_link">6.组件高级用法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-上.html" class="nav_link">7.深入响应式系统构建-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-中.html" class="nav_link">7.深入响应式系统构建-中</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-下.html" class="nav_link">7.深入响应式系统构建-下</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/8.来，跟我一起实现diff算法.html" class="nav_link">8.来，跟我一起实现diff算法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/9.揭秘Vue的事件机制.html" class="nav_link">9.揭秘Vue的事件机制</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/10.vue插槽，你想了解的都在这里.html" class="nav_link">10.vue插槽，你想了解的都在这里</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/11.你真的了解v-model的语法糖了吗.html" class="nav_link">11.你真的了解v-model的语法糖了吗</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/12.动态组件的深入分析.html" class="nav_link">12.动态组件的深入分析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-上.html" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-下.html" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-下</a></li></ol></aside><section class="main"><div class="main_article"><article><h2 id="11-vue%E7%9A%84%E5%BC%95%E5%85%A5">1.1 Vue的引入<a class="anchor" href="#11-vue%E7%9A%84%E5%BC%95%E5%85%A5">§</a></h2>
<p><code>Vue</code>的使用按照官方的说法支持<code>CDN</code>和<code>NPM</code>两种方式，<code>CDN</code>的方式是以<code>script</code>的方式将打包好的<code>vue.js</code>引入页面脚本中，而<code>NPM</code>的方式是和诸如 <code>webpack</code> 或 <code>Browserify</code> 模块打包器配置使用，以<code>npm install vue</code>的方式引入，这也是我们开发应用的主要形式。而从单纯分析源码思路和实现细节的角度来讲，打包后的<code>vue.js</code>在分析和提炼源码方面会更加方便，所以这个系列的源码分析，使用的是打包后的<code>vue</code>脚本，<strong>版本号是<code>v2.6.8</code></strong></p>
<h3 id="111-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">1.1.1 基础使用<a class="anchor" href="#111-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">§</a></h3>
<p>分析的开始当然是<code>vue</code>的基础使用，我们引入了<code>vue.js</code>并且<code>new</code>了一个<code>Vue</code>实例，并将它挂载到<code>#app</code>上，这是最基础的用法。</p>
<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"<a class="token url-link" href="https://cdn.jsdelivr.net/npm/vue@2.6.8/dist/vue.js">https://cdn.jsdelivr.net/npm/vue@2.6.8/dist/vue.js</a>"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    message<span class="token operator">:</span> <span class="token string">'选项合并'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>虽然这一节的重点是阐述<code>Vue</code>的选项配置，从选项配置入手也是我们从零开始品读源码最容易开始的思路，但是为了分析的完整性，避免后续出现未知的概念，有必要先大致了解一下<code>vue</code>在脚本引入之后分别做了什么。</p>
<h3 id="112-vue%E6%9E%84%E9%80%A0%E5%99%A8">1.1.2 Vue构造器<a class="anchor" href="#112-vue%E6%9E%84%E9%80%A0%E5%99%A8">§</a></h3>
<p>打包后的源码是遵从<code>UMD</code>规范的，它是<code>commonjs</code>和<code>amd</code>的整合。而<code>Vue</code>的本质是一个构造器,并且它保证了只能通过<code>new</code>实例的形式去调用，而不能直接通过函数的形式使用。</p>
<pre class="language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">global<span class="token punctuation">,</span> factory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遵循UMD规范</span>
  <span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> module <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">?</span> module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>
  <span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span><span class="token property-access">amd</span> <span class="token operator">?</span> <span class="token function">define</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span> <span class="token operator">:</span>
  <span class="token punctuation">(</span>global <span class="token operator">=</span> global <span class="token operator">||</span> self<span class="token punctuation">,</span> global<span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Vue</span></span> <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token string">'use strict'</span><span class="token punctuation">;</span>
  ···
  <span class="token comment">// Vue 构造函数</span>
  <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Vue</span></span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保证了无法直接通过Vue()去调用，只能通过new的方式去创建实例</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Vue</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'Vue is a constructor and should be called with the `new` keyword'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Vue</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="113-%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">1.1.3 定义原型属性方法<a class="anchor" href="#113-%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">§</a></h3>
<p>Vue之所以能适应基础的开发场景，除了经常提到的支持组件化开发，以及完善的响应式系统等外，还有重要的一点是它提供了丰富的<code>api</code>方法，不管是静态还是原型方法，它们都丰富到足以满足我们日常基础的开发需求。所以熟练阅读<a href="https://cn.vuejs.org/v2/api/">vue-api</a>文档并精准使用<code>api</code>方法是迈向熟练开发的前提。接下来我们看看这些方法属性是在哪里定义的，<strong>注意，该小节会忽略大部分属性方法具体的实现，这些详细的细节会贯穿在后续系列的分析中</strong>。</p>
<p>首先是原型上的属性方法，在构造函数的定义之后，有这样五个函数，他们分别针对不同场景定义了<code>Vue</code>原型上的属性和方法。</p>
<pre class="language-js"><code class="language-js">  <span class="token comment">// 定义Vue原型上的init方法(内部方法)</span>
  <span class="token function">initMixin</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 定义原型上跟数据相关的属性方法</span>
  <span class="token function">stateMixin</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//定义原型上跟事件相关的属性方法</span>
  <span class="token function">eventsMixin</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 定义原型上跟生命周期相关的方法</span>
  <span class="token function">lifecycleMixin</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 定义渲染相关的函数</span>
  <span class="token function">renderMixin</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre>
<p>我们一个个看，首先<code>initMixin</code>定义了<strong>内部在实例化<code>Vue</code>时会执行的初始化代码</strong>，它是一个内部使用的方法。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initMixin</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">Vue</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>stateMixin</code>方法会定义跟数据相关的属性方法，例如代理数据的访问，我们可以在实例上通过<code>this.$data</code>和<code>this.$props</code>访问到<code>data,props</code>的值，并且也定义了使用频率较高的<code>this.$set,this.$delte</code>等方法。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">stateMixin</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">Vue</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> dataDef <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    dataDef<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">_data</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> propsDef <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    propsDef<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">_props</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
      dataDef<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token string">'Avoid replacing instance root $data. '</span> <span class="token operator">+</span>
          <span class="token string">'Use nested data properties instead.'</span><span class="token punctuation">,</span>
          <span class="token keyword">this</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      propsDef<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"$props is readonly."</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 代理了_data,_props的访问</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">,</span> <span class="token string">'$data'</span><span class="token punctuation">,</span> dataDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">,</span> <span class="token string">'$props'</span><span class="token punctuation">,</span> propsDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// $set, $del</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">$set</span> <span class="token operator">=</span> set<span class="token punctuation">;</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">$</span><span class="token keyword">delete</span> <span class="token operator">=</span> del<span class="token punctuation">;</span>

    <span class="token comment">// $watch</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span>cb<span class="token punctuation">,</span>options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<p><code>eventsMixin</code>会对原型上的事件相关方法做定义，文档中提到的<code>vm.$on,vm.$once,vm.$off,vm.$emit</code>也就是在这里定义的。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">eventsMixin</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">Vue</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 自定义事件监听</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$on</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 自定义事件监听,只触发一次</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$once</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 自定义事件解绑</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$off</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 自定义事件通知</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$emit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>lifecycleMixin,renderMixin</code>两个都可以算是对生命周期渲染方法的定义，例如<code>$forceUpdate</code>触发实例的强制刷新，<code>$nextTick</code>将回调延迟到下次 <code>DOM</code> 更新循环之后执行等。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 定义跟生命周期相关的方法</span>
  <span class="token keyword">function</span> <span class="token function">lifecycleMixin</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">Vue</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> hydrating</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$forceUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$destroy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

<span class="token comment">// 定义原型上跟渲染相关的方法</span>
  <span class="token keyword">function</span> <span class="token function">renderMixin</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">Vue</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$nextTick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// _render函数，后面会着重讲</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<h3 id="114-%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">1.1.4 定义静态属性方法<a class="anchor" href="#114-%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">§</a></h3>
<p>除了原型方法外，<code>Vue</code>还提供了丰富的全局<code>api</code>方法，这些都是在<code>initGlobalAPI</code>中定义的。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">/* 初始化构造器的api */</span>
<span class="token keyword">function</span> <span class="token function">initGlobalAPI</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">Vue</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// config</span>
    <span class="token keyword">var</span> configDef <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    configDef<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> config<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
      configDef<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token string">'Do not replace the Vue.config object, set individual fields instead.'</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 通过Vue.config拿到配置信息</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">,</span> <span class="token string">'config'</span><span class="token punctuation">,</span> configDef<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 工具类不作为公共暴露的API使用</span>
    <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">util</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      warn<span class="token operator">:</span> warn<span class="token punctuation">,</span>
      extend<span class="token operator">:</span> extend<span class="token punctuation">,</span>
      mergeOptions<span class="token operator">:</span> mergeOptions<span class="token punctuation">,</span>
      defineReactive<span class="token operator">:</span> defineReactive###<span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// Vue.set = Vue.prototype.$set</span>
    <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">set</span> <span class="token operator">=</span> set<span class="token punctuation">;</span>
    <span class="token comment">// Vue.delete = Vue.prototype.$delete</span>
    <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">delete</span> <span class="token operator">=</span> del<span class="token punctuation">;</span>
    <span class="token comment">// Vue.nextTick = Vue.prototype.$nextTick</span>
    <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">nextTick</span> <span class="token operator">=</span> nextTick<span class="token punctuation">;</span>

    <span class="token comment">// 2.6 explicit observable API</span>
    <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">observable</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">observe</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span> obj
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 构造函数的默认选项默认为components,directive,filter, _base</span>
    <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">ASSET_TYPES</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">[</span>type <span class="token operator">+</span> <span class="token string">'s'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// options里的_base属性存储Vue构造器</span>
    <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">_base</span> <span class="token operator">=</span> <span class="token maybe-class-name">Vue</span><span class="token punctuation">;</span>
    <span class="token function">extend</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">components</span><span class="token punctuation">,</span> builtInComponents<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Vue.use()</span>
    <span class="token function">initUse</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Vue.mixin()</span>
    <span class="token function">initMixin$1</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 定义extend扩展子类构造器的方法</span>
    <span class="token comment">// Vue.extend()</span>
    <span class="token function">initExtend</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Vue.components, Vue.directive, Vue.filter</span>
    <span class="token function">initAssetRegisters</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

</code></pre>
<p>看着源码对静态方法的定义做一个汇总。</p>
<ol>
<li>为源码里的<code>config</code>配置做一层代理，可以通过<code>Vue.config</code>拿到默认的配置，并且可以修改它的属性值，具体哪些可以配置修改，可以先参照官方文档。</li>
<li>定义内部使用的工具方法，例如警告提示，对象合并等。</li>
<li>定义<code>set,delet,nextTick</code>方法，本质上原型上也有这些方法的定义。</li>
<li>对<code>Vue.components,Vue.directive,Vue.filter</code>的定义，这些是默认的资源选项，后续会重点分析。</li>
<li>定义<code>Vue.use()</code>方法</li>
<li>定义<code>Vue.mixin()</code>方法</li>
<li>定义<code>Vue.extend()</code>方法</li>
</ol>
<p>现在我相信你已经对引入<code>Vue</code>的阶段有了一个大致的认识，在源码分析的初期阶段，我们不需要死磕每个方法，思路的实现细节，只需要对大致的结构有基本的认识。有了这些基础，我们开始进入这个章节的主线。</p>
<h2 id="12-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9">1.2 构造器的默认选项<a class="anchor" href="#12-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9">§</a></h2>
<p>我们回到最开始的例子，在实例化<code>Vue</code>时，我们会将选项对象传递给构造器进行初始化，这个选项对象描述了你想要的行为，例如以<code>data</code>定义实例中的响应式数据，以<code>computed</code>描述实例中的计算属性，以<code>components</code>来进行组件注册，甚至是定义各个阶段执行的生命周期钩子等。然而<code>Vue</code>内部本身会自带一些默认的选项，这些选项和用户自定义的选项会在后续一起参与到<code>Vue</code>实例的初始化中。</p>
<p>在<code>initGlobalAPI</code>方法中有几行默认选项的定义。<code>Vue</code>内部的默认选项会保留在静态的<code>options</code>属性上，从源码看<code>Vue</code>自身有四个默认配置选项，分别是<code>component，directive， filter</code>以及返回自身构造器的<code>_base</code>。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token constant">ASSET_TYPES</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'component'</span><span class="token punctuation">,</span>
  <span class="token string">'directive'</span><span class="token punctuation">,</span>
  <span class="token string">'filter'</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 原型上创建了一个指向为空对象的options属性</span>
<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token constant">ASSET_TYPES</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">[</span>type <span class="token operator">+</span> <span class="token string">'s'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">_base</span> <span class="token operator">=</span> <span class="token maybe-class-name">Vue</span><span class="token punctuation">;</span>
</code></pre>
<p>很明显我们开发者对这几个选项是非常熟悉的，<code>components</code>是需要注册的组件选项，<code>directives</code>是需要注册的指令，而<code>filter</code>则代表需要注册的过滤器。从代码的实现细节看，<code>Vue</code>为<code>components</code>提供了<code>keepAlive,transition,transitionGroup</code>的内置组件，为<code>directives</code>提供了<code>v-model,v-show</code>的内置指令，而过滤器则没有默认值。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// Vue内置组件</span>
<span class="token keyword">var</span> builtInComponents <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">KeepAlive</span><span class="token operator">:</span> <span class="token maybe-class-name">KeepAlive</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> platformComponents <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Transition</span><span class="token operator">:</span> <span class="token maybe-class-name">Transition</span><span class="token punctuation">,</span>
  <span class="token maybe-class-name">TransitionGroup</span><span class="token operator">:</span> <span class="token maybe-class-name">TransitionGroup</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Vue 内置指令，例如： v-model, v-show</span>
<span class="token keyword">var</span> platformDirectives <span class="token operator">=</span> <span class="token punctuation">{</span>
  model<span class="token operator">:</span> directive<span class="token punctuation">,</span>
  show<span class="token operator">:</span> show
<span class="token punctuation">}</span>
<span class="token function">extend</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">components</span><span class="token punctuation">,</span> builtInComponents<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">extend</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">components</span><span class="token punctuation">,</span> platformComponents<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩展内置组件</span>
<span class="token function">extend</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">directives</span><span class="token punctuation">,</span> platformDirectives<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 扩展内置指令</span>
</code></pre>
<p>其中<code>extend</code>方法实现了对象的合并，如果属性相同，则用新的属性值覆盖旧值。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 将_from对象合并到to对象，属性相同时，则覆盖to对象的属性</span>
<span class="token keyword">function</span> <span class="token function">extend</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> _from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> _from<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    to<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> _from<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> to
<span class="token punctuation">}</span>
</code></pre>
<p>因此做为构造器而言，<code>Vue</code>默认的资源选项配置如下：</p>
<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">options</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">KeepAlive</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token maybe-class-name">Transition</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token maybe-class-name">TransitionGroup</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  directives<span class="token operator">:</span> <span class="token punctuation">{</span>
    model<span class="token operator">:</span> <span class="token punctuation">{</span>inserted<span class="token operator">:</span> ƒ<span class="token punctuation">,</span> componentUpdated<span class="token operator">:</span> ƒ<span class="token punctuation">}</span>
    show<span class="token operator">:</span> <span class="token punctuation">{</span>bind<span class="token operator">:</span> ƒ<span class="token punctuation">,</span> update<span class="token operator">:</span> ƒ<span class="token punctuation">,</span> unbind<span class="token operator">:</span> ƒ<span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  filters<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  _base
<span class="token punctuation">}</span>
</code></pre>
<h2 id="13-%E9%80%89%E9%A1%B9%E6%A3%80%E9%AA%8C">1.3 选项检验<a class="anchor" href="#13-%E9%80%89%E9%A1%B9%E6%A3%80%E9%AA%8C">§</a></h2>
<p>介绍完<code>Vue</code>自身拥有的选项后，我们回过头来看看，实例化<code>Vue</code>的阶段发生了什么。从构造器的定义我们很容易发现，实例化<code>Vue</code>做的核心操作便是执行<code>_init</code>方法进行初始化。初始化操作会经过选项合并配置，初始化生命周期，初始化事件中心，乃至构建数据响应式系统等。而关键的第一步就是对选项的合并。合并后的选项会挂载到实例的<code>$options</code>属性中。(你可以先在实例中通过<code>this.$options</code>访问最终的选项)</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initMixin</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">Vue</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// a uid</span>
    <span class="token comment">// 记录实例化多少个vue对象</span>
    vm<span class="token punctuation">.</span><span class="token property-access">_uid</span> <span class="token operator">=</span> uid$<span class="token number">3</span><span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token comment">// 选项合并，将合并后的选项赋值给实例的$options属性</span>
    vm<span class="token punctuation">.</span><span class="token property-access">$options</span> <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
      <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">constructor</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 返回Vue构造函数自身的配置项</span>
      options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>从代码中可以看到，选项合并的重点是将用户自身传递的<code>options</code>选项和<code>Vue</code>构造函数自身的选项配置合并。我们看看<code>mergeOptions</code>函数的实现。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mergeOptions</span> <span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span>child<span class="token punctuation">,</span>vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
      <span class="token function">checkComponents</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> child <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      child <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// props,inject,directives的校验和规范化</span>
    <span class="token function">normalizeProps</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">normalizeInject</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">normalizeDirectives</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 针对extends扩展的子类构造器</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>child<span class="token punctuation">.</span><span class="token property-access">_base</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// extends</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">extends</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span><span class="token property-access">extends</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// mixins</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">mixins</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token property-access">mixins</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span><span class="token property-access">mixins</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> key<span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">mergeField</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 拿到各个选择指定的选项配置，如果没有则用默认的配置</span>
      <span class="token keyword">var</span> strat <span class="token operator">=</span> strats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> defaultStrat<span class="token punctuation">;</span>
      <span class="token comment">// 执行各自的合并策略</span>
      options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strat</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// console.log(options)</span>
    <span class="token keyword control-flow">return</span> options
  <span class="token punctuation">}</span>
</code></pre>
<p>**选项合并过程中更多的不可控在于不知道用户传递了哪些配置选项，这些配置是否符合规范，是否达到合并配置的要求。因此每个选项的书写规则需要严格限定，原则上不允许用户脱离规则外来传递选项。**因此在合并选项之前，很大的一部分工作是对选项的校验。其中<code>components,prop,inject,directive</code>等都是检验的重点。</p>
<h3 id="131-components%E8%A7%84%E8%8C%83%E6%A3%80%E9%AA%8C">1.3.1 components规范检验<a class="anchor" href="#131-components%E8%A7%84%E8%8C%83%E6%A3%80%E9%AA%8C">§</a></h3>
<p>如果项目中需要使用到组件，我们会在<code>vue</code>实例化时传入组件选项以此来注册组件。因此，组件命名需要遵守很多规范，比如组件名不能用<code>html</code>保留的标签(如：<code>img,p</code>),也不能包含非法的字符等。这些都会在<code>validateComponentName</code>函数做校验。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// components规范检查函数</span>
<span class="token keyword">function</span> <span class="token function">checkComponents</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历components对象，对每个属性值校验。</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> options<span class="token punctuation">.</span><span class="token property-access">components</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">validateComponentName</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">validateComponentName</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"^[a-zA-Z][\\-\\.0-9_"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>unicodeRegExp<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"]*$"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 正则判断检测是否为非法的标签，例如数字开头</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Invalid component name: "'</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'". Component names '</span> <span class="token operator">+</span>
      <span class="token string">'should conform to valid custom element name in html5 specification.'</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 不能使用Vue自身自定义的组件名，如slot, component,不能使用html的保留标签，如 h1, svg等</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isBuiltInTag</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token method function property-access">isReservedTag</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Do not use built-in or reserved HTML elements as component '</span> <span class="token operator">+</span>
      <span class="token string">'id: '</span> <span class="token operator">+</span> name
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="132-props%E8%A7%84%E8%8C%83%E6%A3%80%E9%AA%8C">1.3.2 props规范检验<a class="anchor" href="#132-props%E8%A7%84%E8%8C%83%E6%A3%80%E9%AA%8C">§</a></h3>
<p><code>Vue</code>的官方文档规定了<code>props</code>选项的书写形式有两种，分别是</p>
<ol>
<li>数组形式 <code>{ props: ['a', 'b', 'c'] }</code>,</li>
<li>带校验规则的对象形式 <code>{ props: { a: { type: 'String', default: 'prop校验' } }}</code>
从源码上看，<strong>两种形式最终都会转换成对象的形式。</strong></li>
</ol>
<pre class="language-js"><code class="language-js"><span class="token comment">// props规范校验</span>
  <span class="token keyword">function</span> <span class="token function">normalizeProps</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token punctuation">}</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> i<span class="token punctuation">,</span> val<span class="token punctuation">,</span> name<span class="token punctuation">;</span>
    <span class="token comment">// props选项数据有两种形式，一种是['a', 'b', 'c'],一种是{ a: { type: 'String', default: 'hahah' }}</span>
    <span class="token comment">// 数组</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      i <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        val <span class="token operator">=</span> props<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          name <span class="token operator">=</span> <span class="token function">camelize</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 默认将数组形式的props转换为对象形式。</span>
          res<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token keyword null nil">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 规则：保证是字符串</span>
          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'props must be strings when using array syntax.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        val <span class="token operator">=</span> props<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        name <span class="token operator">=</span> <span class="token function">camelize</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
          <span class="token operator">?</span> val
          <span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> val <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 非数组，非对象则判定props选项传递非法</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token string">"Invalid value for option \"props\": expected an Array or an Object, "</span> <span class="token operator">+</span>
        <span class="token string">"but got "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">toRawType</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    options<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<h3 id="133-inject%E7%9A%84%E8%A7%84%E8%8C%83%E6%A0%A1%E9%AA%8C">1.3.3 inject的规范校验<a class="anchor" href="#133-inject%E7%9A%84%E8%A7%84%E8%8C%83%E6%A0%A1%E9%AA%8C">§</a></h3>
<p><code>provide/inject</code>这对组合在我们日常开发中可能使用得比较少，当我们需要在父组件中提供数据或者方法给后代组件使用时可以用到<code>provide/inject</code>,注意关键是后代，而不单纯指子代，这是有别于<code>props</code>的使用场景。官方把它被称为依赖注入，依赖注入使得组件后代都能访问到父代注入的数据/方法，且后代不需要知道数据的来源。重要的一点，依赖提供的数据是非响应式的。</p>
<p>基本的使用如下：</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 父组件</span>
<span class="token keyword">var</span> <span class="token maybe-class-name">Provider</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token string">'bar'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 后代组件</span>
<span class="token keyword">var</span> <span class="token maybe-class-name">Child</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 数组写法</span>
  inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">// 对象写法</span>
  inject<span class="token operator">:</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword module">from</span><span class="token operator">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span>
      <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token string">'bardefault'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>inject</code>选项有两种写法，数组的方式以及对象的方式，和<code>props</code>的校验规则一致，最终<code>inject</code>都会转换为对象的形式存在。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// inject的规范化</span>
<span class="token keyword">function</span> <span class="token function">normalizeInject</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> inject <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">inject</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inject<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token punctuation">}</span>
    <span class="token keyword">var</span> normalized <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">inject</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//数组的形式</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>inject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inject<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// from: 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)</span>
        normalized<span class="token punctuation">[</span>inject<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword module">from</span><span class="token operator">:</span> inject<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>inject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对象的处理</span>
      <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> inject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> val <span class="token operator">=</span> inject<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        normalized<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
          <span class="token operator">?</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token keyword module">from</span><span class="token operator">:</span> key <span class="token punctuation">}</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
          <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword module">from</span><span class="token operator">:</span> val <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 非法规则</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token string">"Invalid value for option \"inject\": expected an Array or an Object, "</span> <span class="token operator">+</span>
        <span class="token string">"but got "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">toRawType</span><span class="token punctuation">(</span>inject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<h3 id="134-directive%E7%9A%84%E8%A7%84%E8%8C%83%E6%A0%A1%E9%AA%8C">1.3.4 directive的规范校验<a class="anchor" href="#134-directive%E7%9A%84%E8%A7%84%E8%8C%83%E6%A0%A1%E9%AA%8C">§</a></h3>
<p>我们先看看指令选项的用法，<code>Vue</code>允许我们自定义指令，并且它提供了五个钩子函数<code>bind, inserted, update, componentUpdated, unbind</code>,具体的用法可以参考<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">官方-自定义指令</a>文档,而除了可以以对象的形式去定义钩子函数外，官方还提供了一种函数的简写，例如：</p>
<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>
  directives<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'color-swatch'</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el<span class="token punctuation">.</span><span class="token property-access">style</span><span class="token punctuation">.</span><span class="token property-access">backgroundColor</span> <span class="token operator">=</span> binding<span class="token punctuation">.</span><span class="token property-access">value</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<p>函数的写法会在<code>bind,update</code>钩子中触发相同的行为，并且不关心其他钩子。这个行为就是定义的函数。因此在对<code>directives</code>进行规范化时，针对函数的写法会将行为赋予<code>bind,update</code>钩子。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">normalizeDirectives</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> dirs <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">directives</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> def###<span class="token number">1</span> <span class="token operator">=</span> dirs<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 函数简写同样会转换成对象的形式</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> def###<span class="token number">1</span> <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          dirs<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> bind<span class="token operator">:</span> def###<span class="token number">1</span><span class="token punctuation">,</span> update<span class="token operator">:</span> def###<span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<h3 id="135-%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98">1.3.5 函数缓存<a class="anchor" href="#135-%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98">§</a></h3>
<p>这个内容跟选项的规范化无关，当读到上面规范检测的代码时，笔者发现有一段函数优化的代码值得我们学习。它将每次执行函数后的值进行缓存，当再次执行的时候直接调用缓存的数据而不是重复执行函数，以此提高前端性能，这是典型的用空间换时间的优化，也是经典的偏函数应用。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cached</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> cache <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建空对象作为缓存对象</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">cachedFn</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> hit <span class="token operator">=</span> cache<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> hit <span class="token operator">||</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 每次执行时缓存对象有值则不需要执行函数方法，没有则执行并缓存起来</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> camelizeRE <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">-(\w)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>

<span class="token comment">// 缓存会保存每次进行驼峰转换的结果</span>
<span class="token keyword">var</span> camelize <span class="token operator">=</span> <span class="token function">cached</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将诸如 'a-b'的写法统一处理成驼峰写法'aB'</span>
  <span class="token keyword control-flow">return</span> str<span class="token punctuation">.</span><span class="token method function property-access">replace</span><span class="token punctuation">(</span>camelizeRE<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> c <span class="token operator">?</span> c<span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
<h2 id="14-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8">1.4 子类构造器<a class="anchor" href="#14-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8">§</a></h2>
<p>选项校验介绍完后，在正式进入合并策略之前，还需要先了解一个东西：子类构造器。为什么需要先提到子类构造器呢？</p>
<p>按照前面的知识，<code>Vue</code>内部提供了四个默认选项，关键的三个是<code>components,directives,filter</code>。那么当我们传递一个选项配置到<code>Vue</code>进行初始化，所需要合并的选项好像也仅仅是那关键的三个默认选项而已，那么源码中大篇幅做的选项合并策略又是针对什么场景呢？答案就是这个子类构造器。</p>
<p><strong><code>Vue</code>提供了一个<code>Vue.extend</code>的静态方法，它是基于基础的<code>Vue</code>构造器创建一个“子类”，而这个子类所传递的选项配置会和父类的选项配置进行合并。这是选项合并场景的由来。</strong></p>
<p>因此有不要先了解子类构造器的实现。下面例子中，我们创建了一个<code>Child</code>的子类，它继承于父类<code>Parent</code>,最终将子类挂载到<code>#app</code>元素上。最终获取的<code>data</code>便是选项合并后的结果。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token maybe-class-name">Parent</span> <span class="token operator">=</span> <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    test<span class="token operator">:</span> <span class="token string">'父类'</span>，
    test1<span class="token operator">:</span> <span class="token string">'父类1'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token maybe-class-name">Child</span> <span class="token operator">=</span> <span class="token maybe-class-name">Parent</span><span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    test<span class="token operator">:</span> <span class="token string">'子类'</span><span class="token punctuation">,</span>
    test2<span class="token operator">:</span> <span class="token string">'子类1'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 结果 </span>
<span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token string">'子类'</span><span class="token punctuation">,</span>
  test1<span class="token operator">:</span> <span class="token string">'父类1'</span><span class="token punctuation">,</span>
  test2<span class="token operator">:</span> <span class="token string">'子类1'</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>Vue.extend</code>的实现思路很清晰，创建了一个<code>Sub</code>的类，这个类的原型指向了父类，并且子类的<code>options</code>会和父类的<code>options</code>进行合并，<code>mergeOptions</code>的其他细节接下来会重点分析。</p>
<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">extend</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">extendOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  extendOptions <span class="token operator">=</span> extendOptions <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token maybe-class-name">Super</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> name <span class="token operator">=</span> extendOptions<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">||</span> <span class="token maybe-class-name">Super</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">validateComponentName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 校验子类的名称是否符合规范</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建子类构造器</span>
  <span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">Sub</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">VueComponent</span></span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">Sub</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token class-name">Super</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子类继承于父类</span>
  <span class="token class-name">Sub</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">Sub</span><span class="token punctuation">;</span>
  <span class="token maybe-class-name">Sub</span><span class="token punctuation">.</span><span class="token property-access">cid</span> <span class="token operator">=</span> cid<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token comment">// 子类和父类构造器的配置选项进行合并</span>
  <span class="token maybe-class-name">Sub</span><span class="token punctuation">.</span><span class="token property-access">options</span> <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
    <span class="token maybe-class-name">Super</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">,</span>
    extendOptions
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Sub</span> <span class="token comment">// 返回子类构造函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="15-%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5">1.5 合并策略<a class="anchor" href="#15-%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5">§</a></h2>
<p>合并策略之所以是难点，其中一个是合并选项类型繁多，合并规则随着选项的不同也呈现差异。概括起来思路主要是以下两点：</p>
<ol>
<li><code>Vue</code>针对每个规定的选项都有定义好的合并策略，例如<code>data,component,mounted</code>等。如果合并的子父配置都具有相同的选项，则只需要按照规定好的策略进行选项合并即可。</li>
<li>由于<code>Vue</code>传递的选项是开放式的，所有也存在传递的选项没有自定义选项的情况，这时候由于选项不存在默认的合并策略，所以处理的原则是有子类配置选项则默认使用子类配置选项，没有则选择父类配置选项。</li>
</ol>
<p>我们通过这两个思想去分析源码的实现，先看看<code>mergeOptions</code>除了规范检测后的逻辑。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mergeOptions</span> <span class="token punctuation">(</span> <span class="token parameter">parent<span class="token punctuation">,</span> child<span class="token punctuation">,</span> vm</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
  <span class="token keyword">var</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> key<span class="token punctuation">;</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">mergeField</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果有自定义选项策略，则使用自定义选项策略，否则选择使用默认策略。</span>
    <span class="token keyword">var</span> strat <span class="token operator">=</span> strats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> defaultStrat<span class="token punctuation">;</span> 
    options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strat</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> options
<span class="token punctuation">}</span>
</code></pre>
<p><strong>两个<code>for</code>循环规定了合并的顺序，以自定义选项策略优先，如果没有才会使用默认策略。而<code>strats</code>下每个<code>key</code>对应的便是每个特殊选项的合并策略</strong></p>
<h3 id="151-%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5">1.5.1 默认策略<a class="anchor" href="#151-%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5">§</a></h3>
<p>我们可以用丰富的选项去定义实例的行为，大致可以分为以下几类：</p>
<ol>
<li>用<code>data,props,computed</code>等选项定义实例数据</li>
<li>用<code>mounted, created, destoryed</code>等定义生命周期函数</li>
<li>用<code>components</code>注册组件</li>
<li>用<code>methods</code>选项定义实例方法</li>
</ol>
<p>当然还有诸如<code>watch,inject,directives,filter</code>等选项，总而言之，<code>Vue</code>提供的配置项是丰富的。除此之外，我们也可以使用没有默认配置策略的选项，典型的例子是状态管理<code>Vuex</code>和配套路由<code>vue-router</code>的引入：</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  store<span class="token punctuation">,</span> <span class="token comment">// vuex</span>
  router<span class="token comment">// vue-router</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>不管是插件也好，还是用户自定义的选项，他们的合并策略会遵循思路的第二点：**子配置存在则取子配置，不存在则取父配置，即用子去覆盖父。。**它的描述在<code>defaultStrat</code>中。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 用户自定义选项策略</span>
<span class="token keyword">var</span> <span class="token function-variable function">defaultStrat</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">parentVal<span class="token punctuation">,</span> childVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 子不存在则用父，子存在则用子配置</span>
  <span class="token keyword control-flow">return</span> childVal <span class="token operator">===</span> <span class="token keyword nil">undefined</span>
    <span class="token operator">?</span> parentVal
    <span class="token operator">:</span> childVal
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>接下来会进入某些具体的合并策略的分析，大致分为五类：</p>
<p><strong>1. 常规选项合并</strong></p>
<p><strong>2. 自带资源选项合并</strong></p>
<p><strong>3. 生命周期钩子合并</strong></p>
<p><strong>4. <code>watch</code>选项合并</strong></p>
<p><strong>5. <code>props,methods, inject, computed</code>类似选项合并</strong></p>
<h2 id="16-%E5%B8%B8%E8%A7%84%E9%80%89%E9%A1%B9%E7%9A%84%E5%90%88%E5%B9%B6">1.6 常规选项的合并<a class="anchor" href="#16-%E5%B8%B8%E8%A7%84%E9%80%89%E9%A1%B9%E7%9A%84%E5%90%88%E5%B9%B6">§</a></h2>
<h3 id="161-el%E7%9A%84%E5%90%88%E5%B9%B6">1.6.1 el的合并<a class="anchor" href="#161-el%E7%9A%84%E5%90%88%E5%B9%B6">§</a></h3>
<p><code>el</code>提供一个在页面上已存在的 <code>DOM</code> 元素作为 <code>Vue</code> 实例的挂载目标,因此它只在创建<code>Vue</code>实例才存在，在子类或者子组件中无法定义<code>el</code>选项，因此<code>el</code>的合并策略是在保证选项只存在于根的<code>Vue</code>实例的情形下使用默认策略进行合并。</p>
<pre class="language-js"><code class="language-js">strats<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">el</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 只允许vue实例才拥有el属性，其他子类构造器不允许有el属性</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">"option \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" can only be used during instance "</span> <span class="token operator">+</span>
      <span class="token string">'creation with the `new` keyword.'</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 默认策略</span>
  <span class="token keyword control-flow">return</span> <span class="token function">defaultStrat</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
<h3 id="162-data%E5%90%88%E5%B9%B6">1.6.2 data合并<a class="anchor" href="#162-data%E5%90%88%E5%B9%B6">§</a></h3>
<p>常规选项的重点部分是在于<code>data</code>的合并，读完这部分源码，可能可以解开你心中的一个疑惑，为什么<code>data</code>在<code>vue</code>创建实例时传递的是一个对象，而在组件内部定义时只能传递一个函数。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// data的合并</span>
strats<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">data</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// vm代表是否为Vue创建的实例，否则是子父类的关系</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> childVal <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 必须保证子类的data类型是一个函数而不是一个对象</span>
      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'The "data" option should be a function '</span> <span class="token operator">+</span> <span class="token string">'that returns a per-instance value in component '</span> <span class="token operator">+</span> <span class="token string">'definitions.'</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span> parentVal
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// vue实例时需要传递vm作为函数的第三个参数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>data</code>策略最终调用的<code>mergeDataOrFn</code>方法，区别在于当前<code>vm</code>是否是实例，或者是单纯的子父类的关系。如果是子父类的关系，需要对<code>data</code>选项进行规范校验，保证它的类型是一个函数而不是对象。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mergeDataOrFn</span> <span class="token punctuation">(</span> <span class="token parameter">parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 子父类</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 子类不存在data选项，则合并结果为父类data选项</span>
      <span class="token keyword control-flow">return</span> parentVal
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 父类不存在data选项，则合并结果为子类data选项</span>
      <span class="token keyword control-flow">return</span> childVal
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">function</span> <span class="token function">mergedDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// data选项在父类和子类同时存在的情况下返回的是一个函数</span>
      <span class="token comment">// 子类实例和父类实例，分别将子类和父类实例中data函数执行后返回的对象传递给mergeData函数做数据合并</span>
      <span class="token keyword control-flow">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>
        <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">:</span> childVal<span class="token punctuation">,</span>
        <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">:</span> parentVal
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// Vue实例</span>
    <span class="token comment">// vue构造函数实例对象</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">function</span> <span class="token function">mergedInstanceDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> instanceData <span class="token operator">=</span> <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span>
        <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
        <span class="token operator">:</span> childVal<span class="token punctuation">;</span>
      <span class="token keyword">var</span> defaultData <span class="token operator">=</span> <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span>
        <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
        <span class="token operator">:</span> parentVal<span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>instanceData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当实例中传递data选项时，将实例的data对象和Vm构造函数上的data属性选项合并</span>
        <span class="token keyword control-flow">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>instanceData<span class="token punctuation">,</span> defaultData<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当实例中不传递data时，默认返回Vm构造函数上的data属性选项</span>
        <span class="token keyword control-flow">return</span> defaultData
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>从源码的实现看，<code>data</code>的合并不是简单的将两个数据对象进行合并，而是直接返回一个<code>mergedDataFn</code>或者<code>mergedInstanceDataFn</code>函数，而真正合并的时机是在后续初始化数据响应式系统的环节进行的，初始化数据响应式系统的第一步就是拿到合并后的数据，也就是执行<code>mergeData</code>逻辑。
(关于响应式系统的构建请移步后面的章节)</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mergeData</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword module">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> to <span class="token punctuation">}</span>
  <span class="token keyword">var</span> key<span class="token punctuation">,</span> toVal<span class="token punctuation">,</span> fromVal<span class="token punctuation">;</span>
  <span class="token comment">// Reflect.ownKeys可以拿到Symbol属性</span>
  <span class="token keyword">var</span> keys <span class="token operator">=</span> hasSymbol
    <span class="token operator">?</span> <span class="token known-class-name class-name">Reflect</span><span class="token punctuation">.</span><span class="token method function property-access">ownKeys</span><span class="token punctuation">(</span><span class="token keyword module">from</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span><span class="token keyword module">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    toVal <span class="token operator">=</span> to<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    fromVal <span class="token operator">=</span> <span class="token keyword module">from</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 子的数据父没有，则将新增的数据加入响应式系统中。</span>
      <span class="token function">set</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> key<span class="token punctuation">,</span> fromVal<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>
      toVal <span class="token operator">!==</span> fromVal <span class="token operator">&amp;&amp;</span>
      <span class="token function">isPlainObject</span><span class="token punctuation">(</span>toVal<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      <span class="token function">isPlainObject</span><span class="token punctuation">(</span>fromVal<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 处理深层对象，当合并的数据为多层嵌套对象时，需要递归调用mergeData进行比较合并</span>
      <span class="token function">mergeData</span><span class="token punctuation">(</span>toVal<span class="token punctuation">,</span> fromVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> to
<span class="token punctuation">}</span>
</code></pre>
<p><code>mergeData</code>方法的两个参数是父<code>data</code>选项和子<code>data</code>选项的结果，也就是两个<code>data</code>对象，从源码上看数据合并的原则是，将父类的数据整合到子类的数据选项中， 如若父类数据和子类数据冲突时，保留子类数据。如果对象有深层嵌套，则需要递归调用<code>mergeData</code>进行数据合并。</p>
<p>最后回过头来思考一个问题，为什么<code>Vue</code>组件的<code>data</code>是一个函数，而不是一个对象呢？
我觉得可以这样解释：<strong>组件设计的目的是为了复用，每次通过函数创建相当于在一个独立的内存空间中生成一个<code>data</code>的副本，这样每个组件之间的数据不会互相影响。</strong></p>
<h2 id="17-%E8%87%AA%E5%B8%A6%E8%B5%84%E6%BA%90%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6">1.7 自带资源选项合并<a class="anchor" href="#17-%E8%87%AA%E5%B8%A6%E8%B5%84%E6%BA%90%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6">§</a></h2>
<p>在1.2中我们看到了<code>Vue</code>默认会带几个选项，分别是<code>components</code>组件, <code>directive</code>指令, <code>filter</code>过滤器,所有无论是根实例，还是父子实例，都需要和系统自带的资源选项进行合并。它的定义如下：</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 资源选项</span>
<span class="token keyword">var</span> <span class="token constant">ASSET_TYPES</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'component'</span><span class="token punctuation">,</span>
  <span class="token string">'directive'</span><span class="token punctuation">,</span>
  <span class="token string">'filter'</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 定义资源合并的策略</span>
<span class="token constant">ASSET_TYPES</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strats<span class="token punctuation">[</span>type <span class="token operator">+</span> <span class="token string">'s'</span><span class="token punctuation">]</span> <span class="token operator">=</span> mergeAssets<span class="token punctuation">;</span> <span class="token comment">// 定义默认策略</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
<p>这些资源选项的合并逻辑很简单，首先会创建一个原型指向父类资源选项的空对象，再将子类选项赋值给空对象。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 资源选项自定义合并策略</span>
<span class="token keyword">function</span> <span class="token function">mergeAssets</span> <span class="token punctuation">(</span><span class="token parameter">parentVal<span class="token punctuation">,</span>childVal<span class="token punctuation">,</span>vm<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>parentVal <span class="token operator">||</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个空对象，其原型指向父类的资源选项。</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// components,filters,directives选项必须为对象</span>
    <span class="token keyword control-flow">return</span> <span class="token function">extend</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span> <span class="token comment">// 子类选项赋值给空对象</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>结合下面的例子，我们看具体合并后的结果：</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span>
    componentA<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  directives<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'v-boom'</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">components</span><span class="token punctuation">)</span>
<span class="token comment">// 根实例的选项和资源默认选项合并后的结果</span>
<span class="token punctuation">{</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span>
    componentA<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    __proto__<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">KeepAlive</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token maybe-class-name">Transition</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token maybe-class-name">TransitionGroup</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  directives<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'v-boom'</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    __proto__<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'v-show'</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token string">'v-model'</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<p>简单总结一下，对于 <code>directives、filters</code> 以及 <code>components</code> 等资源选项，父类选项将以原型链的形式被处理。子类必须通过原型链才能查找并使用内置组件和内置指令。</p>
<h2 id="18-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%88%E5%B9%B6">1.8 生命周期钩子函数的合并<a class="anchor" href="#18-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%88%E5%B9%B6">§</a></h2>
<p>在学习<code>Vue</code>时，有一个重要的思想，生命周期。它是我们使用<code>Vue</code>高效开发组件的基础，我们可以在组件实例的不同阶段去定义需要执行的函数，让组件的功能更加丰富。在介绍生命周期钩子函数的选项合并前，我们有必要复习以下官方的生命周期图。</p>
<p><img src="./img/1.1.png" alt=""></p>
<p>然而从源码中我们可以看到<code>Vue</code>的生命周期钩子不止这些，它有多达12个之多，每个钩子的执行时机我们暂且不深究，它们会在以后的章节中逐一出现。我们关心的是：子父组件的生命周期钩子函数是遵循什么样的规则合并。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token constant">LIFECYCLE_HOOKS</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'beforeCreate'</span><span class="token punctuation">,</span>
  <span class="token string">'created'</span><span class="token punctuation">,</span>
  <span class="token string">'beforeMount'</span><span class="token punctuation">,</span>
  <span class="token string">'mounted'</span><span class="token punctuation">,</span>
  <span class="token string">'beforeUpdate'</span><span class="token punctuation">,</span>
  <span class="token string">'updated'</span><span class="token punctuation">,</span>
  <span class="token string">'beforeDestroy'</span><span class="token punctuation">,</span>
  <span class="token string">'destroyed'</span><span class="token punctuation">,</span>
  <span class="token string">'activated'</span><span class="token punctuation">,</span>
  <span class="token string">'deactivated'</span><span class="token punctuation">,</span>
  <span class="token string">'errorCaptured'</span><span class="token punctuation">,</span>
  <span class="token string">'serverPrefetch'</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token constant">LIFECYCLE_HOOKS</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">hook</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strats<span class="token punctuation">[</span>hook<span class="token punctuation">]</span> <span class="token operator">=</span> mergeHook<span class="token punctuation">;</span> <span class="token comment">// 对生命周期钩子选项的合并都执行mergeHook策略</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><code>mergeHook</code>是生命周期钩子合并的策略，简单的对代码进行总结，钩子函数的合并原则是：</p>
<ol>
<li>如果子类和父类都拥有相同钩子选项，则将子类选项和父类选项合并。</li>
<li>如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项。</li>
<li>当子类不存在钩子选项时，则以父类选项返回。</li>
<li>子父合并时，是将子类选项放在数组的末尾，这样在执行钩子时，永远是父类选项优先于子类选项执行。</li>
</ol>
<pre class="language-js"><code class="language-js"><span class="token comment">// 生命周期钩子选项合并策略</span>
<span class="token keyword">function</span> <span class="token function">mergeHook</span> <span class="token punctuation">(</span>
    <span class="token parameter">parentVal<span class="token punctuation">,</span>
    childVal</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.如果子类和父类都拥有钩子选项，则将子类选项和父类选项合并, </span>
    <span class="token comment">// 2.如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项，</span>
    <span class="token comment">// 3.当子类不存在钩子选项时，则以父类选项返回。</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> childVal <span class="token operator">?</span> parentVal <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token method function property-access">concat</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token operator">?</span> childVal <span class="token operator">:</span> <span class="token punctuation">[</span>childVal<span class="token punctuation">]</span> <span class="token operator">:</span> parentVal<span class="token punctuation">;</span> 
    <span class="token keyword control-flow">return</span> res
      <span class="token operator">?</span> <span class="token function">dedupeHooks</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
      <span class="token operator">:</span> res
  <span class="token punctuation">}</span>
<span class="token comment">// 防止多个组件实例钩子选项相互影响</span>
  <span class="token keyword">function</span> <span class="token function">dedupeHooks</span> <span class="token punctuation">(</span><span class="token parameter">hooks</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hooks<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token method function property-access">indexOf</span><span class="token punctuation">(</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> res
  <span class="token punctuation">}</span>
</code></pre>
<p>下面结合具体的例子看合并结果。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token maybe-class-name">Parent</span> <span class="token operator">=</span> <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'parent'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token maybe-class-name">Child</span> <span class="token operator">=</span> <span class="token maybe-class-name">Parent</span><span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 输出结果：</span>
parent
child
</code></pre>
<p>简单总结一下：<strong>对于生命周期钩子选项，子类和父类相同的选项将合并成数组，这样在执行子类钩子函数时，父类钩子选项也会执行，并且父会优先于子执行。</strong></p>
<h2 id="19-watch%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6">1.9 watch选项合并<a class="anchor" href="#19-watch%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6">§</a></h2>
<p>在使用<code>Vue</code>进行开发时，我们有时需要自定义侦听器来响应数据的变化，当需要在数据变化时执行异步或者开销较大的操作时，<code>watch</code>往往是高效的。对于 <code>watch</code> 选项的合并处理，它类似于生命周期钩子，只要父选项有相同的观测字段，则和子的选项合并为数组，在监测字段改变时同时执行父类选项的监听代码。处理方式和生命钩子选项的区别在于，生命周期钩子选项必须是函数，而<code>watch</code>选项最终在合并的数组中可以是包含选项的对象，也可以是对应的回调函数，或者方法名。</p>
<pre class="language-js"><code class="language-js">strats<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">parentVal<span class="token punctuation">,</span>childVal<span class="token punctuation">,</span>vm<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//火狐浏览器在Object的原型上拥有watch方法，这里对这一现象做了兼容</span>
    <span class="token comment">// var nativeWatch = ({}).watch;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>parentVal <span class="token operator">===</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span> parentVal <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">===</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span> childVal <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// 没有子，则默认用父选项</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>parentVal <span class="token operator">||</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>
      <span class="token comment">// 保证watch选项是一个对象</span>
      <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 没有父则直接用子选项</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> childVal <span class="token punctuation">}</span>
    <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> parentVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key$<span class="token number">1</span> <span class="token keyword">in</span> childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> parent <span class="token operator">=</span> ret<span class="token punctuation">[</span>key$<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> child <span class="token operator">=</span> childVal<span class="token punctuation">[</span>key$<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 父的选项先转换成数组</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent <span class="token operator">=</span> <span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      ret<span class="token punctuation">[</span>key$<span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> parent
        <span class="token operator">?</span> parent<span class="token punctuation">.</span><span class="token method function property-access">concat</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token operator">?</span> child <span class="token operator">:</span> <span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ret
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>下面结合具体的例子看合并结果：</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token maybe-class-name">Parent</span> <span class="token operator">=</span> <span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  watch<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'test'</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'parent change'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token maybe-class-name">Child</span> <span class="token operator">=</span> <span class="token maybe-class-name">Parent</span><span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  watch<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'test'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'child change'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
      test<span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vm<span class="token punctuation">.</span><span class="token property-access">test</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果</span>
parent change
child change
</code></pre>
<p>简单总结一下：<strong>对于watch选项的合并，最终和父类选项合并成数组，并且数组的选项成员，可以是回调函数，选项对象，或者函数名。</strong></p>
<h2 id="110-props-methods-inject-computed%E5%90%88%E5%B9%B6">1.10 props methods inject computed合并<a class="anchor" href="#110-props-methods-inject-computed%E5%90%88%E5%B9%B6">§</a></h2>
<p>源码的设计将<code>props.methods,inject,computed</code>归结为一类，他们的配置策略一致，简单概括就是，如果父类不存在选项，则返回子类选项，子类父类都存在时，用子类选项去覆盖父类选项。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 其他选项合并策略</span>
strats<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span>
strats<span class="token punctuation">.</span><span class="token property-access">methods</span> <span class="token operator">=</span>
strats<span class="token punctuation">.</span><span class="token property-access">inject</span> <span class="token operator">=</span>
strats<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">computed</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">parentVal<span class="token punctuation">,</span>childVal<span class="token punctuation">,</span>vm<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">&amp;&amp;</span> <span class="token string">"development"</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> childVal <span class="token punctuation">}</span> <span class="token comment">// 父类不存在该选项，则返回子类的选项</span>
  <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> parentVal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// </span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 子类选项会覆盖父类选项的值</span>
    <span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
  <span class="token keyword control-flow">return</span> ret
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
<h2 id="111-%E5%B0%8F%E7%BB%93">1.11 小结<a class="anchor" href="#111-%E5%B0%8F%E7%BB%93">§</a></h2>
<p>至此，五类选项合并的策略分析到此结束，回顾一下这一章节的内容，这一节是<code>Vue</code>源码分析的起手式，所以我们从<code>Vue</code>的引入出发，先大致了解了<code>Vue</code>在代码引入阶段做的操作，主要是对静态属性方法和原型上属性方法的定义和声明，这里并不需要精确了解到每个方法的功能和实现细节，当然我也相信你已经在实战中或多或少接触过这些方法的使用。接下来到文章的重点，<code>new Vue</code>是我们正确使用<code>Vue</code>进行开发的关键，而实例化阶段会对调用<code>_init</code>方法进行初始化，选项合并是初始化的第一步。选项合并会对系统内部定义的选项和子父类的选项进行合并。而<code>Vue</code>有相当丰富的选项合并策略，不管是内部的选项还是用户自定义的选项，他们都遵循内部约定好的合并策略。有了丰富的选项和严格的合并策略，<code>Vue</code>在指导开发上才显得更加完备。下一节会分析一个重要的概念，数据代理，它也是响应式系统的基础。</p></article><div class="prev_next"><a class="prev button" href="/In-depth-analysis-of-Vue/introduction/index.html">«  <!-- -->Introduction</a><a class="next button" href="/In-depth-analysis-of-Vue/src/2.基础的数据代理检测.html">2.基础的数据代理检测<!-- -->  »</a></div></div><aside class="main_toc_container nav_link_container"><div class="main_toc"><nav class="toc"><ol><li><a href="#11-vue%E7%9A%84%E5%BC%95%E5%85%A5">1.1 Vue的引入</a><ol><li><a href="#111-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">1.1.1 基础使用</a></li><li><a href="#112-vue%E6%9E%84%E9%80%A0%E5%99%A8">1.1.2 Vue构造器</a></li><li><a href="#113-%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">1.1.3 定义原型属性方法</a></li><li><a href="#114-%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">1.1.4 定义静态属性方法</a></li></ol></li><li><a href="#12-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9">1.2 构造器的默认选项</a></li><li><a href="#13-%E9%80%89%E9%A1%B9%E6%A3%80%E9%AA%8C">1.3 选项检验</a><ol><li><a href="#131-components%E8%A7%84%E8%8C%83%E6%A3%80%E9%AA%8C">1.3.1 components规范检验</a></li><li><a href="#132-props%E8%A7%84%E8%8C%83%E6%A3%80%E9%AA%8C">1.3.2 props规范检验</a></li><li><a href="#133-inject%E7%9A%84%E8%A7%84%E8%8C%83%E6%A0%A1%E9%AA%8C">1.3.3 inject的规范校验</a></li><li><a href="#134-directive%E7%9A%84%E8%A7%84%E8%8C%83%E6%A0%A1%E9%AA%8C">1.3.4 directive的规范校验</a></li><li><a href="#135-%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98">1.3.5 函数缓存</a></li></ol></li><li><a href="#14-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8">1.4 子类构造器</a></li><li><a href="#15-%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5">1.5 合并策略</a><ol><li><a href="#151-%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5">1.5.1 默认策略</a></li></ol></li><li><a href="#16-%E5%B8%B8%E8%A7%84%E9%80%89%E9%A1%B9%E7%9A%84%E5%90%88%E5%B9%B6">1.6 常规选项的合并</a><ol><li><a href="#161-el%E7%9A%84%E5%90%88%E5%B9%B6">1.6.1 el的合并</a></li><li><a href="#162-data%E5%90%88%E5%B9%B6">1.6.2 data合并</a></li></ol></li><li><a href="#17-%E8%87%AA%E5%B8%A6%E8%B5%84%E6%BA%90%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6">1.7 自带资源选项合并</a></li><li><a href="#18-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%88%E5%B9%B6">1.8 生命周期钩子函数的合并</a></li><li><a href="#19-watch%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6">1.9 watch选项合并</a></li><li><a href="#110-props-methods-inject-computed%E5%90%88%E5%B9%B6">1.10 props methods inject computed合并</a></li><li><a href="#111-%E5%B0%8F%E7%BB%93">1.11 小结</a></li></ol></nav></div></aside></section><footer>Powered by&amp;nbsp;<a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><div class="tools flex_center hide_on_mobile"><a class="czs-angle-up-l button" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-angle-up-l.svg&quot;)"></a></div><script src="https://unpkg.com/react@16.13.1/umd/react.production.min.js"></script><script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script><script type="module" src="/In-depth-analysis-of-Vue/index.js"></script></body></html>