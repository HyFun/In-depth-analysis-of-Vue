import projectConfig from '/In-depth-analysis-of-Vue/pagic.config.js';
export default {
    'prev': {
        "text": "7.深入响应式系统构建-中",
        "link": "src/7.深入响应式系统构建-中.html"
    },
    'next': {
        "text": "8.来，跟我一起实现diff算法",
        "link": "src/8.来，跟我一起实现diff算法.html"
    },
    config: { "root": "/", ...projectConfig, branch: 'pagic' },
    'pagePath': "src/7.深入响应式系统构建-下.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "src/7.深入响应式系统构建-下.html",
    'title': undefined,
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>上一节，我们深入分析了以<code>data,computed</code>为数据创建响应式系统的过程，并对其中依赖收集和派发更新的过程进行了详细的分析。然而在使用和分析过程中依然存在或多或少的问题，这一节我们将针对这些问题展开分析，最后我们也会分析一下<code>watch</code>的响应式过程。这篇文章将作为响应式系统分析的完结篇。</p>\n</blockquote>\n<h2 id="712-%E6%95%B0%E7%BB%84%E6%A3%80%E6%B5%8B">7.12 数组检测<a class="anchor" href="#712-%E6%95%B0%E7%BB%84%E6%A3%80%E6%B5%8B">§</a></h2>\n<p>在之前介绍数据代理章节，我们已经详细介绍过<code>Vue</code>数据代理的技术是利用了<code>Object.defineProperty</code>,<code>Object.defineProperty</code>让我们可以方便的利用存取描述符中的<code>getter/setter</code>来进行数据的监听,在<code>get,set</code>钩子中分别做不同的操作，达到数据拦截的目的。然而<code>Object.defineProperty</code>的<code>get,set</code>方法只能检测到对象属性的变化，对于数组的变化(例如插入删除数组元素等操作)，<code>Object.defineProperty</code>却无法达到目的,这也是利用<code>Object.defineProperty</code>进行数据监控的缺陷，虽然<code>es6</code>中的<code>proxy</code>可以完美解决这一问题，但毕竟有兼容性问题，所以我们还需要研究<code>Vue</code>在<code>Object.defineProperty</code>的基础上如何对数组进行监听检测。</p>\n<h3 id="7121-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">7.12.1 数组方法的重写<a class="anchor" href="#7121-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">§</a></h3>\n<p>既然数组已经不能再通过数据的<code>getter,setter</code>方法去监听变化了，<code>Vue</code>的做法是对数组方法进行重写，在保留原数组功能的前提下，对数组进行额外的操作处理。也就是重新定义了数组方法。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>\n<span class="token comment">// 新建一个继承于Array的对象</span>\n<span class="token keyword">var</span> arrayMethods <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 数组拥有的方法</span>\n<span class="token keyword">var</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token string">\'push\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'pop\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'shift\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'unshift\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'splice\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'sort\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'reverse\'</span>\n<span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre>\n<p><code>arrayMethods</code>是基于原始<code>Array</code>类为原型继承的一个对象类，由于原型链的继承，<code>arrayMethod</code>拥有数组的所有方法，接下来对这个新的数组类的方法进行改写。</p>\n<pre class="language-js"><code class="language-js">methodsToPatch<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 缓冲原始数组的方法</span>\n  <span class="token keyword">var</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token comment">// 利用Object.defineProperty对方法的执行进行改写</span>\n  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">def</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> enumerable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      value<span class="token operator">:</span> val<span class="token punctuation">,</span>\n      enumerable<span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span>enumerable<span class="token punctuation">,</span>\n      writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      configurable<span class="token operator">:</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n</code></pre>\n<p>这里对数组方法设置了代理，当执行<code>arrayMethods</code>的数组方法时，会代理执行<code>mutator</code>函数，这个函数的具体实现，我们放到数组的派发更新中介绍。</p>\n<p><strong>仅仅创建一个新的数组方法合集是不够的，我们在访问数组时，如何不调用原生的数组方法，而是将过程指向这个新的类，这是下一步的重点。</strong></p>\n<p>回到数据初始化过程，也就是执行<code>initData</code>阶段，上一篇内容花了大篇幅介绍过数据初始化会为<code>data</code>数据创建一个<code>Observer</code>类，当时我们只讲述了<code>Observer</code>类会为每个非数组的属性进行数据拦截，重新定义<code>getter,setter</code>方法,除此之外对于数组类型的数据，我们有意跳过分析了。这里，我们重点看看对于数组拦截的处理。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">Observer</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Observer</span></span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">dep</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">vmCount</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token comment">// 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。</span>\n  <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">\'__ob__\'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 数组处理</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>hasProto<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">protoAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token function">copyAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 对象处理</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>数组处理的分支分为两个，<code>hasProto</code>的判断条件，<code>hasProto</code>用来判断当前环境下是否支持<code>__proto__</code>属性。而数组的处理会根据是否支持这一属性来决定执行<code>protoAugment, copyAugment</code>过程，</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// __proto__属性的判断</span>\n<span class="token keyword">var</span> hasProto <span class="token operator">=</span> <span class="token string">\'__proto__\'</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n<p><strong>当支持<code>__proto__</code>时，执行<code>protoAugment</code>会将当前数组的原型指向新的数组类<code>arrayMethods</code>,如果不支持<code>__proto__</code>，则通过代理设置，在访问数组方法时代理访问新数组类中的数组方法。</strong></p>\n<pre class="language-js"><code class="language-js"><span class="token comment">//直接通过原型指向的方式</span>\n\n<span class="token keyword">function</span> <span class="token function">protoAugment</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  target<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">=</span> src<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 通过数据代理的方式</span>\n<span class="token keyword">function</span> <span class="token function">copyAugment</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> src<span class="token punctuation">,</span> keys</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token function">def</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>有了这两步的处理，接下来我们在实例内部调用<code>push, unshift</code>等数组的方法时，会执行<code>arrayMethods</code>类的方法。这也是数组进行依赖收集和派发更新的前提。</p>\n<h3 id="7122-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.12.2 依赖收集<a class="anchor" href="#7122-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">§</a></h3>\n<p>由于数据初始化阶段会利用<code>Object.definePrototype</code>进行数据访问的改写，数组的访问同样会被<code>getter</code>所拦截。由于是数组，拦截过程会做特殊处理，后面我们再看看<code>dependArray</code>的原理。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> defineReactive###<span class="token number">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword">var</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">var</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> getter<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>\n          <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            dep<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              childOb<span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n              <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">dependArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n              <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n          <span class="token punctuation">}</span>\n          <span class="token keyword control-flow">return</span> value\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n \n</code></pre>\n<p><code>childOb</code>是标志属性值是否为基础类型的标志，<code>observe</code>如果遇到基本类型数据，则直接返回，不做任何处理，如果遇到对象或者数组则会递归实例化<code>Observer</code>，会为每个子属性设置响应式数据，最终返回<code>Observer</code>实例。而实例化<code>Observer</code>又回到之前的老流程：\n<strong>添加<code>__ob__</code>属性，如果遇到数组则进行原型重指向，遇到对象则定义<code>getter,setter</code>，这一过程前面分析过，就不再阐述。</strong></p>\n<p>在访问到数组时，由于<code>childOb</code>的存在，会执行<code>childOb.dep.depend();</code>进行依赖收集，该<code>Observer</code>实例的<code>dep</code>属性会收集当前的<code>watcher</code>作为依赖保存，<code>dependArray</code>保证了如果数组元素是数组或者对象，需要递归去为内部的元素收集相关的依赖。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">dependArray</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      e <span class="token operator">=</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token property-access">__ob__</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token property-access">__ob__</span><span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">dependArray</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n</code></pre>\n<p>我们可以通过截图看最终依赖收集的结果。</p>\n<p>收集前</p>\n<p><img src="./img/7.1.png" alt=""></p>\n<p>收集后</p>\n<p><img src="./img/7.2.png" alt=""></p>\n<h3 id="7123-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.12.3 派发更新<a class="anchor" href="#7123-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">§</a></h3>\n<p>当调用数组的方法去添加或者删除数据时，数据的<code>setter</code>方法是无法拦截的，所以我们唯一可以拦截的过程就是调用数组方法的时候，前面介绍过，数组方法的调用会代理到新类<code>arrayMethods</code>的方法中,而<code>arrayMethods</code>的数组方法是进行重写过的。具体我们看他的定义。</p>\n<pre class="language-js"><code class="language-js"> methodsToPatch<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arguments<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span> len<span class="token operator">--</span> <span class="token punctuation">)</span> args<span class="token punctuation">[</span> len <span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span> len <span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token comment">// 执行原数组方法</span>\n      <span class="token keyword">var</span> result <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">__ob__</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> inserted<span class="token punctuation">;</span>\n      <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">case</span> <span class="token string">\'push\'</span><span class="token operator">:</span>\n        <span class="token keyword">case</span> <span class="token string">\'unshift\'</span><span class="token operator">:</span>\n          inserted <span class="token operator">=</span> args<span class="token punctuation">;</span>\n          <span class="token keyword control-flow">break</span>\n        <span class="token keyword">case</span> <span class="token string">\'splice\'</span><span class="token operator">:</span>\n          inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword control-flow">break</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> <span class="token punctuation">{</span> ob<span class="token punctuation">.</span><span class="token method function property-access">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n      <span class="token comment">// notify change</span>\n      ob<span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> result\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre>\n<p><code>mutator</code>是重写的数组方法，首先会调用原始的数组方法进行运算，这保证了与原始数组类型的方法一致性，<code>args</code>保存了数组方法调用传递的参数。之后取出数组的<code>__ob__</code>也就是之前保存的<code>Observer</code>实例，调用<code>ob.dep.notify();</code>进行依赖的派发更新，前面知道了。<code>Observer</code>实例的<code>dep</code>是<code>Dep</code>的实例，他收集了需要监听的<code>watcher</code>依赖，而<code>notify</code>会对依赖进行重新计算并更新。具体看<code>Dep.prototype.notify = function notify () {}</code>函数的分析，这里也不重复赘述。</p>\n<p>回到代码中，<code>inserted</code>变量用来标志数组是否是增加了元素，如果增加的元素不是原始类型，而是数组对象类型，则需要触发<code>observeArray</code>方法，对每个元素进行依赖收集。</p>\n<pre class="language-js"><code class="language-js"><span class="token class-name">Observer</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">observeArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n<p><strong>总的来说。数组的改变不会触发<code>setter</code>进行依赖更新，所以<code>Vue</code>创建了一个新的数组类，重写了数组的方法，将数组方法指向了新的数组类。同时在访问到数组时依旧触发<code>getter</code>进行依赖收集，在更改数组时，触发数组新方法运算，并进行依赖的派发。</strong></p>\n<p>现在我们回过头看看Vue的官方文档对于数组检测时的注意事项：</p>\n<blockquote>\n<p><code>Vue</code> 不能检测以下数组的变动:</p>\n<ul>\n<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>\n</ul>\n</blockquote>\n<p>显然有了上述的分析我们很容易理解数组检测带来的弊端，即使<code>Vue</code>重写了数组的方法，以便在设置数组时进行拦截处理，但是不管是通过索引还是直接修改长度，都是无法触发依赖更新的。</p>\n<h2 id="713-%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8">7.13 对象检测异常<a class="anchor" href="#713-%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8">§</a></h2>\n<p>我们在实际开发中经常遇到一种场景，对象<code>test: { a: 1 }</code>要添加一个属性<code>b</code>,这时如果我们使用<code>test.b = 2</code>的方式去添加，这个过程<code>Vue</code>是无法检测到的，理由也很简单。我们在对对象进行依赖收集的时候，会为对象的每个属性都进行收集依赖，而直接通过<code>test.b</code>添加的新属性并没有依赖收集的过程，因此当之后数据<code>b</code>发生改变时也不会进行依赖的更新。</p>\n<p>了解决这一问题，<code>Vue</code>提供了<code>Vue.set(object, propertyName, value)</code>的静态方法和<code>vm.$set(object, propertyName, value)</code>的实例方法，我们看具体怎么完成新属性的依赖收集过程。</p>\n<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">set</span> <span class="token operator">=</span> <span class="token keyword">set</span>\n<span class="token keyword">function</span> <span class="token function">set</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//target必须为非空对象</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>\n    <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Cannot set reactive property on undefined, null, or primitive value: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 数组场景，调用重写的splice方法，对新添加属性收集依赖。</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      target<span class="token punctuation">.</span><span class="token method function property-access">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 新增对象的属性存在时，直接返回新属性，触发依赖收集</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 拿到目标源的Observer 实例</span>\n    <span class="token keyword">var</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">__ob__</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token property-access">_isVue</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ob <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">.</span><span class="token property-access">vmCount</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warn</span><span class="token punctuation">(</span>\n        <span class="token string">\'Avoid adding reactive properties to a Vue instance or its root $data \'</span> <span class="token operator">+</span>\n        <span class="token string">\'at runtime - declare it upfront in the data option.\'</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 目标源对象本身不是一个响应式对象，则不需要处理</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 手动调用defineReactive，为新属性设置getter,setter</span>\n    defineReactive###<span class="token number">1</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    ob<span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">return</span> val\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>按照分支分为不同的四个处理逻辑：</p>\n<ol>\n<li>目标对象必须为非空的对象，可以是数组，否则抛出异常。</li>\n<li>如果目标对象是数组时，调用数组的<code>splice</code>方法，而前面分析数组检测时，遇到数组新增元素的场景，会调用<code>ob.observeArray(inserted)</code>对数组新增的元素收集依赖。</li>\n<li>新增的属性值在原对象中已经存在，则手动访问新的属性值，这一过程会触发依赖收集。</li>\n<li>手动定义新属性的<code>getter,setter</code>方法，并通过<code>notify</code>触发依赖更新。</li>\n</ol>\n<h2 id="714-nexttick">7.14 nextTick<a class="anchor" href="#714-nexttick">§</a></h2>\n<p>在上一节的内容中，我们说到数据修改时会触发<code>setter</code>方法进行依赖的派发更新，而更新时会将每个<code>watcher</code>推到队列中，等待下一个<code>tick</code>到来时再执行<code>DOM</code>的渲染更新操作。这个就是异步更新的过程。为了说明异步更新的概念，需要牵扯到浏览器的事件循环机制和最优的渲染时机问题。由于这不是文章的主线，我只用简单的语言概述。</p>\n<h3 id="7141-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6">7.14.1 事件循环机制<a class="anchor" href="#7141-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6">§</a></h3>\n<ol>\n<li>完整的事件循环机制需要了解两种异步队列：<code>macro-task</code>和<code>micro-task</code></li>\n<li><code>macro-task</code>常见的有 <code>setTimeout, setInterval, setImmediate, script脚本, I/O操作，UI渲染</code></li>\n<li><code>micro-task</code>常见的有 <code>promise, process.nextTick, MutationObserver</code>等</li>\n<li>完整事件循环流程为：\n4.1 <code>micro-task</code>空，<code>macro-task</code>队列只有<code>script</code>脚本，推出<code>macro-task</code>的<code>script</code>任务执行，脚本执行期间产生的<code>macro-task，micro-task</code>推到对应的队列中\n4.2 执行全部<code>micro-task</code>里的微任务事件\n4.3 执行<code>DOM</code>操作，渲染更新页面\n4.4 执行<code>web worker</code>等相关任务\n4.5 循环，取出<code>macro-task</code>中一个宏任务事件执行，重复4的操作。</li>\n</ol>\n<p>从上面的流程中我们可以发现，最好的渲染过程发生在微任务队列的执行过程中，此时他离页面渲染过程最近，因此我们可以借助微任务队列来实现异步更新，它可以让复杂批量的运算操作运行在JS层面，而视图的渲染只关心最终的结果，这大大降低了性能的损耗。</p>\n<p>举一个这一做法好处的例子：\n由于<code>Vue</code>是数据驱动视图更新渲染，如果我们在一个操作中重复对一个响应式数据进行计算，例如 在一个循环中执行<code>this.num ++ </code>一千次，由于响应式系统的存在，数据变化触发<code>setter</code>，<code>setter</code>触发依赖派发更新，更新调用<code>run</code>进行视图的重新渲染。这一次循环，视图渲染要执行一千次，很明显这是很浪费性能的，我们只需要关注最后第一千次在界面上更新的结果而已。所以利用异步更新显得格外重要。</p>\n<h3 id="7142-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0">7.14.2 基本实现<a class="anchor" href="#7142-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0">§</a></h3>\n<p><code>Vue</code>用一个<code>queue</code>收集依赖的执行，在下次微任务执行的时候统一执行<code>queue</code>中<code>Watcher</code>的<code>run</code>操作,与此同时，相同<code>id</code>的<code>watcher</code>不会重复添加到<code>queue</code>中,因此也不会重复执行多次的视图渲染。我们看<code>nextTick</code>的实现。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 原型上定义的方法</span>\n<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$nextTick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">return</span> <span class="token function">nextTick</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token comment">// 构造函数上定义的方法</span>\n<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">nextTick</span> <span class="token operator">=</span> nextTick<span class="token punctuation">;</span>\n\n<span class="token comment">// 实际的定义</span>\n<span class="token keyword">var</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">nextTick</span> <span class="token punctuation">(</span><span class="token parameter">cb<span class="token punctuation">,</span> ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> _resolve<span class="token punctuation">;</span>\n    <span class="token comment">// callbacks是维护微任务的数组。</span>\n    callbacks<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>\n          cb<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token string">\'nextTick\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>_resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">_resolve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      pending <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n      <span class="token comment">// 将维护的队列推到微任务队列中维护</span>\n      <span class="token function">timerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// nextTick没有传递参数，且浏览器支持Promise,则返回一个promise对象</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cb <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> <span class="token known-class-name class-name">Promise</span> <span class="token operator">!==</span> <span class="token string">\'undefined\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        _resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p><code>nextTick</code>定义为一个函数，使用方式为<code>Vue.nextTick( [callback, context] )</code>,当<code>callback</code>经过<code>nextTick</code>封装后，<code>callback</code>会在下一个<code>tick</code>中执行调用。从实现上，<code>callbacks</code>是一个维护了需要在下一个<code>tick</code>中执行的任务的队列，它的每个元素都是需要执行的函数。<code>pending</code>是判断是否在等待执行微任务队列的标志。而<code>timerFunc</code>是真正将任务队列推到微任务队列中的函数。我们看<code>timerFunc</code>的实现。</p>\n<p>1.如果浏览器执行<code>Promise</code>,那么默认以<code>Promsie</code>将执行过程推到微任务队列中。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> timerFunc<span class="token punctuation">;</span>\n\n<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token known-class-name class-name">Promise</span> <span class="token operator">!==</span> <span class="token string">\'undefined\'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 手机端的兼容代码</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>isIOS<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token comment">// 使用微任务队列的标志</span>\n  isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>flushCallbacks</code>是异步更新的函数，他会取出callbacks数组的每一个任务，执行任务，具体定义如下：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">flushCallbacks</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  pending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> copies <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 取出callbacks数组的每一个任务，执行任务</span>\n  callbacks<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    copies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>2.不支持<code>promise</code>,支持<code>MutataionObserver</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isIE <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> <span class="token maybe-class-name">MutationObserver</span> <span class="token operator">!==</span> <span class="token string">\'undefined\'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>\n    <span class="token function">isNative</span><span class="token punctuation">(</span><span class="token maybe-class-name">MutationObserver</span><span class="token punctuation">)</span> <span class="token operator">||</span>\n    <span class="token comment">// PhantomJS and iOS 7.x</span>\n    <span class="token maybe-class-name">MutationObserver</span><span class="token punctuation">.</span><span class="token method function property-access">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object MutationObserverConstructor]\'</span>\n  <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> textNode <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createTextNode</span><span class="token punctuation">(</span><span class="token known-class-name class-name">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    observer<span class="token punctuation">.</span><span class="token method function property-access">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      characterData<span class="token operator">:</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>\n      textNode<span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">=</span> <span class="token known-class-name class-name">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>3.如果不支持微任务方法，则会使用宏任务方法，<code>setImmediate</code>会先被使用</p>\n<pre class="language-js"><code class="language-js"> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">\'undefined\'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Fallback to setImmediate.</span>\n    <span class="token comment">// Techinically it leverages the (macro) task queue,</span>\n    <span class="token comment">// but it is still a better choice than setTimeout.</span>\n    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>4.所有方法都不适合，会使用宏任务方法中的<code>setTimeout</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><strong>当<code>nextTick</code>不传递任何参数时，可以作为一个<code>promise</code>用</strong>，例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="7143-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">7.14.3 使用场景<a class="anchor" href="#7143-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">§</a></h3>\n<p>说了这么多原理性的东西，回过头来看看<code>nextTick</code>的使用场景，由于异步更新的原理，我们在某一时间改变的数据并不会触发视图的更新，而是需要等下一个<code>tick</code>到来时才会更新视图，下面是一个典型场景：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>input v<span class="token operator">-</span><span class="token keyword control-flow">if</span><span class="token operator">=</span><span class="token string">"show"</span> type<span class="token operator">=</span><span class="token string">"text"</span> ref<span class="token operator">=</span><span class="token string">"myInput"</span><span class="token operator">></span>\n\n<span class="token comment">// js</span>\n<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  show<span class="token operator">:</span> <span class="token boolean">false</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">show</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$refs</span><span class="token punctuation">.</span><span class="token property-access">myInput</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 报错</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>数据改变时，视图并不会同时改变，因此需要使用<code>nextTick</code></p>\n<pre class="language-js"><code class="language-js"><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">show</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$refs</span><span class="token punctuation">.</span><span class="token property-access">myInput</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正常</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="715-watch">7.15 watch<a class="anchor" href="#715-watch">§</a></h2>\n<p>到这里，关于响应式系统的分析大部分内容已经分析完毕，我们上一节还遗留着一个问题，<code>Vue</code>对用户手动添加的<code>watch</code>如何进行数据拦截。我们先看看两种基本的使用形式。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// watch选项</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n      num<span class="token operator">:</span> <span class="token number">12</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  watch<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\nvm<span class="token punctuation">.</span><span class="token property-access">num</span> <span class="token operator">=</span> <span class="token number">111</span>\n\n<span class="token comment">// $watch api方式</span>\nvm<span class="token punctuation">.</span><span class="token method function property-access">$watch</span><span class="token punctuation">(</span><span class="token string">\'num\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  deep<span class="token operator">:</span> <span class="token punctuation">,</span>\n  immediate<span class="token operator">:</span> <span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="7151-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.15.1 依赖收集<a class="anchor" href="#7151-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">§</a></h3>\n<p>我们以<code>watch</code>选项的方式来分析<code>watch</code>的细节，同样从初始化说起，初始化数据会执行<code>initWatch</code>,<code>initWatch</code>的核心是<code>createWatcher</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initWatch</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> watch<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> handler <span class="token operator">=</span> watch<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token comment">// handler可以是数组的形式，执行多个回调</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> handler<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">createWatcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> handler<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n        <span class="token function">createWatcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">function</span> <span class="token function">createWatcher</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span>expOrFn<span class="token punctuation">,</span>handler<span class="token punctuation">,</span>options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 针对watch是对象的形式，此时回调回选项中的handler</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      options <span class="token operator">=</span> handler<span class="token punctuation">;</span>\n      handler <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token property-access">handler</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> handler <span class="token operator">===</span> <span class="token string">\'string\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      handler <span class="token operator">=</span> vm<span class="token punctuation">[</span>handler<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> vm<span class="token punctuation">.</span><span class="token method function property-access">$watch</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> options<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>无论是选项的形式，还是<code>api</code>的形式，最终都会调用实例的<code>$watch</code>方法，其中<code>expOrFn</code>是监听的字符串，<code>handler</code>是监听的回调函数，<code>options</code>是相关配置。我们重点看看<code>$watch</code>的实现。</p>\n<pre class="language-js"><code class="language-js"><span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span>cb<span class="token punctuation">,</span>options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token function">createWatcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> expOrFn<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    options <span class="token operator">=</span> options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    options<span class="token punctuation">.</span><span class="token property-access">user</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> expOrFn<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 当watch有immediate选项时，立即执行cb方法，即不需要等待属性变化，立刻执行回调。</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>\n        cb<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> watcher<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"callback for immediate watcher \""</span> <span class="token operator">+</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span><span class="token property-access">expression</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> <span class="token keyword">function</span> <span class="token function">unwatchFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      watcher<span class="token punctuation">.</span><span class="token method function property-access">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>$watch</code>的核心是创建一个<code>user watcher</code>,<code>options.user</code>是当前用户定义<code>watcher</code>的标志。如果有<code>immediate</code>属性，则立即执行回调函数。\n而实例化<code>watcher</code>时会执行一次<code>getter</code>求值，这时，<code>user watcher</code>会作为依赖被数据所收集。这个过程可以参考<code>data</code>的分析。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">Watcher</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Watcher</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazy</span>\n      <span class="token operator">?</span> <span class="token keyword nil">undefined</span>\n      <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>\n    <span class="token comment">// getter回调函数，触发依赖收集</span>\n    value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getter</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="7152-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.15.2 派发更新<a class="anchor" href="#7152-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">§</a></h3>\n<p><code>watch</code>派发更新的过程很好理解，数据发生改变时，<code>setter</code>拦截对依赖进行更新，而此前<code>user watcher</code>已经被当成依赖收集了。这个时候依赖的更新就是回调函数的执行。</p>\n<h2 id="716-%E5%B0%8F%E7%BB%93">7.16 小结<a class="anchor" href="#716-%E5%B0%8F%E7%BB%93">§</a></h2>\n<p>这一节是响应式系统构建的完结篇，<code>data,computed</code>如何进行响应式系统设计，这在上一节内容已经详细分析，这一节针对一些特殊场景做了分析。例如由于<code>Object.defineProperty</code>自身的缺陷，无法对数组的新增删除进行拦截检测，因此<code>Vue</code>对数组进行了特殊处理，重写了数组的方法，并在方法中对数据进行拦截。我们也重点介绍了<code>nextTick</code>的原理，利用浏览器的事件循环机制来达到最优的渲染时机。文章的最后补充了<code>watch</code>在响应式设计的原理，用户自定义的<code>watch</code>会创建一个依赖，这个依赖在数据改变时会执行回调。</p>'
        } }),
    'head': React.createElement(React.Fragment, null,
        React.createElement("link", { href: "src/assets/favicon.ico", rel: "icon" })),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/In-depth-analysis-of-Vue/index.js", type: "module" })),
    'footer': React.createElement("footer", null,
        "Powered by\u00A0",
        React.createElement("a", { href: "https://github.com/xcatliu/pagic", target: "_blank" }, "Pagic")),
    'contentTitle': undefined,
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>上一节，我们深入分析了以<code>data,computed</code>为数据创建响应式系统的过程，并对其中依赖收集和派发更新的过程进行了详细的分析。然而在使用和分析过程中依然存在或多或少的问题，这一节我们将针对这些问题展开分析，最后我们也会分析一下<code>watch</code>的响应式过程。这篇文章将作为响应式系统分析的完结篇。</p>\n</blockquote>\n<h2 id="712-%E6%95%B0%E7%BB%84%E6%A3%80%E6%B5%8B">7.12 数组检测<a class="anchor" href="#712-%E6%95%B0%E7%BB%84%E6%A3%80%E6%B5%8B">§</a></h2>\n<p>在之前介绍数据代理章节，我们已经详细介绍过<code>Vue</code>数据代理的技术是利用了<code>Object.defineProperty</code>,<code>Object.defineProperty</code>让我们可以方便的利用存取描述符中的<code>getter/setter</code>来进行数据的监听,在<code>get,set</code>钩子中分别做不同的操作，达到数据拦截的目的。然而<code>Object.defineProperty</code>的<code>get,set</code>方法只能检测到对象属性的变化，对于数组的变化(例如插入删除数组元素等操作)，<code>Object.defineProperty</code>却无法达到目的,这也是利用<code>Object.defineProperty</code>进行数据监控的缺陷，虽然<code>es6</code>中的<code>proxy</code>可以完美解决这一问题，但毕竟有兼容性问题，所以我们还需要研究<code>Vue</code>在<code>Object.defineProperty</code>的基础上如何对数组进行监听检测。</p>\n<h3 id="7121-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">7.12.1 数组方法的重写<a class="anchor" href="#7121-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">§</a></h3>\n<p>既然数组已经不能再通过数据的<code>getter,setter</code>方法去监听变化了，<code>Vue</code>的做法是对数组方法进行重写，在保留原数组功能的前提下，对数组进行额外的操作处理。也就是重新定义了数组方法。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>\n<span class="token comment">// 新建一个继承于Array的对象</span>\n<span class="token keyword">var</span> arrayMethods <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 数组拥有的方法</span>\n<span class="token keyword">var</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token string">\'push\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'pop\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'shift\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'unshift\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'splice\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'sort\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'reverse\'</span>\n<span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre>\n<p><code>arrayMethods</code>是基于原始<code>Array</code>类为原型继承的一个对象类，由于原型链的继承，<code>arrayMethod</code>拥有数组的所有方法，接下来对这个新的数组类的方法进行改写。</p>\n<pre class="language-js"><code class="language-js">methodsToPatch<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 缓冲原始数组的方法</span>\n  <span class="token keyword">var</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token comment">// 利用Object.defineProperty对方法的执行进行改写</span>\n  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">def</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> enumerable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      value<span class="token operator">:</span> val<span class="token punctuation">,</span>\n      enumerable<span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span>enumerable<span class="token punctuation">,</span>\n      writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      configurable<span class="token operator">:</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n</code></pre>\n<p>这里对数组方法设置了代理，当执行<code>arrayMethods</code>的数组方法时，会代理执行<code>mutator</code>函数，这个函数的具体实现，我们放到数组的派发更新中介绍。</p>\n<p><strong>仅仅创建一个新的数组方法合集是不够的，我们在访问数组时，如何不调用原生的数组方法，而是将过程指向这个新的类，这是下一步的重点。</strong></p>\n<p>回到数据初始化过程，也就是执行<code>initData</code>阶段，上一篇内容花了大篇幅介绍过数据初始化会为<code>data</code>数据创建一个<code>Observer</code>类，当时我们只讲述了<code>Observer</code>类会为每个非数组的属性进行数据拦截，重新定义<code>getter,setter</code>方法,除此之外对于数组类型的数据，我们有意跳过分析了。这里，我们重点看看对于数组拦截的处理。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">Observer</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Observer</span></span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">dep</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">vmCount</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token comment">// 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。</span>\n  <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">\'__ob__\'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 数组处理</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>hasProto<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">protoAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n      <span class="token function">copyAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 对象处理</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>数组处理的分支分为两个，<code>hasProto</code>的判断条件，<code>hasProto</code>用来判断当前环境下是否支持<code>__proto__</code>属性。而数组的处理会根据是否支持这一属性来决定执行<code>protoAugment, copyAugment</code>过程，</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// __proto__属性的判断</span>\n<span class="token keyword">var</span> hasProto <span class="token operator">=</span> <span class="token string">\'__proto__\'</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n<p><strong>当支持<code>__proto__</code>时，执行<code>protoAugment</code>会将当前数组的原型指向新的数组类<code>arrayMethods</code>,如果不支持<code>__proto__</code>，则通过代理设置，在访问数组方法时代理访问新数组类中的数组方法。</strong></p>\n<pre class="language-js"><code class="language-js"><span class="token comment">//直接通过原型指向的方式</span>\n\n<span class="token keyword">function</span> <span class="token function">protoAugment</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  target<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">=</span> src<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 通过数据代理的方式</span>\n<span class="token keyword">function</span> <span class="token function">copyAugment</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> src<span class="token punctuation">,</span> keys</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token function">def</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>有了这两步的处理，接下来我们在实例内部调用<code>push, unshift</code>等数组的方法时，会执行<code>arrayMethods</code>类的方法。这也是数组进行依赖收集和派发更新的前提。</p>\n<h3 id="7122-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.12.2 依赖收集<a class="anchor" href="#7122-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">§</a></h3>\n<p>由于数据初始化阶段会利用<code>Object.definePrototype</code>进行数据访问的改写，数组的访问同样会被<code>getter</code>所拦截。由于是数组，拦截过程会做特殊处理，后面我们再看看<code>dependArray</code>的原理。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> defineReactive###<span class="token number">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword">var</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">var</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> getter<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>\n          <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            dep<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              childOb<span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n              <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">dependArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n              <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n          <span class="token punctuation">}</span>\n          <span class="token keyword control-flow">return</span> value\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n \n</code></pre>\n<p><code>childOb</code>是标志属性值是否为基础类型的标志，<code>observe</code>如果遇到基本类型数据，则直接返回，不做任何处理，如果遇到对象或者数组则会递归实例化<code>Observer</code>，会为每个子属性设置响应式数据，最终返回<code>Observer</code>实例。而实例化<code>Observer</code>又回到之前的老流程：\n<strong>添加<code>__ob__</code>属性，如果遇到数组则进行原型重指向，遇到对象则定义<code>getter,setter</code>，这一过程前面分析过，就不再阐述。</strong></p>\n<p>在访问到数组时，由于<code>childOb</code>的存在，会执行<code>childOb.dep.depend();</code>进行依赖收集，该<code>Observer</code>实例的<code>dep</code>属性会收集当前的<code>watcher</code>作为依赖保存，<code>dependArray</code>保证了如果数组元素是数组或者对象，需要递归去为内部的元素收集相关的依赖。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">dependArray</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      e <span class="token operator">=</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token property-access">__ob__</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token property-access">__ob__</span><span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">dependArray</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n</code></pre>\n<p>我们可以通过截图看最终依赖收集的结果。</p>\n<p>收集前</p>\n<p><img src="./img/7.1.png" alt=""></p>\n<p>收集后</p>\n<p><img src="./img/7.2.png" alt=""></p>\n<h3 id="7123-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.12.3 派发更新<a class="anchor" href="#7123-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">§</a></h3>\n<p>当调用数组的方法去添加或者删除数据时，数据的<code>setter</code>方法是无法拦截的，所以我们唯一可以拦截的过程就是调用数组方法的时候，前面介绍过，数组方法的调用会代理到新类<code>arrayMethods</code>的方法中,而<code>arrayMethods</code>的数组方法是进行重写过的。具体我们看他的定义。</p>\n<pre class="language-js"><code class="language-js"> methodsToPatch<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arguments<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span> len<span class="token operator">--</span> <span class="token punctuation">)</span> args<span class="token punctuation">[</span> len <span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span> len <span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token comment">// 执行原数组方法</span>\n      <span class="token keyword">var</span> result <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">__ob__</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> inserted<span class="token punctuation">;</span>\n      <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">case</span> <span class="token string">\'push\'</span><span class="token operator">:</span>\n        <span class="token keyword">case</span> <span class="token string">\'unshift\'</span><span class="token operator">:</span>\n          inserted <span class="token operator">=</span> args<span class="token punctuation">;</span>\n          <span class="token keyword control-flow">break</span>\n        <span class="token keyword">case</span> <span class="token string">\'splice\'</span><span class="token operator">:</span>\n          inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword control-flow">break</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> <span class="token punctuation">{</span> ob<span class="token punctuation">.</span><span class="token method function property-access">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n      <span class="token comment">// notify change</span>\n      ob<span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> result\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre>\n<p><code>mutator</code>是重写的数组方法，首先会调用原始的数组方法进行运算，这保证了与原始数组类型的方法一致性，<code>args</code>保存了数组方法调用传递的参数。之后取出数组的<code>__ob__</code>也就是之前保存的<code>Observer</code>实例，调用<code>ob.dep.notify();</code>进行依赖的派发更新，前面知道了。<code>Observer</code>实例的<code>dep</code>是<code>Dep</code>的实例，他收集了需要监听的<code>watcher</code>依赖，而<code>notify</code>会对依赖进行重新计算并更新。具体看<code>Dep.prototype.notify = function notify () {}</code>函数的分析，这里也不重复赘述。</p>\n<p>回到代码中，<code>inserted</code>变量用来标志数组是否是增加了元素，如果增加的元素不是原始类型，而是数组对象类型，则需要触发<code>observeArray</code>方法，对每个元素进行依赖收集。</p>\n<pre class="language-js"><code class="language-js"><span class="token class-name">Observer</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">observeArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n<p><strong>总的来说。数组的改变不会触发<code>setter</code>进行依赖更新，所以<code>Vue</code>创建了一个新的数组类，重写了数组的方法，将数组方法指向了新的数组类。同时在访问到数组时依旧触发<code>getter</code>进行依赖收集，在更改数组时，触发数组新方法运算，并进行依赖的派发。</strong></p>\n<p>现在我们回过头看看Vue的官方文档对于数组检测时的注意事项：</p>\n<blockquote>\n<p><code>Vue</code> 不能检测以下数组的变动:</p>\n<ul>\n<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>\n</ul>\n</blockquote>\n<p>显然有了上述的分析我们很容易理解数组检测带来的弊端，即使<code>Vue</code>重写了数组的方法，以便在设置数组时进行拦截处理，但是不管是通过索引还是直接修改长度，都是无法触发依赖更新的。</p>\n<h2 id="713-%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8">7.13 对象检测异常<a class="anchor" href="#713-%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8">§</a></h2>\n<p>我们在实际开发中经常遇到一种场景，对象<code>test: { a: 1 }</code>要添加一个属性<code>b</code>,这时如果我们使用<code>test.b = 2</code>的方式去添加，这个过程<code>Vue</code>是无法检测到的，理由也很简单。我们在对对象进行依赖收集的时候，会为对象的每个属性都进行收集依赖，而直接通过<code>test.b</code>添加的新属性并没有依赖收集的过程，因此当之后数据<code>b</code>发生改变时也不会进行依赖的更新。</p>\n<p>了解决这一问题，<code>Vue</code>提供了<code>Vue.set(object, propertyName, value)</code>的静态方法和<code>vm.$set(object, propertyName, value)</code>的实例方法，我们看具体怎么完成新属性的依赖收集过程。</p>\n<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">set</span> <span class="token operator">=</span> <span class="token keyword">set</span>\n<span class="token keyword">function</span> <span class="token function">set</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//target必须为非空对象</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>\n    <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Cannot set reactive property on undefined, null, or primitive value: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 数组场景，调用重写的splice方法，对新添加属性收集依赖。</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      target<span class="token punctuation">.</span><span class="token method function property-access">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 新增对象的属性存在时，直接返回新属性，触发依赖收集</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 拿到目标源的Observer 实例</span>\n    <span class="token keyword">var</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">__ob__</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token property-access">_isVue</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ob <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">.</span><span class="token property-access">vmCount</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warn</span><span class="token punctuation">(</span>\n        <span class="token string">\'Avoid adding reactive properties to a Vue instance or its root $data \'</span> <span class="token operator">+</span>\n        <span class="token string">\'at runtime - declare it upfront in the data option.\'</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 目标源对象本身不是一个响应式对象，则不需要处理</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 手动调用defineReactive，为新属性设置getter,setter</span>\n    defineReactive###<span class="token number">1</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    ob<span class="token punctuation">.</span><span class="token property-access">dep</span><span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">return</span> val\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>按照分支分为不同的四个处理逻辑：</p>\n<ol>\n<li>目标对象必须为非空的对象，可以是数组，否则抛出异常。</li>\n<li>如果目标对象是数组时，调用数组的<code>splice</code>方法，而前面分析数组检测时，遇到数组新增元素的场景，会调用<code>ob.observeArray(inserted)</code>对数组新增的元素收集依赖。</li>\n<li>新增的属性值在原对象中已经存在，则手动访问新的属性值，这一过程会触发依赖收集。</li>\n<li>手动定义新属性的<code>getter,setter</code>方法，并通过<code>notify</code>触发依赖更新。</li>\n</ol>\n<h2 id="714-nexttick">7.14 nextTick<a class="anchor" href="#714-nexttick">§</a></h2>\n<p>在上一节的内容中，我们说到数据修改时会触发<code>setter</code>方法进行依赖的派发更新，而更新时会将每个<code>watcher</code>推到队列中，等待下一个<code>tick</code>到来时再执行<code>DOM</code>的渲染更新操作。这个就是异步更新的过程。为了说明异步更新的概念，需要牵扯到浏览器的事件循环机制和最优的渲染时机问题。由于这不是文章的主线，我只用简单的语言概述。</p>\n<h3 id="7141-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6">7.14.1 事件循环机制<a class="anchor" href="#7141-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6">§</a></h3>\n<ol>\n<li>完整的事件循环机制需要了解两种异步队列：<code>macro-task</code>和<code>micro-task</code></li>\n<li><code>macro-task</code>常见的有 <code>setTimeout, setInterval, setImmediate, script脚本, I/O操作，UI渲染</code></li>\n<li><code>micro-task</code>常见的有 <code>promise, process.nextTick, MutationObserver</code>等</li>\n<li>完整事件循环流程为：\n4.1 <code>micro-task</code>空，<code>macro-task</code>队列只有<code>script</code>脚本，推出<code>macro-task</code>的<code>script</code>任务执行，脚本执行期间产生的<code>macro-task，micro-task</code>推到对应的队列中\n4.2 执行全部<code>micro-task</code>里的微任务事件\n4.3 执行<code>DOM</code>操作，渲染更新页面\n4.4 执行<code>web worker</code>等相关任务\n4.5 循环，取出<code>macro-task</code>中一个宏任务事件执行，重复4的操作。</li>\n</ol>\n<p>从上面的流程中我们可以发现，最好的渲染过程发生在微任务队列的执行过程中，此时他离页面渲染过程最近，因此我们可以借助微任务队列来实现异步更新，它可以让复杂批量的运算操作运行在JS层面，而视图的渲染只关心最终的结果，这大大降低了性能的损耗。</p>\n<p>举一个这一做法好处的例子：\n由于<code>Vue</code>是数据驱动视图更新渲染，如果我们在一个操作中重复对一个响应式数据进行计算，例如 在一个循环中执行<code>this.num ++ </code>一千次，由于响应式系统的存在，数据变化触发<code>setter</code>，<code>setter</code>触发依赖派发更新，更新调用<code>run</code>进行视图的重新渲染。这一次循环，视图渲染要执行一千次，很明显这是很浪费性能的，我们只需要关注最后第一千次在界面上更新的结果而已。所以利用异步更新显得格外重要。</p>\n<h3 id="7142-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0">7.14.2 基本实现<a class="anchor" href="#7142-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0">§</a></h3>\n<p><code>Vue</code>用一个<code>queue</code>收集依赖的执行，在下次微任务执行的时候统一执行<code>queue</code>中<code>Watcher</code>的<code>run</code>操作,与此同时，相同<code>id</code>的<code>watcher</code>不会重复添加到<code>queue</code>中,因此也不会重复执行多次的视图渲染。我们看<code>nextTick</code>的实现。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 原型上定义的方法</span>\n<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$nextTick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword control-flow">return</span> <span class="token function">nextTick</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token comment">// 构造函数上定义的方法</span>\n<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">nextTick</span> <span class="token operator">=</span> nextTick<span class="token punctuation">;</span>\n\n<span class="token comment">// 实际的定义</span>\n<span class="token keyword">var</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">nextTick</span> <span class="token punctuation">(</span><span class="token parameter">cb<span class="token punctuation">,</span> ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> _resolve<span class="token punctuation">;</span>\n    <span class="token comment">// callbacks是维护微任务的数组。</span>\n    callbacks<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>\n          cb<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token string">\'nextTick\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>_resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">_resolve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      pending <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n      <span class="token comment">// 将维护的队列推到微任务队列中维护</span>\n      <span class="token function">timerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// nextTick没有传递参数，且浏览器支持Promise,则返回一个promise对象</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cb <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> <span class="token known-class-name class-name">Promise</span> <span class="token operator">!==</span> <span class="token string">\'undefined\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        _resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p><code>nextTick</code>定义为一个函数，使用方式为<code>Vue.nextTick( [callback, context] )</code>,当<code>callback</code>经过<code>nextTick</code>封装后，<code>callback</code>会在下一个<code>tick</code>中执行调用。从实现上，<code>callbacks</code>是一个维护了需要在下一个<code>tick</code>中执行的任务的队列，它的每个元素都是需要执行的函数。<code>pending</code>是判断是否在等待执行微任务队列的标志。而<code>timerFunc</code>是真正将任务队列推到微任务队列中的函数。我们看<code>timerFunc</code>的实现。</p>\n<p>1.如果浏览器执行<code>Promise</code>,那么默认以<code>Promsie</code>将执行过程推到微任务队列中。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> timerFunc<span class="token punctuation">;</span>\n\n<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token known-class-name class-name">Promise</span> <span class="token operator">!==</span> <span class="token string">\'undefined\'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 手机端的兼容代码</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>isIOS<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token comment">// 使用微任务队列的标志</span>\n  isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>flushCallbacks</code>是异步更新的函数，他会取出callbacks数组的每一个任务，执行任务，具体定义如下：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">flushCallbacks</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  pending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> copies <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 取出callbacks数组的每一个任务，执行任务</span>\n  callbacks<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    copies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>2.不支持<code>promise</code>,支持<code>MutataionObserver</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isIE <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> <span class="token maybe-class-name">MutationObserver</span> <span class="token operator">!==</span> <span class="token string">\'undefined\'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>\n    <span class="token function">isNative</span><span class="token punctuation">(</span><span class="token maybe-class-name">MutationObserver</span><span class="token punctuation">)</span> <span class="token operator">||</span>\n    <span class="token comment">// PhantomJS and iOS 7.x</span>\n    <span class="token maybe-class-name">MutationObserver</span><span class="token punctuation">.</span><span class="token method function property-access">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object MutationObserverConstructor]\'</span>\n  <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> textNode <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createTextNode</span><span class="token punctuation">(</span><span class="token known-class-name class-name">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    observer<span class="token punctuation">.</span><span class="token method function property-access">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      characterData<span class="token operator">:</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>\n      textNode<span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">=</span> <span class="token known-class-name class-name">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>3.如果不支持微任务方法，则会使用宏任务方法，<code>setImmediate</code>会先被使用</p>\n<pre class="language-js"><code class="language-js"> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">\'undefined\'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Fallback to setImmediate.</span>\n    <span class="token comment">// Techinically it leverages the (macro) task queue,</span>\n    <span class="token comment">// but it is still a better choice than setTimeout.</span>\n    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>4.所有方法都不适合，会使用宏任务方法中的<code>setTimeout</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><strong>当<code>nextTick</code>不传递任何参数时，可以作为一个<code>promise</code>用</strong>，例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="7143-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">7.14.3 使用场景<a class="anchor" href="#7143-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">§</a></h3>\n<p>说了这么多原理性的东西，回过头来看看<code>nextTick</code>的使用场景，由于异步更新的原理，我们在某一时间改变的数据并不会触发视图的更新，而是需要等下一个<code>tick</code>到来时才会更新视图，下面是一个典型场景：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>input v<span class="token operator">-</span><span class="token keyword control-flow">if</span><span class="token operator">=</span><span class="token string">"show"</span> type<span class="token operator">=</span><span class="token string">"text"</span> ref<span class="token operator">=</span><span class="token string">"myInput"</span><span class="token operator">></span>\n\n<span class="token comment">// js</span>\n<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  show<span class="token operator">:</span> <span class="token boolean">false</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">show</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$refs</span><span class="token punctuation">.</span><span class="token property-access">myInput</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 报错</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>数据改变时，视图并不会同时改变，因此需要使用<code>nextTick</code></p>\n<pre class="language-js"><code class="language-js"><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">show</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$refs</span><span class="token punctuation">.</span><span class="token property-access">myInput</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正常</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="715-watch">7.15 watch<a class="anchor" href="#715-watch">§</a></h2>\n<p>到这里，关于响应式系统的分析大部分内容已经分析完毕，我们上一节还遗留着一个问题，<code>Vue</code>对用户手动添加的<code>watch</code>如何进行数据拦截。我们先看看两种基本的使用形式。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// watch选项</span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n      num<span class="token operator">:</span> <span class="token number">12</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  watch<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\nvm<span class="token punctuation">.</span><span class="token property-access">num</span> <span class="token operator">=</span> <span class="token number">111</span>\n\n<span class="token comment">// $watch api方式</span>\nvm<span class="token punctuation">.</span><span class="token method function property-access">$watch</span><span class="token punctuation">(</span><span class="token string">\'num\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  deep<span class="token operator">:</span> <span class="token punctuation">,</span>\n  immediate<span class="token operator">:</span> <span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="7151-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">7.15.1 依赖收集<a class="anchor" href="#7151-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">§</a></h3>\n<p>我们以<code>watch</code>选项的方式来分析<code>watch</code>的细节，同样从初始化说起，初始化数据会执行<code>initWatch</code>,<code>initWatch</code>的核心是<code>createWatcher</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initWatch</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> watch<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> handler <span class="token operator">=</span> watch<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token comment">// handler可以是数组的形式，执行多个回调</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> handler<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">createWatcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> handler<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n        <span class="token function">createWatcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">function</span> <span class="token function">createWatcher</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span>expOrFn<span class="token punctuation">,</span>handler<span class="token punctuation">,</span>options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 针对watch是对象的形式，此时回调回选项中的handler</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      options <span class="token operator">=</span> handler<span class="token punctuation">;</span>\n      handler <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token property-access">handler</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> handler <span class="token operator">===</span> <span class="token string">\'string\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      handler <span class="token operator">=</span> vm<span class="token punctuation">[</span>handler<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> vm<span class="token punctuation">.</span><span class="token method function property-access">$watch</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> options<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<p>无论是选项的形式，还是<code>api</code>的形式，最终都会调用实例的<code>$watch</code>方法，其中<code>expOrFn</code>是监听的字符串，<code>handler</code>是监听的回调函数，<code>options</code>是相关配置。我们重点看看<code>$watch</code>的实现。</p>\n<pre class="language-js"><code class="language-js"><span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span>cb<span class="token punctuation">,</span>options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> <span class="token function">createWatcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> expOrFn<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    options <span class="token operator">=</span> options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    options<span class="token punctuation">.</span><span class="token property-access">user</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> expOrFn<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 当watch有immediate选项时，立即执行cb方法，即不需要等待属性变化，立刻执行回调。</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>\n        cb<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> watcher<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"callback for immediate watcher \""</span> <span class="token operator">+</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span><span class="token property-access">expression</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword control-flow">return</span> <span class="token keyword">function</span> <span class="token function">unwatchFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      watcher<span class="token punctuation">.</span><span class="token method function property-access">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>$watch</code>的核心是创建一个<code>user watcher</code>,<code>options.user</code>是当前用户定义<code>watcher</code>的标志。如果有<code>immediate</code>属性，则立即执行回调函数。\n而实例化<code>watcher</code>时会执行一次<code>getter</code>求值，这时，<code>user watcher</code>会作为依赖被数据所收集。这个过程可以参考<code>data</code>的分析。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">Watcher</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Watcher</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazy</span>\n      <span class="token operator">?</span> <span class="token keyword nil">undefined</span>\n      <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Watcher</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>\n    <span class="token comment">// getter回调函数，触发依赖收集</span>\n    value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getter</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="7152-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">7.15.2 派发更新<a class="anchor" href="#7152-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0">§</a></h3>\n<p><code>watch</code>派发更新的过程很好理解，数据发生改变时，<code>setter</code>拦截对依赖进行更新，而此前<code>user watcher</code>已经被当成依赖收集了。这个时候依赖的更新就是回调函数的执行。</p>\n<h2 id="716-%E5%B0%8F%E7%BB%93">7.16 小结<a class="anchor" href="#716-%E5%B0%8F%E7%BB%93">§</a></h2>\n<p>这一节是响应式系统构建的完结篇，<code>data,computed</code>如何进行响应式系统设计，这在上一节内容已经详细分析，这一节针对一些特殊场景做了分析。例如由于<code>Object.defineProperty</code>自身的缺陷，无法对数组的新增删除进行拦截检测，因此<code>Vue</code>对数组进行了特殊处理，重写了数组的方法，并在方法中对数据进行拦截。我们也重点介绍了<code>nextTick</code>的原理，利用浏览器的事件循环机制来达到最优的渲染时机。文章的最后补充了<code>watch</code>在响应式设计的原理，用户自定义的<code>watch</code>会创建一个依赖，这个依赖在数据改变时会执行回调。</p>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#712-%E6%95%B0%E7%BB%84%E6%A3%80%E6%B5%8B" }, "7.12 \u6570\u7EC4\u68C0\u6D4B"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7121-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99" }, "7.12.1 \u6570\u7EC4\u65B9\u6CD5\u7684\u91CD\u5199")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7122-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86" }, "7.12.2 \u4F9D\u8D56\u6536\u96C6")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7123-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0" }, "7.12.3 \u6D3E\u53D1\u66F4\u65B0")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#713-%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8" }, "7.13 \u5BF9\u8C61\u68C0\u6D4B\u5F02\u5E38")),
            React.createElement("li", null,
                React.createElement("a", { href: "#714-nexttick" }, "7.14 nextTick"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7141-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6" }, "7.14.1 \u4E8B\u4EF6\u5FAA\u73AF\u673A\u5236")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7142-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0" }, "7.14.2 \u57FA\u672C\u5B9E\u73B0")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7143-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" }, "7.14.3 \u4F7F\u7528\u573A\u666F")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#715-watch" }, "7.15 watch"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7151-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86" }, "7.15.1 \u4F9D\u8D56\u6536\u96C6")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#7152-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0" }, "7.15.2 \u6D3E\u53D1\u66F4\u65B0")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#716-%E5%B0%8F%E7%BB%93" }, "7.16 \u5C0F\u7ED3")))),
    'author': "wyp",
    'contributors': [
        "wyp",
        "hyfun"
    ],
    'date': "2019-10-29T06:12:00.000Z",
    'updated': "2021-09-15T02:34:36.000Z",
    'excerpt': "7.12 数组检测 在之前介绍数据代理章节，我们已经详细介绍过Vue数据代理的技术是利用了Object.defineProperty,Object.defineProperty让我们可以方便的利用存取描述符中的getter/setter来进行数据的监听,在get,set钩子中分别做不...",
    'cover': "./img/7.1.png",
    'sidebar': [
        {
            "text": "Introduction",
            "link": "introduction/index.html",
            "pagePath": "introduction/README.md"
        },
        {
            "text": "1.丰富的选项合并策略",
            "link": "src/1.丰富的选项合并策略.html",
            "pagePath": "src/1.丰富的选项合并策略.md"
        },
        {
            "text": "2.基础的数据代理检测",
            "link": "src/2.基础的数据代理检测.html",
            "pagePath": "src/2.基础的数据代理检测.md"
        },
        {
            "text": "3.实例挂载流程和模板编译",
            "link": "src/3.实例挂载流程和模板编译.html",
            "pagePath": "src/3.实例挂载流程和模板编译.md"
        },
        {
            "text": "4.完整渲染流程",
            "link": "src/4.完整渲染流程.html",
            "pagePath": "src/4.完整渲染流程.md"
        },
        {
            "text": "5.组件基础剖析",
            "link": "src/5.组件基础剖析.html",
            "pagePath": "src/5.组件基础剖析.md"
        },
        {
            "text": "6.组件高级用法",
            "link": "src/6.组件高级用法.html",
            "pagePath": "src/6.组件高级用法.md"
        },
        {
            "text": "7.深入响应式系统构建-上",
            "link": "src/7.深入响应式系统构建-上.html",
            "pagePath": "src/7.深入响应式系统构建-上.md"
        },
        {
            "text": "7.深入响应式系统构建-中",
            "link": "src/7.深入响应式系统构建-中.html",
            "pagePath": "src/7.深入响应式系统构建-中.md"
        },
        {
            "text": "7.深入响应式系统构建-下",
            "link": "src/7.深入响应式系统构建-下.html",
            "pagePath": "src/7.深入响应式系统构建-下.md"
        },
        {
            "text": "8.来，跟我一起实现diff算法",
            "link": "src/8.来，跟我一起实现diff算法.html",
            "pagePath": "src/8.来，跟我一起实现diff算法.md"
        },
        {
            "text": "9.揭秘Vue的事件机制",
            "link": "src/9.揭秘Vue的事件机制.html",
            "pagePath": "src/9.揭秘Vue的事件机制.md"
        },
        {
            "text": "10.vue插槽，你想了解的都在这里",
            "link": "src/10.vue插槽，你想了解的都在这里.html",
            "pagePath": "src/10.vue插槽，你想了解的都在这里.md"
        },
        {
            "text": "11.你真的了解v-model的语法糖了吗",
            "link": "src/11.你真的了解v-model的语法糖了吗.html",
            "pagePath": "src/11.你真的了解v-model的语法糖了吗.md"
        },
        {
            "text": "12.动态组件的深入分析",
            "link": "src/12.动态组件的深入分析.html",
            "pagePath": "src/12.动态组件的深入分析.md"
        },
        {
            "text": "13.彻底搞懂Vue中keep-alive的魔法-上",
            "link": "src/13.彻底搞懂Vue中keep-alive的魔法-上.html",
            "pagePath": "src/13.彻底搞懂Vue中keep-alive的魔法-上.md"
        },
        {
            "text": "13.彻底搞懂Vue中keep-alive的魔法-下",
            "link": "src/13.彻底搞懂Vue中keep-alive的魔法-下.html",
            "pagePath": "src/13.彻底搞懂Vue中keep-alive的魔法-下.md"
        }
    ]
};
