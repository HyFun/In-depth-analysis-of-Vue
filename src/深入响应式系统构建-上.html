<!doctype html><html class="" data-reactroot=""><head><link rel="icon" href="/In-depth-analysis-of-Vue/src/assets/favicon.ico"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:title" content="深入剖析Vue源码"/><meta data-react-helmet="true" property="og:description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary"/>
<title data-react-helmet="true">深入剖析Vue源码</title>
<link data-react-helmet="true" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/In-depth-analysis-of-Vue/assets/prism_tomorrow.css";
    }
  </script>
</head><body><header><h1 class="hide_on_mobile"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1><nav><ul><li class="show_on_mobile flex_center"><a class="czs-menu-l" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-menu-l.svg&quot;)"></a></li><li class="show_on_mobile"><h1 class="mobile_title"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1></li><li class="hide_on_mobile"><a href="https://cn.vuejs.org/index.html" target="_blank">Vue2.x文档</a></li><li class="hide_on_mobile"><a href="https://book.penblog.cn/" target="_blank">历史地址</a></li><li class="hide_on_mobile"><a>赞助作者</a></li><li style="flex-grow:1"></li><li class="flex_center"><a class="czs-github-logo" href="https://github.com/Ocean1509/In-depth-analysis-of-Vue" target="_blank" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-github-logo.svg&quot;)"></a></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon-l.svg&quot;)"></span></li></ul></nav></header><aside class="sidebar"><ol class="list_style_none"><li class=""><a href="/In-depth-analysis-of-Vue/src/1.丰富的选项合并策略.md" class="nav_link">1.丰富的选项合并策略</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/2.基础的数据代理检测.md" class="nav_link">2.基础的数据代理检测</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/3.实例挂载流程和模板编译.md" class="nav_link">3.实例挂载流程和模板编译</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/4.完整渲染流程.md" class="nav_link">4.完整渲染流程</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/5.组件基础剖析.md" class="nav_link">5.组件基础剖析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/6.组件高级用法.md" class="nav_link">6.组件高级用法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-上.md" class="nav_link">7.深入响应式系统构建-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-中.md" class="nav_link">7.深入响应式系统构建-中</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-下.md" class="nav_link">7.深入响应式系统构建-下</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/8.来，跟我一起实现diff算法.md" class="nav_link">8.来，跟我一起实现diff算法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/9.揭秘Vue的事件机制.md" class="nav_link">9.揭秘Vue的事件机制</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/10.vue插槽，你想了解的都在这里.md" class="nav_link">10.vue插槽，你想了解的都在这里</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/11.你真的了解v-model的语法糖了吗.md" class="nav_link">11.你真的了解v-model的语法糖了吗</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/12.动态组件的深入分析.md" class="nav_link">12.动态组件的深入分析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-上.md" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-下.md" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-下</a></li></ol></aside><section class="main"><div class="main_article"><article><blockquote>
<p>从这一小节开始，正式进入<code>Vue</code>源码的核心，也是难点之一，响应式系统的构建。这一节将作为分析响应式构建过程源码的入门，主要分为两大块,第一块是针对响应式数据<code>props,methods,data,computed,wather</code>初始化过程的分析，另一块则是在保留源码设计理念的前提下，尝试手动构建一个基础的响应式系统。有了这两个基础内容的铺垫，下一篇进行源码具体细节的分析会更加得心应手。</p>
</blockquote>
<h2 id="71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96">7.1 数据初始化<a class="anchor" href="#71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96">§</a></h2>
<p>回顾一下之前的内容，我们对<code>Vue</code>源码的分析是从初始化开始，初始化<code>_init</code>会执行一系列的过程，这个过程包括了配置选项的合并，数据的监测代理，最后才是实例的挂载。而在实例挂载前还有意忽略了一个重要的过程，<strong>数据的初始化</strong>(即<code>initState(vm)</code>)。<code>initState</code>的过程，是对数据进行响应式设计的过程，过程会针对<code>props,methods,data,computed</code>和<code>watch</code>做数据的初始化处理，并将他们转换为响应式对象，接下来我们会逐步分析每一个过程。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token property-access">_watchers</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化props</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// 初始化methods</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// 初始化data</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有定义data，则创建一个空对象，并设置为响应式</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">_data</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化computed</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">computed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">computed</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// 初始化watch</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">watch</span> <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span><span class="token property-access">watch</span> <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">watch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="72-initprops">7.2 initProps<a class="anchor" href="#72-initprops">§</a></h2>
<p>简单回顾一下<code>props</code>的用法，父组件通过属性的形式将数据传递给子组件，子组件通过<code>props</code>属性接收父组件传递的值。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 父组件</span>
<span class="token operator">&lt;</span>child <span class="token operator">:</span>test<span class="token operator">=</span><span class="token string">"test"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
      test<span class="token operator">:</span> <span class="token string">'child'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 子组件</span>
<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">component</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token string">'&lt;div>{{test}}&lt;/div>'</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'test'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>因此分析<code>props</code>需要分析父组件和子组件的两个过程，我们先看父组件对传递值的处理。按照以往文章介绍的那样，父组件优先进行模板编译得到一个<code>render</code>函数，在解析过程中遇到子组件的属性，<code>:test=test</code>会被解析成<code>{ attrs: {test： test}}</code>并作为子组件的<code>render</code>函数存在，如下所示:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token method function property-access">_c</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"test"</span><span class="token operator">:</span>test<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre>
<p><code>render</code>解析<code>Vnode</code>的过程遇到<code>child</code>这个子占位符节点，因此会进入创建子组件<code>Vnode</code>的过程，创建子<code>Vnode</code>过程是调用<code>createComponent</code>,这个阶段我们在组件章节有分析过，在组件的高级用法也有分析过，最终会调用<code>new Vnode</code>去创建子<code>Vnode</code>。而对于<code>props</code>的处理，<code>extractPropsFromVNodeData</code>会对<code>attrs</code>属性进行规范校验后，最后会把校验后的结果以<code>propsData</code>属性的形式传入<code>Vnode</code>构造器中。总结来说，<code>props</code>传递给占位符组件的写法，会以<code>propsData</code>的形式作为子组件<code>Vnode</code>的属性存在。下面会分析具体的细节。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 创建子组件过程</span>
<span class="token keyword">function</span> <span class="token function">createComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// props校验</span>
  <span class="token keyword">var</span> propsData <span class="token operator">=</span> <span class="token function">extractPropsFromVNodeData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span><span class="token punctuation">;</span>
  ···
  <span class="token comment">// 创建子组件vnode</span>
  <span class="token keyword">var</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token string">"vue-component-"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">cid</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>name <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    data<span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token maybe-class-name">Ctor</span><span class="token operator">:</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> propsData<span class="token operator">:</span> propsData<span class="token punctuation">,</span> listeners<span class="token operator">:</span> listeners<span class="token punctuation">,</span> tag<span class="token operator">:</span> tag<span class="token punctuation">,</span> children<span class="token operator">:</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>
    asyncFactory
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">7.2.1 props的命名规范<a class="anchor" href="#721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">§</a></h3>
<p>先看检测<code>props</code>规范性的过程。**<code>props</code>编译后的结果有两种，其中<code>attrs</code>前面分析过，是编译生成<code>render</code>函数针对属性的处理，而<code>props</code>是针对用户自写<code>render</code>函数的属性值。**因此需要同时对这两种方式进行校验。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">extractPropsFromVNodeData</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span>tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Ctor为子类构造器</span>
  ···
  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 子组件props选项</span>
  <span class="token keyword">var</span> propOptions <span class="token operator">=</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
  <span class="token comment">// data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数</span>
  <span class="token keyword">var</span> attrs <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isDef</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> propOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// aB 形式转成 a-b</span>
      <span class="token keyword">var</span> altKey <span class="token operator">=</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">{</span>
          <span class="token keyword">var</span> keyInLowerCase <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>
            key <span class="token operator">!==</span> keyInLowerCase <span class="token operator">&amp;&amp;</span>
            attrs <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> keyInLowerCase<span class="token punctuation">)</span>
          <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 警告</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>重点说一下源码在这一部分的处理，<strong>HTML对大小写是不敏感的，所有的浏览器会把大写字符解释为小写字符，因此我们在使用<code>DOM</code>中的模板时，cameCase(驼峰命名法)的<code>props</code>名需要使用其等价的 <code>kebab-case</code> (短横线分隔命名) 命代替</strong>。
<strong>即： <code>&lt;child :aB=&quot;test&quot;&gt;&lt;/child&gt;</code>需要写成<code>&lt;child :a-b=&quot;test&quot;&gt;&lt;/child&gt;</code></strong></p>
<h3 id="722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops">7.2.2 响应式数据props<a class="anchor" href="#722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops">§</a></h3>
<p>刚才说到分析<code>props</code>需要两个过程，前面已经针对父组件对<code>props</code>的处理做了描述，而对于子组件而言，我们是通过<code>props</code>选项去接收父组件传递的值。我们再看看子组件对<code>props</code>的处理：</p>
<p>子组件处理<code>props</code>的过程，是发生在父组件<code>_update</code>阶段，这个阶段是<code>Vnode</code>生成真实节点的过程，期间会遇到子<code>Vnode</code>,这时会调用<code>createComponent</code>去实例化子组件。而实例化子组件的过程又回到了<code>_init</code>初始化，此时又会经历选项的合并，针对<code>props</code>选项，最终会统一成<code>{props: { test: { type: null }}}</code>的写法。接着会调用<code>initProps</code>, <code>initProps</code>做的事情，简单概括一句话就是，将组件的<code>props</code>数据设置为响应式数据。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initProps</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> propsOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> propsData <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">propsData</span> <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token function-variable function">loop</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ···
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>cb<span class="token punctuation">)</span>；
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">"_props"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 遍历props，执行loop设置为响应式数据。</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token function">loop</span><span class="token punctuation">(</span> key <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>其中<code>proxy(vm, &quot;_props&quot;, key);</code>为<code>props</code>做了一层代理，用户通过<code>vm.XXX</code>可以代理访问到<code>vm._props</code>上的值。针对<code>defineReactive</code>,本质上是利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行重写，具体的原理可以参考数据代理章节的内容，在这小节后半段也会有一个基本的实现。</p>
<h2 id="73-initmethods">7.3 initMethods<a class="anchor" href="#73-initmethods">§</a></h2>
<p><code>initMethod</code>方法和这一节介绍的响应式没有任何的关系，他的实现也相对简单，主要是保证<code>methods</code>方法定义必须是函数，且命名不能和<code>props</code>重复，最终会将定义的方法都挂载到根实例上。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initMethods</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> methods</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// method必须为函数形式</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has type \""</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\" in the component definition. "</span> <span class="token operator">+</span>
            <span class="token string">"Did you reference the function correctly?"</span><span class="token punctuation">,</span>
            vm
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// methods方法名不能和props重复</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has already been defined as a prop."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            vm
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//  不能以_ or $.这些Vue保留标志开头</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" conflicts with an existing Vue instance method. "</span> <span class="token operator">+</span>
            <span class="token string">"Avoid defining component methods that start with _ or $."</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 直接挂载到实例的属性上,可以通过vm[method]访问。</span>
      vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'function'</span> <span class="token operator">?</span> noop <span class="token operator">:</span> <span class="token function">bind</span><span class="token punctuation">(</span>methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<h2 id="74-initdata">7.4 initData<a class="anchor" href="#74-initdata">§</a></h2>
<p><code>data</code>在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以<code>initData</code>方法会先执行拿到组件的<code>data</code>数据，并且会对对象每个属性的命名进行校验，保证不能和<code>props，methods</code>重复。最后的核心方法是<code>observe</code>,<code>observe</code>方法是将<strong>数据对象标记为响应式对象</strong>，并对对象的每个属性进行响应式处理。与此同时，和<code>props</code>的代理处理方式一样，<code>proxy</code>会对<code>data</code>做一层代理，直接通过<code>vm.XXX</code>可以代理访问到<code>vm._data</code>上挂载的对象属性。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>
  <span class="token comment">// 根实例时，data是一个对象，子组件的data是一个函数，其中getData会调用函数返回data对象</span>
  data <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">_data</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">'function'</span><span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> keys <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> methods <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
      <span class="token comment">// 命名不能和方法重复</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>methods<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has already been defined as a data property."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 命名不能和props重复</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"The data property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already declared as a prop. "</span> <span class="token operator">+</span> <span class="token string">"Use prop default value instead."</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 数据代理，用户可直接通过vm实例返回data数据</span>
      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">"_data"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// observe data</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>最后讲讲<code>observe</code>,<code>observe</code>具体的行为是将数据对象添加一个不可枚举的属性<code>__ob__</code>，标志对象是一个响应式对象，并且拿到每个对象的属性值，重写<code>getter,setter</code>方法，使得每个属性值都是响应式数据。详细的代码我们后面分析。</strong></p>
<h2 id="75-initcomputed">7.5 initComputed<a class="anchor" href="#75-initcomputed">§</a></h2>
<p>和上面的分析方法一样，<code>initComputed</code>是<code>computed</code>数据的初始化,不同之处在于以下几点：</p>
<ol>
<li><code>computed</code>可以是对象，也可以是函数，但是对象必须有<code>getter</code>方法,因此如果<code>computed</code>中的属性值是对象时需要进行验证。</li>
<li>针对<code>computed</code>的每个属性，要创建一个监听的依赖，也就是实例化一个<code>watcher</code>,<code>watcher</code>的定义，可以暂时理解为数据使用的依赖本身，一个<code>watcher</code>实例代表多了一个需要被监听的数据依赖。</li>
</ol>
<p>除了不同点，<code>initComputed</code>也会将每个属性设置成响应式的数据，同样的，也会对<code>computed</code>的命名做检测，防止与<code>props,data</code>冲突。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initComputed</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> computed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> userDef <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> getter <span class="token operator">=</span> <span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> userDef <span class="token operator">:</span> userDef<span class="token punctuation">.</span><span class="token property-access">get</span><span class="token punctuation">;</span>
      <span class="token comment">// computed属性为对象时，要保证有getter方法</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>getter <span class="token operator">==</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Getter is missing for computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\"."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSSR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建computed watcher</span>
        watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span>getter <span class="token operator">||</span> noop<span class="token punctuation">,</span>noop<span class="token punctuation">,</span>computedWatcherOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置为响应式数据</span>
        <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不能和props，data命名冲突</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">.</span><span class="token property-access">$data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"The computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already defined in data."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">&amp;&amp;</span> key <span class="token keyword">in</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"The computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already defined as a prop."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>显然<code>Vue</code>提供了很多种数据供开发者使用，但是分析完后发现每个处理的核心都是将数据转化成响应式数据，有了响应式数据，如何构建一个响应式系统呢？前面提到的<code>watcher</code>又是什么东西？构建响应式系统还需要其他的东西吗？接下来我们尝试着去实现一个极简风的响应式系统。</p>
<h2 id="76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">7.6 极简风的响应式系统<a class="anchor" href="#76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">§</a></h2>
<p><code>Vue</code>的响应式系统构建是比较复杂的，直接进入源码分析构建的每一个流程会让理解变得困难，因此我觉得在尽可能保留源码的设计逻辑下,用最小的代码构建一个最基础的响应式系统是有必要的。对<code>Dep,Watcher,Observer</code>概念的初步认识，也有助于下一篇对响应式系统设计细节的分析。</p>
<h3 id="761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA">7.6.1 框架搭建<a class="anchor" href="#761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA">§</a></h3>
<p>我们以<code>MyVue</code>作为类响应式框架，框架的搭建不做赘述。我们模拟<code>Vue</code>源码的实现思路，实例化<code>MyVue</code>时会传递一个选项配置，精简的代码只有一个<code>id</code>挂载元素和一个数据对象<code>data</code>。模拟源码的思路，我们在实例化时会先进行数据的初始化，这一步就是响应式的构建，我们稍后分析。数据初始化后开始进行真实<code>DOM</code>的挂载。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyVue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    test<span class="token operator">:</span> <span class="token number">12</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// myVue.js</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">global</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span> <span class="token operator">=</span> options<span class="token punctuation">;</span>
        <span class="token comment">// 数据的初始化</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">initData</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> el <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>
        <span class="token comment">// 实例的挂载</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">}</span>
      <span class="token function">$mount</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token dom variable">window</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer">7.6.2 设置响应式对象 - Observer<a class="anchor" href="#762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer">§</a></h3>
<p>首先引入一个类<code>Observer</code>,这个类的目的是将数据变成响应式对象，利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行改写。在数据读取<code>getter</code>阶段我们会进行<strong>依赖的收集</strong>，在数据的修改<code>setter</code>阶段，我们会进行<strong>依赖的更新</strong>(这两个概念的介绍放在后面)。因此在数据初始化阶段，我们会利用<code>Observer</code>这个类将数据对象修改为相应式对象，而这是所有流程的基础。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>
  <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>
    <span class="token comment">// 将数据重置getter，setter方法</span>
    <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Observer类的定义</span>
<span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实例化时执行walk方法对每个数据属性重写getter，setter方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">walk</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> keys <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Object.defineProperty的处理逻辑</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher">7.6.3 依赖本身 - Watcher<a class="anchor" href="#763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher">§</a></h3>
<p>我们可以这样理解，一个<code>Watcher</code>实例就是一个依赖，数据不管是在渲染模板时使用还是在用户计算时使用，都可以算做一个需要监听的依赖，<code>watcher</code>中记录着这个依赖监听的状态，以及如何更新操作的方法。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 监听的依赖</span>
<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span> isRenderWatcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>
    <span class="token comment">// Watcher.prototype.get的调用会进行状态的更新。</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>那么哪个时间点会实例化<code>watcher</code>并更新数据状态呢？显然在渲染数据到真实<code>DOM</code>时可以创建<code>watcher</code>。<code>$mount</code>流程前面章节介绍过，会经历模板生成<code>render</code>函数和<code>render</code>函数渲染真实<code>DOM</code>的过程。我们对代码做了精简，<code>updateView</code>浓缩了这一过程。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>
  <span class="token function">$mount</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 直接改写innerHTML</span>
    <span class="token keyword">const</span> <span class="token function-variable function">updateView</span> <span class="token operator">=</span> <span class="token parameter">_</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> innerHtml <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">innerHTML</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> key <span class="token operator">=</span> innerHtml<span class="token punctuation">.</span><span class="token method function property-access">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">{(\w+)}</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 创建一个渲染的依赖。</span>
    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>updateView<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep">7.6.4 依赖管理 - Dep<a class="anchor" href="#764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep">§</a></h3>
<p><code>watcher</code>如果理解为每个数据需要监听的依赖，那么<code>Dep</code> 可以理解为对依赖的一种管理。数据可以在渲染中使用，也可以在计算属性中使用。相应的每个数据对应的<code>watcher</code>也有很多。而我们在更新数据时，如何通知到数据相关的每一个依赖，这就需要<code>Dep</code>进行通知管理了。并且浏览器同一时间只能更新一个<code>watcher</code>,所以也需要一个属性去记录当前更新的<code>watcher</code>。而<code>Dep</code>这个类只需要做两件事情，将依赖进行收集，派发依赖进行更新。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">let</span> uid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">=</span> uid<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 依赖收集</span>
  <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Dep.target是当前的watcher,将当前的依赖推到subs中</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 派发更新</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token comment">// 遍历dep中的依赖，对每个依赖执行更新操作</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive">7.6.5 依赖管理过程 - defineReactive<a class="anchor" href="#765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive">§</a></h3>
<p>我们看看数据拦截的过程。前面的<code>Observer</code>实例化最终会调用<code>defineReactive</code>重写<code>getter,setter</code>方法。这个方法开始会实例化一个<code>Dep</code>,也就是创建一个数据的依赖管理。在重写的<code>getter</code>方法中会进行依赖的收集，也就是调用<code>dep.depend</code>的方法。在<code>setter</code>阶段，比较两个数不同后，会调用依赖的派发更新。即<code>dep.notify</code></p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">defineReactive</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> property <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span><span class="token property-access">configurable</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 做依赖的收集</span>
      <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword control-flow">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>nval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>nval <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword control-flow">return</span>
      <span class="token comment">// 派发更新</span>
      val <span class="token operator">=</span> nval
      dep<span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>回过头来看<code>watcher</code>,实例化<code>watcher</code>时会将<code>Dep.target</code>设置为当前的<code>watcher</code>,执行完状态更新函数之后，再将<code>Dep.target</code>置空。这样在收集依赖时只要将<code>Dep.target</code>当前的<code>watcher push</code>到<code>Dep</code>的<code>subs</code>数组即可。而在派发更新阶段也只需要重新更新状态即可。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span> isRenderWatcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>
    <span class="token comment">// Watcher.prototype.get的调用会进行状态的更新。</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前执行的watcher</span>
    <span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="766-%E7%BB%93%E6%9E%9C">7.6.6 结果<a class="anchor" href="#766-%E7%BB%93%E6%9E%9C">§</a></h3>
<p>一个极简的响应式系统搭建完成。在精简代码的同时，保持了源码设计的思想和逻辑。有了这一步的基础，接下来深入分析源码中每个环节的实现细节会更加简单。</p>
<h2 id="77-%E5%B0%8F%E7%BB%93">7.7 小结<a class="anchor" href="#77-%E5%B0%8F%E7%BB%93">§</a></h2>
<p>这一节内容，我们正式进入响应式系统的介绍，前面在数据代理章节，我们学过<code>Object.defineProperty</code>,这是一个用来进行数据拦截的方法，而响应式系统构建的基础就是数据的拦截。我们先介绍了<code>Vue</code>内部在初始化数据的过程，最终得出的结论是，不管是<code>data,computed</code>,还是其他的用户定义数据，最终都是调用<code>Object.defineProperty</code>进行数据拦截。而文章的最后，我们在保留源码设计思想和逻辑的前提下，构建出了一个简化版的响应式系统。完整的功能有助于我们下一节对源码具体实现细节的分析和思考。</p></article></div><aside class="main_toc_container nav_link_container"><div class="main_toc"><nav class="toc"><ol><li><a href="#71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96">7.1 数据初始化</a></li><li><a href="#72-initprops">7.2 initProps</a><ol><li><a href="#721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">7.2.1 props的命名规范</a></li><li><a href="#722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops">7.2.2 响应式数据props</a></li></ol></li><li><a href="#73-initmethods">7.3 initMethods</a></li><li><a href="#74-initdata">7.4 initData</a></li><li><a href="#75-initcomputed">7.5 initComputed</a></li><li><a href="#76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">7.6 极简风的响应式系统</a><ol><li><a href="#761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA">7.6.1 框架搭建</a></li><li><a href="#762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer">7.6.2 设置响应式对象 - Observer</a></li><li><a href="#763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher">7.6.3 依赖本身 - Watcher</a></li><li><a href="#764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep">7.6.4 依赖管理 - Dep</a></li><li><a href="#765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive">7.6.5 依赖管理过程 - defineReactive</a></li><li><a href="#766-%E7%BB%93%E6%9E%9C">7.6.6 结果</a></li></ol></li><li><a href="#77-%E5%B0%8F%E7%BB%93">7.7 小结</a></li></ol></nav></div></aside></section><footer>Powered by&amp;nbsp;<a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><div class="tools flex_center hide_on_mobile"><a class="czs-angle-up-l button" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-angle-up-l.svg&quot;)"></a></div><script src="https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/In-depth-analysis-of-Vue/index.js"></script></body></html>