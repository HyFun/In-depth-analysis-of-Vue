import projectConfig from '/In-depth-analysis-of-Vue/pagic.config.js';
export default {
    'prev': undefined,
    'next': undefined,
    config: { "root": "/", ...projectConfig, branch: 'pagic' },
    'pagePath': "src/深入响应式系统构建-上.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "src/深入响应式系统构建-上.html",
    'title': undefined,
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>从这一小节开始，正式进入<code>Vue</code>源码的核心，也是难点之一，响应式系统的构建。这一节将作为分析响应式构建过程源码的入门，主要分为两大块,第一块是针对响应式数据<code>props,methods,data,computed,wather</code>初始化过程的分析，另一块则是在保留源码设计理念的前提下，尝试手动构建一个基础的响应式系统。有了这两个基础内容的铺垫，下一篇进行源码具体细节的分析会更加得心应手。</p>\n</blockquote>\n<h2 id="71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96">7.1 数据初始化<a class="anchor" href="#71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96">§</a></h2>\n<p>回顾一下之前的内容，我们对<code>Vue</code>源码的分析是从初始化开始，初始化<code>_init</code>会执行一系列的过程，这个过程包括了配置选项的合并，数据的监测代理，最后才是实例的挂载。而在实例挂载前还有意忽略了一个重要的过程，<strong>数据的初始化</strong>(即<code>initState(vm)</code>)。<code>initState</code>的过程，是对数据进行响应式设计的过程，过程会针对<code>props,methods,data,computed</code>和<code>watch</code>做数据的初始化处理，并将他们转换为响应式对象，接下来我们会逐步分析每一个过程。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  vm<span class="token punctuation">.</span><span class="token property-access">_watchers</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">;</span>\n  <span class="token comment">// 初始化props</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化methods</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化data</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 如果没有定义data，则创建一个空对象，并设置为响应式</span>\n    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">_data</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化computed</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">computed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">computed</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化watch</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">watch</span> <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span><span class="token property-access">watch</span> <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">watch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="72-initprops">7.2 initProps<a class="anchor" href="#72-initprops">§</a></h2>\n<p>简单回顾一下<code>props</code>的用法，父组件通过属性的形式将数据传递给子组件，子组件通过<code>props</code>属性接收父组件传递的值。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 父组件</span>\n<span class="token operator">&lt;</span>child <span class="token operator">:</span>test<span class="token operator">=</span><span class="token string">"test"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n      test<span class="token operator">:</span> <span class="token string">\'child\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 子组件</span>\n<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">component</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token string">\'&lt;div>{{test}}&lt;/div>\'</span><span class="token punctuation">,</span>\n  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'test\'</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>因此分析<code>props</code>需要分析父组件和子组件的两个过程，我们先看父组件对传递值的处理。按照以往文章介绍的那样，父组件优先进行模板编译得到一个<code>render</code>函数，在解析过程中遇到子组件的属性，<code>:test=test</code>会被解析成<code>{ attrs: {test： test}}</code>并作为子组件的<code>render</code>函数存在，如下所示:</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token method function property-access">_c</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"test"</span><span class="token operator">:</span>test<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<p><code>render</code>解析<code>Vnode</code>的过程遇到<code>child</code>这个子占位符节点，因此会进入创建子组件<code>Vnode</code>的过程，创建子<code>Vnode</code>过程是调用<code>createComponent</code>,这个阶段我们在组件章节有分析过，在组件的高级用法也有分析过，最终会调用<code>new Vnode</code>去创建子<code>Vnode</code>。而对于<code>props</code>的处理，<code>extractPropsFromVNodeData</code>会对<code>attrs</code>属性进行规范校验后，最后会把校验后的结果以<code>propsData</code>属性的形式传入<code>Vnode</code>构造器中。总结来说，<code>props</code>传递给占位符组件的写法，会以<code>propsData</code>的形式作为子组件<code>Vnode</code>的属性存在。下面会分析具体的细节。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 创建子组件过程</span>\n<span class="token keyword">function</span> <span class="token function">createComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// props校验</span>\n  <span class="token keyword">var</span> propsData <span class="token operator">=</span> <span class="token function">extractPropsFromVNodeData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  ···\n  <span class="token comment">// 创建子组件vnode</span>\n  <span class="token keyword">var</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>\n    <span class="token punctuation">(</span><span class="token string">"vue-component-"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">cid</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>name <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    data<span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>\n    <span class="token punctuation">{</span> <span class="token maybe-class-name">Ctor</span><span class="token operator">:</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> propsData<span class="token operator">:</span> propsData<span class="token punctuation">,</span> listeners<span class="token operator">:</span> listeners<span class="token punctuation">,</span> tag<span class="token operator">:</span> tag<span class="token punctuation">,</span> children<span class="token operator">:</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    asyncFactory\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">7.2.1 props的命名规范<a class="anchor" href="#721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">§</a></h3>\n<p>先看检测<code>props</code>规范性的过程。**<code>props</code>编译后的结果有两种，其中<code>attrs</code>前面分析过，是编译生成<code>render</code>函数针对属性的处理，而<code>props</code>是针对用户自写<code>render</code>函数的属性值。**因此需要同时对这两种方式进行校验。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">extractPropsFromVNodeData</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span>tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Ctor为子类构造器</span>\n  ···\n  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token comment">// 子组件props选项</span>\n  <span class="token keyword">var</span> propOptions <span class="token operator">=</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n  <span class="token comment">// data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数</span>\n  <span class="token keyword">var</span> attrs <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> props <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isDef</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> propOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// aB 形式转成 a-b</span>\n      <span class="token keyword">var</span> altKey <span class="token operator">=</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">{</span>\n          <span class="token keyword">var</span> keyInLowerCase <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>\n            key <span class="token operator">!==</span> keyInLowerCase <span class="token operator">&amp;&amp;</span>\n            attrs <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> keyInLowerCase<span class="token punctuation">)</span>\n          <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 警告</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>重点说一下源码在这一部分的处理，<strong>HTML对大小写是不敏感的，所有的浏览器会把大写字符解释为小写字符，因此我们在使用<code>DOM</code>中的模板时，cameCase(驼峰命名法)的<code>props</code>名需要使用其等价的 <code>kebab-case</code> (短横线分隔命名) 命代替</strong>。\n<strong>即： <code>&lt;child :aB=&quot;test&quot;&gt;&lt;/child&gt;</code>需要写成<code>&lt;child :a-b=&quot;test&quot;&gt;&lt;/child&gt;</code></strong></p>\n<h3 id="722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops">7.2.2 响应式数据props<a class="anchor" href="#722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops">§</a></h3>\n<p>刚才说到分析<code>props</code>需要两个过程，前面已经针对父组件对<code>props</code>的处理做了描述，而对于子组件而言，我们是通过<code>props</code>选项去接收父组件传递的值。我们再看看子组件对<code>props</code>的处理：</p>\n<p>子组件处理<code>props</code>的过程，是发生在父组件<code>_update</code>阶段，这个阶段是<code>Vnode</code>生成真实节点的过程，期间会遇到子<code>Vnode</code>,这时会调用<code>createComponent</code>去实例化子组件。而实例化子组件的过程又回到了<code>_init</code>初始化，此时又会经历选项的合并，针对<code>props</code>选项，最终会统一成<code>{props: { test: { type: null }}}</code>的写法。接着会调用<code>initProps</code>, <code>initProps</code>做的事情，简单概括一句话就是，将组件的<code>props</code>数据设置为响应式数据。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initProps</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> propsOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> propsData <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">propsData</span> <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> <span class="token function-variable function">loop</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    ···\n    <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>cb<span class="token punctuation">)</span>；\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">"_props"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 遍历props，执行loop设置为响应式数据。</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token function">loop</span><span class="token punctuation">(</span> key <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>其中<code>proxy(vm, &quot;_props&quot;, key);</code>为<code>props</code>做了一层代理，用户通过<code>vm.XXX</code>可以代理访问到<code>vm._props</code>上的值。针对<code>defineReactive</code>,本质上是利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行重写，具体的原理可以参考数据代理章节的内容，在这小节后半段也会有一个基本的实现。</p>\n<h2 id="73-initmethods">7.3 initMethods<a class="anchor" href="#73-initmethods">§</a></h2>\n<p><code>initMethod</code>方法和这一节介绍的响应式没有任何的关系，他的实现也相对简单，主要是保证<code>methods</code>方法定义必须是函数，且命名不能和<code>props</code>重复，最终会将定义的方法都挂载到根实例上。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initMethods</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> methods</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">{</span>\n        <span class="token comment">// method必须为函数形式</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">\'function\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has type \""</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\" in the component definition. "</span> <span class="token operator">+</span>\n            <span class="token string">"Did you reference the function correctly?"</span><span class="token punctuation">,</span>\n            vm\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// methods方法名不能和props重复</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token punctuation">(</span><span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has already been defined as a prop."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            vm\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">//  不能以_ or $.这些Vue保留标志开头</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" conflicts with an existing Vue instance method. "</span> <span class="token operator">+</span>\n            <span class="token string">"Avoid defining component methods that start with _ or $."</span>\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 直接挂载到实例的属性上,可以通过vm[method]访问。</span>\n      vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">\'function\'</span> <span class="token operator">?</span> noop <span class="token operator">:</span> <span class="token function">bind</span><span class="token punctuation">(</span>methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<h2 id="74-initdata">7.4 initData<a class="anchor" href="#74-initdata">§</a></h2>\n<p><code>data</code>在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以<code>initData</code>方法会先执行拿到组件的<code>data</code>数据，并且会对对象每个属性的命名进行校验，保证不能和<code>props，methods</code>重复。最后的核心方法是<code>observe</code>,<code>observe</code>方法是将<strong>数据对象标记为响应式对象</strong>，并对对象的每个属性进行响应式处理。与此同时，和<code>props</code>的代理处理方式一样，<code>proxy</code>会对<code>data</code>做一层代理，直接通过<code>vm.XXX</code>可以代理访问到<code>vm._data</code>上挂载的对象属性。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>\n  <span class="token comment">// 根实例时，data是一个对象，子组件的data是一个函数，其中getData会调用函数返回data对象</span>\n  data <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">_data</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">\'function\'</span><span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> keys <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> methods <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">{</span>\n      <span class="token comment">// 命名不能和方法重复</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>methods<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has already been defined as a data property."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 命名不能和props重复</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"The data property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already declared as a prop. "</span> <span class="token operator">+</span> <span class="token string">"Use prop default value instead."</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 数据代理，用户可直接通过vm实例返回data数据</span>\n      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">"_data"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// observe data</span>\n  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><strong>最后讲讲<code>observe</code>,<code>observe</code>具体的行为是将数据对象添加一个不可枚举的属性<code>__ob__</code>，标志对象是一个响应式对象，并且拿到每个对象的属性值，重写<code>getter,setter</code>方法，使得每个属性值都是响应式数据。详细的代码我们后面分析。</strong></p>\n<h2 id="75-initcomputed">7.5 initComputed<a class="anchor" href="#75-initcomputed">§</a></h2>\n<p>和上面的分析方法一样，<code>initComputed</code>是<code>computed</code>数据的初始化,不同之处在于以下几点：</p>\n<ol>\n<li><code>computed</code>可以是对象，也可以是函数，但是对象必须有<code>getter</code>方法,因此如果<code>computed</code>中的属性值是对象时需要进行验证。</li>\n<li>针对<code>computed</code>的每个属性，要创建一个监听的依赖，也就是实例化一个<code>watcher</code>,<code>watcher</code>的定义，可以暂时理解为数据使用的依赖本身，一个<code>watcher</code>实例代表多了一个需要被监听的数据依赖。</li>\n</ol>\n<p>除了不同点，<code>initComputed</code>也会将每个属性设置成响应式的数据，同样的，也会对<code>computed</code>的命名做检测，防止与<code>props,data</code>冲突。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initComputed</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> computed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> userDef <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> getter <span class="token operator">=</span> <span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">\'function\'</span> <span class="token operator">?</span> userDef <span class="token operator">:</span> userDef<span class="token punctuation">.</span><span class="token property-access">get</span><span class="token punctuation">;</span>\n      <span class="token comment">// computed属性为对象时，要保证有getter方法</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>getter <span class="token operator">==</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Getter is missing for computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\"."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSSR<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 创建computed watcher</span>\n        watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span>getter <span class="token operator">||</span> noop<span class="token punctuation">,</span>noop<span class="token punctuation">,</span>computedWatcherOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 设置为响应式数据</span>\n        <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 不能和props，data命名冲突</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">.</span><span class="token property-access">$data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"The computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already defined in data."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">&amp;&amp;</span> key <span class="token keyword">in</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"The computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already defined as a prop."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>显然<code>Vue</code>提供了很多种数据供开发者使用，但是分析完后发现每个处理的核心都是将数据转化成响应式数据，有了响应式数据，如何构建一个响应式系统呢？前面提到的<code>watcher</code>又是什么东西？构建响应式系统还需要其他的东西吗？接下来我们尝试着去实现一个极简风的响应式系统。</p>\n<h2 id="76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">7.6 极简风的响应式系统<a class="anchor" href="#76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">§</a></h2>\n<p><code>Vue</code>的响应式系统构建是比较复杂的，直接进入源码分析构建的每一个流程会让理解变得困难，因此我觉得在尽可能保留源码的设计逻辑下,用最小的代码构建一个最基础的响应式系统是有必要的。对<code>Dep,Watcher,Observer</code>概念的初步认识，也有助于下一篇对响应式系统设计细节的分析。</p>\n<h3 id="761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA">7.6.1 框架搭建<a class="anchor" href="#761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA">§</a></h3>\n<p>我们以<code>MyVue</code>作为类响应式框架，框架的搭建不做赘述。我们模拟<code>Vue</code>源码的实现思路，实例化<code>MyVue</code>时会传递一个选项配置，精简的代码只有一个<code>id</code>挂载元素和一个数据对象<code>data</code>。模拟源码的思路，我们在实例化时会先进行数据的初始化，这一步就是响应式的构建，我们稍后分析。数据初始化后开始进行真实<code>DOM</code>的挂载。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyVue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  id<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  data<span class="token operator">:</span> <span class="token punctuation">{</span>\n    test<span class="token operator">:</span> <span class="token number">12</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// myVue.js</span>\n<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">global</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>\n      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span> <span class="token operator">=</span> options<span class="token punctuation">;</span>\n        <span class="token comment">// 数据的初始化</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">initData</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">let</span> el <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>\n        <span class="token comment">// 实例的挂载</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">}</span>\n      <span class="token function">$mount</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token dom variable">window</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer">7.6.2 设置响应式对象 - Observer<a class="anchor" href="#762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer">§</a></h3>\n<p>首先引入一个类<code>Observer</code>,这个类的目的是将数据变成响应式对象，利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行改写。在数据读取<code>getter</code>阶段我们会进行<strong>依赖的收集</strong>，在数据的修改<code>setter</code>阶段，我们会进行<strong>依赖的更新</strong>(这两个概念的介绍放在后面)。因此在数据初始化阶段，我们会利用<code>Observer</code>这个类将数据对象修改为相应式对象，而这是所有流程的基础。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>\n  <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>\n    <span class="token comment">// 将数据重置getter，setter方法</span>\n    <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// Observer类的定义</span>\n<span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 实例化时执行walk方法对每个数据属性重写getter，setter方法</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">walk</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> keys <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// Object.defineProperty的处理逻辑</span>\n      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher">7.6.3 依赖本身 - Watcher<a class="anchor" href="#763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher">§</a></h3>\n<p>我们可以这样理解，一个<code>Watcher</code>实例就是一个依赖，数据不管是在渲染模板时使用还是在用户计算时使用，都可以算做一个需要监听的依赖，<code>watcher</code>中记录着这个依赖监听的状态，以及如何更新操作的方法。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 监听的依赖</span>\n<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span> isRenderWatcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>\n    <span class="token comment">// Watcher.prototype.get的调用会进行状态的更新。</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>那么哪个时间点会实例化<code>watcher</code>并更新数据状态呢？显然在渲染数据到真实<code>DOM</code>时可以创建<code>watcher</code>。<code>$mount</code>流程前面章节介绍过，会经历模板生成<code>render</code>函数和<code>render</code>函数渲染真实<code>DOM</code>的过程。我们对代码做了精简，<code>updateView</code>浓缩了这一过程。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>\n  <span class="token function">$mount</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 直接改写innerHTML</span>\n    <span class="token keyword">const</span> <span class="token function-variable function">updateView</span> <span class="token operator">=</span> <span class="token parameter">_</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> innerHtml <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">innerHTML</span><span class="token punctuation">;</span>\n      <span class="token keyword">let</span> key <span class="token operator">=</span> innerHtml<span class="token punctuation">.</span><span class="token method function property-access">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">{(\w+)}</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 创建一个渲染的依赖。</span>\n    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>updateView<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep">7.6.4 依赖管理 - Dep<a class="anchor" href="#764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep">§</a></h3>\n<p><code>watcher</code>如果理解为每个数据需要监听的依赖，那么<code>Dep</code> 可以理解为对依赖的一种管理。数据可以在渲染中使用，也可以在计算属性中使用。相应的每个数据对应的<code>watcher</code>也有很多。而我们在更新数据时，如何通知到数据相关的每一个依赖，这就需要<code>Dep</code>进行通知管理了。并且浏览器同一时间只能更新一个<code>watcher</code>,所以也需要一个属性去记录当前更新的<code>watcher</code>。而<code>Dep</code>这个类只需要做两件事情，将依赖进行收集，派发依赖进行更新。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">let</span> uid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">=</span> uid<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 依赖收集</span>\n  <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// Dep.target是当前的watcher,将当前的依赖推到subs中</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 派发更新</span>\n  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      <span class="token comment">// 遍历dep中的依赖，对每个依赖执行更新操作</span>\n      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>\n</code></pre>\n<h3 id="765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive">7.6.5 依赖管理过程 - defineReactive<a class="anchor" href="#765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive">§</a></h3>\n<p>我们看看数据拦截的过程。前面的<code>Observer</code>实例化最终会调用<code>defineReactive</code>重写<code>getter,setter</code>方法。这个方法开始会实例化一个<code>Dep</code>,也就是创建一个数据的依赖管理。在重写的<code>getter</code>方法中会进行依赖的收集，也就是调用<code>dep.depend</code>的方法。在<code>setter</code>阶段，比较两个数不同后，会调用依赖的派发更新。即<code>dep.notify</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">defineReactive</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> property <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n  <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span><span class="token property-access">configurable</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>\n  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 做依赖的收集</span>\n      <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        dep<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">set</span><span class="token punctuation">(</span>nval<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>nval <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword control-flow">return</span>\n      <span class="token comment">// 派发更新</span>\n      val <span class="token operator">=</span> nval\n      dep<span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>回过头来看<code>watcher</code>,实例化<code>watcher</code>时会将<code>Dep.target</code>设置为当前的<code>watcher</code>,执行完状态更新函数之后，再将<code>Dep.target</code>置空。这样在收集依赖时只要将<code>Dep.target</code>当前的<code>watcher push</code>到<code>Dep</code>的<code>subs</code>数组即可。而在派发更新阶段也只需要重新更新状态即可。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span> isRenderWatcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>\n    <span class="token comment">// Watcher.prototype.get的调用会进行状态的更新。</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 当前执行的watcher</span>\n    <span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword">this</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="766-%E7%BB%93%E6%9E%9C">7.6.6 结果<a class="anchor" href="#766-%E7%BB%93%E6%9E%9C">§</a></h3>\n<p>一个极简的响应式系统搭建完成。在精简代码的同时，保持了源码设计的思想和逻辑。有了这一步的基础，接下来深入分析源码中每个环节的实现细节会更加简单。</p>\n<h2 id="77-%E5%B0%8F%E7%BB%93">7.7 小结<a class="anchor" href="#77-%E5%B0%8F%E7%BB%93">§</a></h2>\n<p>这一节内容，我们正式进入响应式系统的介绍，前面在数据代理章节，我们学过<code>Object.defineProperty</code>,这是一个用来进行数据拦截的方法，而响应式系统构建的基础就是数据的拦截。我们先介绍了<code>Vue</code>内部在初始化数据的过程，最终得出的结论是，不管是<code>data,computed</code>,还是其他的用户定义数据，最终都是调用<code>Object.defineProperty</code>进行数据拦截。而文章的最后，我们在保留源码设计思想和逻辑的前提下，构建出了一个简化版的响应式系统。完整的功能有助于我们下一节对源码具体实现细节的分析和思考。</p>'
        } }),
    'head': React.createElement(React.Fragment, null,
        React.createElement("link", { href: "src/assets/favicon.ico", rel: "icon" })),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/In-depth-analysis-of-Vue/index.js", type: "module" })),
    'footer': React.createElement("footer", null,
        "Powered by\u00A0",
        React.createElement("a", { href: "https://github.com/xcatliu/pagic", target: "_blank" }, "Pagic")),
    'contentTitle': undefined,
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>从这一小节开始，正式进入<code>Vue</code>源码的核心，也是难点之一，响应式系统的构建。这一节将作为分析响应式构建过程源码的入门，主要分为两大块,第一块是针对响应式数据<code>props,methods,data,computed,wather</code>初始化过程的分析，另一块则是在保留源码设计理念的前提下，尝试手动构建一个基础的响应式系统。有了这两个基础内容的铺垫，下一篇进行源码具体细节的分析会更加得心应手。</p>\n</blockquote>\n<h2 id="71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96">7.1 数据初始化<a class="anchor" href="#71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96">§</a></h2>\n<p>回顾一下之前的内容，我们对<code>Vue</code>源码的分析是从初始化开始，初始化<code>_init</code>会执行一系列的过程，这个过程包括了配置选项的合并，数据的监测代理，最后才是实例的挂载。而在实例挂载前还有意忽略了一个重要的过程，<strong>数据的初始化</strong>(即<code>initState(vm)</code>)。<code>initState</code>的过程，是对数据进行响应式设计的过程，过程会针对<code>props,methods,data,computed</code>和<code>watch</code>做数据的初始化处理，并将他们转换为响应式对象，接下来我们会逐步分析每一个过程。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  vm<span class="token punctuation">.</span><span class="token property-access">_watchers</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">;</span>\n  <span class="token comment">// 初始化props</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化methods</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化data</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 如果没有定义data，则创建一个空对象，并设置为响应式</span>\n    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">_data</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化computed</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">computed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">computed</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n  <span class="token comment">// 初始化watch</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span><span class="token property-access">watch</span> <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span><span class="token property-access">watch</span> <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span><span class="token property-access">watch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="72-initprops">7.2 initProps<a class="anchor" href="#72-initprops">§</a></h2>\n<p>简单回顾一下<code>props</code>的用法，父组件通过属性的形式将数据传递给子组件，子组件通过<code>props</code>属性接收父组件传递的值。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 父组件</span>\n<span class="token operator">&lt;</span>child <span class="token operator">:</span>test<span class="token operator">=</span><span class="token string">"test"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span>\n<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>\n      test<span class="token operator">:</span> <span class="token string">\'child\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 子组件</span>\n<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">component</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token string">\'&lt;div>{{test}}&lt;/div>\'</span><span class="token punctuation">,</span>\n  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'test\'</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>因此分析<code>props</code>需要分析父组件和子组件的两个过程，我们先看父组件对传递值的处理。按照以往文章介绍的那样，父组件优先进行模板编译得到一个<code>render</code>函数，在解析过程中遇到子组件的属性，<code>:test=test</code>会被解析成<code>{ attrs: {test： test}}</code>并作为子组件的<code>render</code>函数存在，如下所示:</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token method function property-access">_c</span><span class="token punctuation">(</span><span class="token string">\'child\'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"test"</span><span class="token operator">:</span>test<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre>\n<p><code>render</code>解析<code>Vnode</code>的过程遇到<code>child</code>这个子占位符节点，因此会进入创建子组件<code>Vnode</code>的过程，创建子<code>Vnode</code>过程是调用<code>createComponent</code>,这个阶段我们在组件章节有分析过，在组件的高级用法也有分析过，最终会调用<code>new Vnode</code>去创建子<code>Vnode</code>。而对于<code>props</code>的处理，<code>extractPropsFromVNodeData</code>会对<code>attrs</code>属性进行规范校验后，最后会把校验后的结果以<code>propsData</code>属性的形式传入<code>Vnode</code>构造器中。总结来说，<code>props</code>传递给占位符组件的写法，会以<code>propsData</code>的形式作为子组件<code>Vnode</code>的属性存在。下面会分析具体的细节。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 创建子组件过程</span>\n<span class="token keyword">function</span> <span class="token function">createComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// props校验</span>\n  <span class="token keyword">var</span> propsData <span class="token operator">=</span> <span class="token function">extractPropsFromVNodeData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  ···\n  <span class="token comment">// 创建子组件vnode</span>\n  <span class="token keyword">var</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>\n    <span class="token punctuation">(</span><span class="token string">"vue-component-"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">cid</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>name <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    data<span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>\n    <span class="token punctuation">{</span> <span class="token maybe-class-name">Ctor</span><span class="token operator">:</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> propsData<span class="token operator">:</span> propsData<span class="token punctuation">,</span> listeners<span class="token operator">:</span> listeners<span class="token punctuation">,</span> tag<span class="token operator">:</span> tag<span class="token punctuation">,</span> children<span class="token operator">:</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    asyncFactory\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">7.2.1 props的命名规范<a class="anchor" href="#721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">§</a></h3>\n<p>先看检测<code>props</code>规范性的过程。**<code>props</code>编译后的结果有两种，其中<code>attrs</code>前面分析过，是编译生成<code>render</code>函数针对属性的处理，而<code>props</code>是针对用户自写<code>render</code>函数的属性值。**因此需要同时对这两种方式进行校验。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">extractPropsFromVNodeData</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span>tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Ctor为子类构造器</span>\n  ···\n  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token comment">// 子组件props选项</span>\n  <span class="token keyword">var</span> propOptions <span class="token operator">=</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n  <span class="token comment">// data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数</span>\n  <span class="token keyword">var</span> attrs <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> props <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isDef</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> propOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// aB 形式转成 a-b</span>\n      <span class="token keyword">var</span> altKey <span class="token operator">=</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">{</span>\n          <span class="token keyword">var</span> keyInLowerCase <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>\n            key <span class="token operator">!==</span> keyInLowerCase <span class="token operator">&amp;&amp;</span>\n            attrs <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> keyInLowerCase<span class="token punctuation">)</span>\n          <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 警告</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>重点说一下源码在这一部分的处理，<strong>HTML对大小写是不敏感的，所有的浏览器会把大写字符解释为小写字符，因此我们在使用<code>DOM</code>中的模板时，cameCase(驼峰命名法)的<code>props</code>名需要使用其等价的 <code>kebab-case</code> (短横线分隔命名) 命代替</strong>。\n<strong>即： <code>&lt;child :aB=&quot;test&quot;&gt;&lt;/child&gt;</code>需要写成<code>&lt;child :a-b=&quot;test&quot;&gt;&lt;/child&gt;</code></strong></p>\n<h3 id="722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops">7.2.2 响应式数据props<a class="anchor" href="#722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops">§</a></h3>\n<p>刚才说到分析<code>props</code>需要两个过程，前面已经针对父组件对<code>props</code>的处理做了描述，而对于子组件而言，我们是通过<code>props</code>选项去接收父组件传递的值。我们再看看子组件对<code>props</code>的处理：</p>\n<p>子组件处理<code>props</code>的过程，是发生在父组件<code>_update</code>阶段，这个阶段是<code>Vnode</code>生成真实节点的过程，期间会遇到子<code>Vnode</code>,这时会调用<code>createComponent</code>去实例化子组件。而实例化子组件的过程又回到了<code>_init</code>初始化，此时又会经历选项的合并，针对<code>props</code>选项，最终会统一成<code>{props: { test: { type: null }}}</code>的写法。接着会调用<code>initProps</code>, <code>initProps</code>做的事情，简单概括一句话就是，将组件的<code>props</code>数据设置为响应式数据。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initProps</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> propsOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> propsData <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">propsData</span> <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> <span class="token function-variable function">loop</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    ···\n    <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>cb<span class="token punctuation">)</span>；\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">"_props"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 遍历props，执行loop设置为响应式数据。</span>\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token function">loop</span><span class="token punctuation">(</span> key <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>其中<code>proxy(vm, &quot;_props&quot;, key);</code>为<code>props</code>做了一层代理，用户通过<code>vm.XXX</code>可以代理访问到<code>vm._props</code>上的值。针对<code>defineReactive</code>,本质上是利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行重写，具体的原理可以参考数据代理章节的内容，在这小节后半段也会有一个基本的实现。</p>\n<h2 id="73-initmethods">7.3 initMethods<a class="anchor" href="#73-initmethods">§</a></h2>\n<p><code>initMethod</code>方法和这一节介绍的响应式没有任何的关系，他的实现也相对简单，主要是保证<code>methods</code>方法定义必须是函数，且命名不能和<code>props</code>重复，最终会将定义的方法都挂载到根实例上。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initMethods</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> methods</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">{</span>\n        <span class="token comment">// method必须为函数形式</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">\'function\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has type \""</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\" in the component definition. "</span> <span class="token operator">+</span>\n            <span class="token string">"Did you reference the function correctly?"</span><span class="token punctuation">,</span>\n            vm\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// methods方法名不能和props重复</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token punctuation">(</span><span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has already been defined as a prop."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            vm\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">//  不能以_ or $.这些Vue保留标志开头</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span>\n            <span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" conflicts with an existing Vue instance method. "</span> <span class="token operator">+</span>\n            <span class="token string">"Avoid defining component methods that start with _ or $."</span>\n          <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 直接挂载到实例的属性上,可以通过vm[method]访问。</span>\n      vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">\'function\'</span> <span class="token operator">?</span> noop <span class="token operator">:</span> <span class="token function">bind</span><span class="token punctuation">(</span>methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre>\n<h2 id="74-initdata">7.4 initData<a class="anchor" href="#74-initdata">§</a></h2>\n<p><code>data</code>在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以<code>initData</code>方法会先执行拿到组件的<code>data</code>数据，并且会对对象每个属性的命名进行校验，保证不能和<code>props，methods</code>重复。最后的核心方法是<code>observe</code>,<code>observe</code>方法是将<strong>数据对象标记为响应式对象</strong>，并对对象的每个属性进行响应式处理。与此同时，和<code>props</code>的代理处理方式一样，<code>proxy</code>会对<code>data</code>做一层代理，直接通过<code>vm.XXX</code>可以代理访问到<code>vm._data</code>上挂载的对象属性。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>\n  <span class="token comment">// 根实例时，data是一个对象，子组件的data是一个函数，其中getData会调用函数返回data对象</span>\n  data <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">_data</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">\'function\'</span><span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> keys <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> methods <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">methods</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">{</span>\n      <span class="token comment">// 命名不能和方法重复</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>methods<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Method \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" has already been defined as a data property."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 命名不能和props重复</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"The data property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already declared as a prop. "</span> <span class="token operator">+</span> <span class="token string">"Use prop default value instead."</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 数据代理，用户可直接通过vm实例返回data数据</span>\n      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">"_data"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// observe data</span>\n  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><strong>最后讲讲<code>observe</code>,<code>observe</code>具体的行为是将数据对象添加一个不可枚举的属性<code>__ob__</code>，标志对象是一个响应式对象，并且拿到每个对象的属性值，重写<code>getter,setter</code>方法，使得每个属性值都是响应式数据。详细的代码我们后面分析。</strong></p>\n<h2 id="75-initcomputed">7.5 initComputed<a class="anchor" href="#75-initcomputed">§</a></h2>\n<p>和上面的分析方法一样，<code>initComputed</code>是<code>computed</code>数据的初始化,不同之处在于以下几点：</p>\n<ol>\n<li><code>computed</code>可以是对象，也可以是函数，但是对象必须有<code>getter</code>方法,因此如果<code>computed</code>中的属性值是对象时需要进行验证。</li>\n<li>针对<code>computed</code>的每个属性，要创建一个监听的依赖，也就是实例化一个<code>watcher</code>,<code>watcher</code>的定义，可以暂时理解为数据使用的依赖本身，一个<code>watcher</code>实例代表多了一个需要被监听的数据依赖。</li>\n</ol>\n<p>除了不同点，<code>initComputed</code>也会将每个属性设置成响应式的数据，同样的，也会对<code>computed</code>的命名做检测，防止与<code>props,data</code>冲突。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initComputed</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> computed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  ···\n  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> userDef <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token keyword">var</span> getter <span class="token operator">=</span> <span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">\'function\'</span> <span class="token operator">?</span> userDef <span class="token operator">:</span> userDef<span class="token punctuation">.</span><span class="token property-access">get</span><span class="token punctuation">;</span>\n      <span class="token comment">// computed属性为对象时，要保证有getter方法</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>getter <span class="token operator">==</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Getter is missing for computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\"."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSSR<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 创建computed watcher</span>\n        watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span>getter <span class="token operator">||</span> noop<span class="token punctuation">,</span>noop<span class="token punctuation">,</span>computedWatcherOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 设置为响应式数据</span>\n        <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 不能和props，data命名冲突</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">.</span><span class="token property-access">$data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"The computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already defined in data."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">&amp;&amp;</span> key <span class="token keyword">in</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"The computed property \""</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"\" is already defined as a prop."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>显然<code>Vue</code>提供了很多种数据供开发者使用，但是分析完后发现每个处理的核心都是将数据转化成响应式数据，有了响应式数据，如何构建一个响应式系统呢？前面提到的<code>watcher</code>又是什么东西？构建响应式系统还需要其他的东西吗？接下来我们尝试着去实现一个极简风的响应式系统。</p>\n<h2 id="76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">7.6 极简风的响应式系统<a class="anchor" href="#76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">§</a></h2>\n<p><code>Vue</code>的响应式系统构建是比较复杂的，直接进入源码分析构建的每一个流程会让理解变得困难，因此我觉得在尽可能保留源码的设计逻辑下,用最小的代码构建一个最基础的响应式系统是有必要的。对<code>Dep,Watcher,Observer</code>概念的初步认识，也有助于下一篇对响应式系统设计细节的分析。</p>\n<h3 id="761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA">7.6.1 框架搭建<a class="anchor" href="#761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA">§</a></h3>\n<p>我们以<code>MyVue</code>作为类响应式框架，框架的搭建不做赘述。我们模拟<code>Vue</code>源码的实现思路，实例化<code>MyVue</code>时会传递一个选项配置，精简的代码只有一个<code>id</code>挂载元素和一个数据对象<code>data</code>。模拟源码的思路，我们在实例化时会先进行数据的初始化，这一步就是响应式的构建，我们稍后分析。数据初始化后开始进行真实<code>DOM</code>的挂载。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyVue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  id<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  data<span class="token operator">:</span> <span class="token punctuation">{</span>\n    test<span class="token operator">:</span> <span class="token number">12</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// myVue.js</span>\n<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">global</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>\n      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span> <span class="token operator">=</span> options<span class="token punctuation">;</span>\n        <span class="token comment">// 数据的初始化</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">initData</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">let</span> el <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>\n        <span class="token comment">// 实例的挂载</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">}</span>\n      <span class="token function">$mount</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token dom variable">window</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer">7.6.2 设置响应式对象 - Observer<a class="anchor" href="#762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer">§</a></h3>\n<p>首先引入一个类<code>Observer</code>,这个类的目的是将数据变成响应式对象，利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行改写。在数据读取<code>getter</code>阶段我们会进行<strong>依赖的收集</strong>，在数据的修改<code>setter</code>阶段，我们会进行<strong>依赖的更新</strong>(这两个概念的介绍放在后面)。因此在数据初始化阶段，我们会利用<code>Observer</code>这个类将数据对象修改为相应式对象，而这是所有流程的基础。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>\n  <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>\n    <span class="token comment">// 将数据重置getter，setter方法</span>\n    <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// Observer类的定义</span>\n<span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 实例化时执行walk方法对每个数据属性重写getter，setter方法</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">walk</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> keys <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> keys<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// Object.defineProperty的处理逻辑</span>\n      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher">7.6.3 依赖本身 - Watcher<a class="anchor" href="#763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher">§</a></h3>\n<p>我们可以这样理解，一个<code>Watcher</code>实例就是一个依赖，数据不管是在渲染模板时使用还是在用户计算时使用，都可以算做一个需要监听的依赖，<code>watcher</code>中记录着这个依赖监听的状态，以及如何更新操作的方法。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 监听的依赖</span>\n<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span> isRenderWatcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>\n    <span class="token comment">// Watcher.prototype.get的调用会进行状态的更新。</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>那么哪个时间点会实例化<code>watcher</code>并更新数据状态呢？显然在渲染数据到真实<code>DOM</code>时可以创建<code>watcher</code>。<code>$mount</code>流程前面章节介绍过，会经历模板生成<code>render</code>函数和<code>render</code>函数渲染真实<code>DOM</code>的过程。我们对代码做了精简，<code>updateView</code>浓缩了这一过程。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyVue</span> <span class="token punctuation">{</span>\n  <span class="token function">$mount</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 直接改写innerHTML</span>\n    <span class="token keyword">const</span> <span class="token function-variable function">updateView</span> <span class="token operator">=</span> <span class="token parameter">_</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> innerHtml <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">innerHTML</span><span class="token punctuation">;</span>\n      <span class="token keyword">let</span> key <span class="token operator">=</span> innerHtml<span class="token punctuation">.</span><span class="token method function property-access">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">{(\w+)}</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">querySelector</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 创建一个渲染的依赖。</span>\n    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>updateView<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep">7.6.4 依赖管理 - Dep<a class="anchor" href="#764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep">§</a></h3>\n<p><code>watcher</code>如果理解为每个数据需要监听的依赖，那么<code>Dep</code> 可以理解为对依赖的一种管理。数据可以在渲染中使用，也可以在计算属性中使用。相应的每个数据对应的<code>watcher</code>也有很多。而我们在更新数据时，如何通知到数据相关的每一个依赖，这就需要<code>Dep</code>进行通知管理了。并且浏览器同一时间只能更新一个<code>watcher</code>,所以也需要一个属性去记录当前更新的<code>watcher</code>。而<code>Dep</code>这个类只需要做两件事情，将依赖进行收集，派发依赖进行更新。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">let</span> uid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">=</span> uid<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 依赖收集</span>\n  <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// Dep.target是当前的watcher,将当前的依赖推到subs中</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 派发更新</span>\n  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subs</span><span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      <span class="token comment">// 遍历dep中的依赖，对每个依赖执行更新操作</span>\n      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>\n</code></pre>\n<h3 id="765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive">7.6.5 依赖管理过程 - defineReactive<a class="anchor" href="#765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive">§</a></h3>\n<p>我们看看数据拦截的过程。前面的<code>Observer</code>实例化最终会调用<code>defineReactive</code>重写<code>getter,setter</code>方法。这个方法开始会实例化一个<code>Dep</code>,也就是创建一个数据的依赖管理。在重写的<code>getter</code>方法中会进行依赖的收集，也就是调用<code>dep.depend</code>的方法。在<code>setter</code>阶段，比较两个数不同后，会调用依赖的派发更新。即<code>dep.notify</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">defineReactive</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> property <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n  <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span><span class="token property-access">configurable</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>\n  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 做依赖的收集</span>\n      <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        dep<span class="token punctuation">.</span><span class="token method function property-access">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword control-flow">return</span> val\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">set</span><span class="token punctuation">(</span>nval<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>nval <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword control-flow">return</span>\n      <span class="token comment">// 派发更新</span>\n      val <span class="token operator">=</span> nval\n      dep<span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>回过头来看<code>watcher</code>,实例化<code>watcher</code>时会将<code>Dep.target</code>设置为当前的<code>watcher</code>,执行完状态更新函数之后，再将<code>Dep.target</code>置空。这样在收集依赖时只要将<code>Dep.target</code>当前的<code>watcher push</code>到<code>Dep</code>的<code>subs</code>数组即可。而在派发更新阶段也只需要重新更新状态即可。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">expOrFn<span class="token punctuation">,</span> isRenderWatcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">getter</span> <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>\n    <span class="token comment">// Watcher.prototype.get的调用会进行状态的更新。</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 当前执行的watcher</span>\n    <span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword">this</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token maybe-class-name">Dep</span><span class="token punctuation">.</span><span class="token property-access">target</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="766-%E7%BB%93%E6%9E%9C">7.6.6 结果<a class="anchor" href="#766-%E7%BB%93%E6%9E%9C">§</a></h3>\n<p>一个极简的响应式系统搭建完成。在精简代码的同时，保持了源码设计的思想和逻辑。有了这一步的基础，接下来深入分析源码中每个环节的实现细节会更加简单。</p>\n<h2 id="77-%E5%B0%8F%E7%BB%93">7.7 小结<a class="anchor" href="#77-%E5%B0%8F%E7%BB%93">§</a></h2>\n<p>这一节内容，我们正式进入响应式系统的介绍，前面在数据代理章节，我们学过<code>Object.defineProperty</code>,这是一个用来进行数据拦截的方法，而响应式系统构建的基础就是数据的拦截。我们先介绍了<code>Vue</code>内部在初始化数据的过程，最终得出的结论是，不管是<code>data,computed</code>,还是其他的用户定义数据，最终都是调用<code>Object.defineProperty</code>进行数据拦截。而文章的最后，我们在保留源码设计思想和逻辑的前提下，构建出了一个简化版的响应式系统。完整的功能有助于我们下一节对源码具体实现细节的分析和思考。</p>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#71-%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96" }, "7.1 \u6570\u636E\u521D\u59CB\u5316")),
            React.createElement("li", null,
                React.createElement("a", { href: "#72-initprops" }, "7.2 initProps"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#721-props%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83" }, "7.2.1 props\u7684\u547D\u540D\u89C4\u8303")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#722-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AEprops" }, "7.2.2 \u54CD\u5E94\u5F0F\u6570\u636Eprops")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#73-initmethods" }, "7.3 initMethods")),
            React.createElement("li", null,
                React.createElement("a", { href: "#74-initdata" }, "7.4 initData")),
            React.createElement("li", null,
                React.createElement("a", { href: "#75-initcomputed" }, "7.5 initComputed")),
            React.createElement("li", null,
                React.createElement("a", { href: "#76-%E6%9E%81%E7%AE%80%E9%A3%8E%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F" }, "7.6 \u6781\u7B80\u98CE\u7684\u54CD\u5E94\u5F0F\u7CFB\u7EDF"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#761-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA" }, "7.6.1 \u6846\u67B6\u642D\u5EFA")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#762-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1---observer" }, "7.6.2 \u8BBE\u7F6E\u54CD\u5E94\u5F0F\u5BF9\u8C61 - Observer")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#763-%E4%BE%9D%E8%B5%96%E6%9C%AC%E8%BA%AB---watcher" }, "7.6.3 \u4F9D\u8D56\u672C\u8EAB - Watcher")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#764-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86---dep" }, "7.6.4 \u4F9D\u8D56\u7BA1\u7406 - Dep")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#765-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B---definereactive" }, "7.6.5 \u4F9D\u8D56\u7BA1\u7406\u8FC7\u7A0B - defineReactive")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#766-%E7%BB%93%E6%9E%9C" }, "7.6.6 \u7ED3\u679C")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#77-%E5%B0%8F%E7%BB%93" }, "7.7 \u5C0F\u7ED3")))),
    'author': "wyp",
    'contributors': [
        "wyp"
    ],
    'date': "2019-10-29T06:12:00.000Z",
    'updated': "2019-10-30T09:03:02.000Z",
    'excerpt': "7.1 数据初始化 回顾一下之前的内容，我们对Vue源码的分析是从初始化开始，初始化_init会执行一系列的过程，这个过程包括了配置选项的合并，数据的监测代理，最后才是实例的挂载。而在实例挂载前还有意忽略了一个重要的过程，数...",
    'cover': undefined,
    'sidebar': [
        {
            "text": "Introduction",
            "link": "introduction/index.html",
            "pagePath": "introduction/README.md"
        },
        {
            "text": "1.丰富的选项合并策略",
            "link": "src/1.丰富的选项合并策略.html",
            "pagePath": "src/1.丰富的选项合并策略.md"
        },
        {
            "text": "2.基础的数据代理检测",
            "link": "src/2.基础的数据代理检测.html",
            "pagePath": "src/2.基础的数据代理检测.md"
        },
        {
            "text": "3.实例挂载流程和模板编译",
            "link": "src/3.实例挂载流程和模板编译.html",
            "pagePath": "src/3.实例挂载流程和模板编译.md"
        },
        {
            "text": "4.完整渲染流程",
            "link": "src/4.完整渲染流程.html",
            "pagePath": "src/4.完整渲染流程.md"
        },
        {
            "text": "5.组件基础剖析",
            "link": "src/5.组件基础剖析.html",
            "pagePath": "src/5.组件基础剖析.md"
        },
        {
            "text": "6.组件高级用法",
            "link": "src/6.组件高级用法.html",
            "pagePath": "src/6.组件高级用法.md"
        },
        {
            "text": "7.深入响应式系统构建-上",
            "link": "src/7.深入响应式系统构建-上.html",
            "pagePath": "src/7.深入响应式系统构建-上.md"
        },
        {
            "text": "7.深入响应式系统构建-中",
            "link": "src/7.深入响应式系统构建-中.html",
            "pagePath": "src/7.深入响应式系统构建-中.md"
        },
        {
            "text": "7.深入响应式系统构建-下",
            "link": "src/7.深入响应式系统构建-下.html",
            "pagePath": "src/7.深入响应式系统构建-下.md"
        },
        {
            "text": "8.来，跟我一起实现diff算法",
            "link": "src/8.来，跟我一起实现diff算法.html",
            "pagePath": "src/8.来，跟我一起实现diff算法.md"
        },
        {
            "text": "9.揭秘Vue的事件机制",
            "link": "src/9.揭秘Vue的事件机制.html",
            "pagePath": "src/9.揭秘Vue的事件机制.md"
        },
        {
            "text": "10.vue插槽，你想了解的都在这里",
            "link": "src/10.vue插槽，你想了解的都在这里.html",
            "pagePath": "src/10.vue插槽，你想了解的都在这里.md"
        },
        {
            "text": "11.你真的了解v-model的语法糖了吗",
            "link": "src/11.你真的了解v-model的语法糖了吗.html",
            "pagePath": "src/11.你真的了解v-model的语法糖了吗.md"
        },
        {
            "text": "12.动态组件的深入分析",
            "link": "src/12.动态组件的深入分析.html",
            "pagePath": "src/12.动态组件的深入分析.md"
        },
        {
            "text": "13.彻底搞懂Vue中keep-alive的魔法-上",
            "link": "src/13.彻底搞懂Vue中keep-alive的魔法-上.html",
            "pagePath": "src/13.彻底搞懂Vue中keep-alive的魔法-上.md"
        },
        {
            "text": "13.彻底搞懂Vue中keep-alive的魔法-下",
            "link": "src/13.彻底搞懂Vue中keep-alive的魔法-下.html",
            "pagePath": "src/13.彻底搞懂Vue中keep-alive的魔法-下.md"
        }
    ]
};
