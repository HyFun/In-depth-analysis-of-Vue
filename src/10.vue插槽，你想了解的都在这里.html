<!doctype html><html class="" data-reactroot=""><head><link rel="icon" href="src/assets/favicon.ico"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:title" content="深入剖析Vue源码"/><meta data-react-helmet="true" property="og:description" content="Vue源码解析，深入剖析Vue源码"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary"/>
<title data-react-helmet="true">深入剖析Vue源码</title>
<link data-react-helmet="true" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/In-depth-analysis-of-Vue/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/In-depth-analysis-of-Vue/assets/prism_tomorrow.css";
    }
  </script>
</head><body><header><h1 class="hide_on_mobile"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1><nav><ul><li class="show_on_mobile flex_center"><a class="czs-menu-l" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-menu-l.svg&quot;)"></a></li><li class="show_on_mobile"><h1 class="mobile_title"><a href="/In-depth-analysis-of-Vue/">深入剖析Vue源码</a></h1></li><li class="hide_on_mobile"><a href="https://cn.vuejs.org/index.html" target="_blank">Vue2.x文档</a></li><li class="hide_on_mobile"><a href="https://book.penblog.cn/" target="_blank">历史地址</a></li><li class="hide_on_mobile"><a>赞助作者</a></li><li style="flex-grow:1"></li><li class="flex_center"><a class="czs-github-logo" href="https://github.com/Ocean1509/In-depth-analysis-of-Vue" target="_blank" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-github-logo.svg&quot;)"></a></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-moon-l.svg&quot;)"></span></li></ul></nav></header><aside class="sidebar"><ol class="list_style_none"><li class=""><a href="/In-depth-analysis-of-Vue/introduction/index.html" class="nav_link">Introduction</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/1.丰富的选项合并策略.html" class="nav_link">1.丰富的选项合并策略</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/2.基础的数据代理检测.html" class="nav_link">2.基础的数据代理检测</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/3.实例挂载流程和模板编译.html" class="nav_link">3.实例挂载流程和模板编译</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/4.完整渲染流程.html" class="nav_link">4.完整渲染流程</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/5.组件基础剖析.html" class="nav_link">5.组件基础剖析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/6.组件高级用法.html" class="nav_link">6.组件高级用法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-上.html" class="nav_link">7.深入响应式系统构建-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-中.html" class="nav_link">7.深入响应式系统构建-中</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/7.深入响应式系统构建-下.html" class="nav_link">7.深入响应式系统构建-下</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/8.来，跟我一起实现diff算法.html" class="nav_link">8.来，跟我一起实现diff算法</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/9.揭秘Vue的事件机制.html" class="nav_link">9.揭秘Vue的事件机制</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/10.vue插槽，你想了解的都在这里.html" class="nav_link active">10.vue插槽，你想了解的都在这里</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/11.你真的了解v-model的语法糖了吗.html" class="nav_link">11.你真的了解v-model的语法糖了吗</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/12.动态组件的深入分析.html" class="nav_link">12.动态组件的深入分析</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-上.html" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-上</a></li><li class=""><a href="/In-depth-analysis-of-Vue/src/13.彻底搞懂Vue中keep-alive的魔法-下.html" class="nav_link">13.彻底搞懂Vue中keep-alive的魔法-下</a></li></ol></aside><section class="main"><div class="main_article"><article><blockquote>
<p>Vue组件的另一个重要概念是插槽，它允许你以一种不同于严格的父子关系的方式组合组件。插槽为你提供了一个将内容放置到新位置或使组件更通用的出口。这一节将围绕官网对插槽内容的介绍思路，按照普通插槽，具名插槽，再到作用域插槽的思路，逐步深入内部的实现原理,有对插槽使用不熟悉的，可以先参考官网对<a href="https://cn.vuejs.org/v2/guide/components-slots.html">插槽</a>的介绍。</p>
</blockquote>
<h2 id="101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD">10.1 普通插槽<a class="anchor" href="#101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD">§</a></h2>
<p>插槽将<code>&lt;slot&gt;&lt;/slot&gt;</code>作为子组件承载分发的载体，简单的用法如下</p>
<h3 id="1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">10.1.1 基础用法<a class="anchor" href="#1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">§</a></h3>
<pre class="language-autoit"><code class="language-autoit">var child <span class="token operator">=</span> {
  template<span class="token punctuation">:</span> `<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span><span class="token operator">&lt;</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>`
}
var vm <span class="token operator">=</span> new <span class="token function">Vue</span><span class="token punctuation">(</span>{
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> {
    child
  }<span class="token punctuation">,</span>
  template<span class="token punctuation">:</span> `<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span><span class="token operator">&lt;</span>child<span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>`
}<span class="token punctuation">)</span>
<span class="token operator">/</span><span class="token operator">/</span> 最终渲染结果
<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
</code></pre>
<h3 id="1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86">10.1.2 组件挂载原理<a class="anchor" href="#1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86">§</a></h3>
<p>插槽的原理，贯穿了整个组件系统编译到渲染的过程，所以首先需要回顾一下对组件相关编译渲染流程，简单总结一下几点：</p>
<ol>
<li>从根实例入手进行实例的挂载，如果有手写的<code>render</code>函数，则直接进入<code>$mount</code>挂载流程。</li>
<li>只有<code>template</code>模板则需要对模板进行解析，这里分为两个阶段，一个是将模板解析为<code>AST</code>树，另一个是根据不同平台生成执行代码，例如<code>render</code>函数。</li>
<li><code>$mount</code>流程也分为两步，第一步是将<code>render</code>函数生成<code>Vnode</code>树，如果遇到子组件会先生成子组件，子组件会以<code>vue-componet-</code>为<code>tag</code>标记，另一步是把<code>Vnode</code>渲染成真正的DOM节点。</li>
<li>创建真实节点过程中，如果遇到子的占位符组件会进行子组件的实例化过程，这个过程又将回到流程的第一步。</li>
</ol>
<p>接下来我们对<code>slot</code>的分析将围绕这四个具体的流程展开。</p>
<h3 id="1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86">10.1.3 父组件处理<a class="anchor" href="#1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86">§</a></h3>
<p>回到组件实例流程中，父组件会优先于子组件进行实例的挂载，模板的解析和<code>render</code>函数的生成阶段在处理上没有特殊的差异，这里就不展开分析。接下来是<code>render</code>函数生成<code>Vnode</code>的过程，在这个阶段会遇到子的占位符节点(即：<code>child</code>),因此会为子组件创建子的<code>Vnode</code>。<code>createComponent</code>执行了创建子占位节点<code>Vnode</code>的过程。我们把重点放在最终<code>Vnode</code>代码的生成。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 创建子Vnode过程</span>
  <span class="token keyword">function</span> <span class="token function">createComponent</span> <span class="token punctuation">(</span>
    <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> <span class="token comment">// 子类构造器</span>
    data<span class="token punctuation">,</span>
    context<span class="token punctuation">,</span> <span class="token comment">// vm实例</span>
    children<span class="token punctuation">,</span> <span class="token comment">// 父组件需要分发的内容</span>
    tag <span class="token comment">// 子组件占位符</span>
  <span class="token punctuation">)</span><span class="token punctuation">{</span>
    ···
    <span class="token comment">// 创建子vnode，其中父保留的children属性会以选项的形式传递给Vnode</span>
    <span class="token keyword">var</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token string">"vue-component-"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Ctor</span><span class="token punctuation">.</span><span class="token property-access">cid</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>name <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      data<span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>
      <span class="token punctuation">{</span> <span class="token maybe-class-name">Ctor</span><span class="token operator">:</span> <span class="token maybe-class-name">Ctor</span><span class="token punctuation">,</span> propsData<span class="token operator">:</span> propsData<span class="token punctuation">,</span> listeners<span class="token operator">:</span> listeners<span class="token punctuation">,</span> tag<span class="token operator">:</span> tag<span class="token punctuation">,</span> children<span class="token operator">:</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>
      asyncFactory
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token comment">// Vnode构造器</span>
<span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">VNode</span></span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">VNode</span></span> <span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span>data<span class="token punctuation">,</span>children<span class="token punctuation">,</span>text<span class="token punctuation">,</span>elm<span class="token punctuation">,</span>context<span class="token punctuation">,</span>componentOptions<span class="token punctuation">,</span>asyncFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">componentOptions</span> <span class="token operator">=</span> componentOptions<span class="token punctuation">;</span> <span class="token comment">// 子组件的选项相关</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>createComponent</code>函数接收的第四个参数<code>children</code>就是父组件需要分发的内容。在创建子<code>Vnode</code>过程中，会以会<code>componentOptions</code>配置传入<code>Vnode</code>构造器中。<strong>最终<code>Vnode</code>中父组件需要分发的内容以<code>componentOptions</code>属性的形式存在，这是插槽分析的第一步</strong>。</p>
<h3 id="1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B">10.1.4 子组件流程<a class="anchor" href="#1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B">§</a></h3>
<p>父组件的最后一个阶段是将<code>Vnode</code>渲染为真正的DOM节点，在这个过程中如果遇到子<code>Vnode</code>会优先实例化子组件并进行一系列子组件的渲染流程。子组件初始化会先调用<code>_init</code>方法，并且和父组件不同的是，子组件会调用<code>initInternalComponent</code>方法拿到父组件拥有的相关配置信息，并赋值给子组件自身的配置选项。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 子组件的初始化</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span><span class="token property-access">_isComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">initInternalComponent</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token property-access">$options</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token property-access">constructor</span><span class="token punctuation">.</span><span class="token property-access">options</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> parentVnode <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span><span class="token property-access">parent</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">parent</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span> <span class="token operator">=</span> parentVnode<span class="token punctuation">;</span>
    <span class="token comment">// componentOptions为子vnode记录的相关信息</span>
    <span class="token keyword">var</span> vnodeComponentOptions <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span><span class="token property-access">componentOptions</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span><span class="token property-access">propsData</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">propsData</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span><span class="token property-access">_parentListeners</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">listeners</span><span class="token punctuation">;</span>
    <span class="token comment">// 父组件需要分发的内容赋值给子选项配置的_renderChildren</span>
    opts<span class="token punctuation">.</span><span class="token property-access">_renderChildren</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span><span class="token property-access">_componentTag</span> <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span><span class="token property-access">tag</span><span class="token punctuation">;</span>

    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">render</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      opts<span class="token punctuation">.</span><span class="token property-access">render</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">render</span><span class="token punctuation">;</span>
      opts<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>最终在<strong>子组件实例的配置中拿到了父组件保存的分发内容，记录在组件实例<code>$options._renderChildren</code>中，这是第二步的重点</strong>。</p>
<p>接下来是子组件的实例化会进入<code>initRender</code>阶段，在这个过程会<strong>将配置的<code>_renderChildren</code>属性做规范化处理，并将他赋值给子实例上的<code>$slot</code>属性，这是第三步的重点</strong>。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initRender</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ···
  vm<span class="token punctuation">.</span><span class="token property-access">$slots</span> <span class="token operator">=</span> <span class="token function">resolveSlots</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token property-access">_renderChildren</span><span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// $slots拿到了子占位符节点的_renderchildren(即需要分发的内容)，保留作为子实例的属性</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">resolveSlots</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span>context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// children是父组件需要分发到子组件的Vnode节点，如果不存在，则没有分发内容</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>children <span class="token operator">||</span> <span class="token operator">!</span>children<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> slots <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> data <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>
      <span class="token comment">// remove slot attribute if the node is resolved as a Vue slot node</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> data<span class="token punctuation">.</span><span class="token property-access">attrs</span><span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// named slots should only be respected if the vnode was rendered in the</span>
      <span class="token comment">// same context.</span>
      <span class="token comment">// 分支1为具名插槽的逻辑，放后分析</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">context</span> <span class="token operator">===</span> context <span class="token operator">||</span> child<span class="token punctuation">.</span><span class="token property-access">fnContext</span> <span class="token operator">===</span> context<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token property-access">slot</span> <span class="token operator">!=</span> <span class="token keyword null nil">null</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> name <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> slot <span class="token operator">=</span> <span class="token punctuation">(</span>slots<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>slots<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token property-access">tag</span> <span class="token operator">===</span> <span class="token string">'template'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          slot<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> child<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
          slot<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 普通插槽的重点，核心逻辑是构造{ default: [children] }对象返回</span>
        <span class="token punctuation">(</span>slots<span class="token punctuation">.</span><span class="token keyword module">default</span> <span class="token operator">||</span> <span class="token punctuation">(</span>slots<span class="token punctuation">.</span><span class="token keyword module">default</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> slots
  <span class="token punctuation">}</span>
</code></pre>
<p>其中普通插槽的处理逻辑核心在<code>(slots.default || (slots.default = [])).push(child);</code>，即以数组的形式赋值给<code>default</code>属性，并以<code>$slot</code>属性的形式保存在子组件的实例中。</p>
<p>随后子组件也会走挂载的流程，同样会经历<code>template</code>模板到<code>render</code>函数，再到<code>Vnode</code>,最后渲染真实<code>DOM</code>的过程。解析<code>AST</code>阶段，<code>slot</code>标签和其他普通标签处理相同，<strong>不同之处在于<code>AST</code>生成<code>render</code>函数阶段，对<code>slot</code>标签的处理，会使用<code>_t函数</code>进行包裹。这是关键步骤的第四步</strong></p>
<p>子组件渲染的大致流程简单梳理如下:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// ast 生成 render函数</span>
<span class="token keyword">var</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// generate实现</span>
<span class="token keyword">function</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token parameter">ast<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> state <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CodegenState</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> code <span class="token operator">=</span> ast <span class="token operator">?</span> <span class="token function">genElement</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">'_c("div")'</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
    render<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token string">"with(this){return "</span> <span class="token operator">+</span> code <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    staticRenderFns<span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">staticRenderFns</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// genElement实现</span>
<span class="token keyword">function</span> <span class="token function">genElement</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 针对slot标签的处理走```genSlot```分支</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span><span class="token property-access">tag</span> <span class="token operator">===</span> <span class="token string">'slot'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">genSlot</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 核心genSlot原理</span>
<span class="token keyword">function</span> <span class="token function">genSlot</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// slotName记录着插槽的唯一标志名，默认为default</span>
    <span class="token keyword">var</span> slotName <span class="token operator">=</span> el<span class="token punctuation">.</span><span class="token property-access">slotName</span> <span class="token operator">||</span> <span class="token string">'"default"'</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果子组件的插槽还有子元素，则会递归调执行子元素的创建过程</span>
    <span class="token keyword">var</span> children <span class="token operator">=</span> <span class="token function">genChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过_t函数包裹</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token string">"_t("</span> <span class="token operator">+</span> slotName <span class="token operator">+</span> <span class="token punctuation">(</span>children <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">","</span> <span class="token operator">+</span> children<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 具名插槽的其他处理</span>
    ···    
    <span class="token keyword control-flow">return</span> res <span class="token operator">+</span> <span class="token string">')'</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>最终子组件的<code>render</code>函数为：</p>
<pre class="language-js"><code class="language-js"><span class="token string">"with(this){return _c('div',{staticClass:"</span>child<span class="token string">"},[_t("</span><span class="token keyword module">default</span><span class="token string">")],2)}"</span>
</code></pre>
<p><strong>第五步到了子组件渲染为<code>Vnode</code>的过程。<code>render</code>函数执行阶段会执行<code>_t()</code>函数，<code>_t</code>函数是<code>renderSlot</code>函数简写，它会在<code>Vnode</code>树中进行分发内容的替换</strong>，具体看看实现逻辑。</p>
<pre class="language-js"><code class="language-js">
<span class="token comment">// target._t = renderSlot;</span>

<span class="token comment">// render函数渲染Vnode函数</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> _parentVnode <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token property-access">_parentVnode</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>_parentVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// slots的规范化处理并赋值给$scopedSlots属性。</span>
    vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span> <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>
      _parentVnode<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">.</span><span class="token property-access">scopedSlots</span><span class="token punctuation">,</span>
      vm<span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">,</span> <span class="token comment">// 记录父组件的插槽内容</span>
      vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>normalizeScopedSlots</code>的逻辑较长，但并不是本节的重点。拿到<code>$scopedSlots</code>属性后会执行真正的<code>render</code>函数,其中<code>_t</code>的执行逻辑如下：</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 渲染slot组件内容</span>
  <span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>
    name<span class="token punctuation">,</span>
    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容(针对后备内容)</span>
    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值(作用域插槽)</span>
    bindObject
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// scopedSlotFn拿到父组件插槽的执行函数，默认slotname为default</span>
    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>
    <span class="token comment">// 具名插槽分支(暂时忽略)</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>
      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token string">'slot v-bind without argument expects an Object'</span><span class="token punctuation">,</span>
            <span class="token keyword">this</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>
      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果父占位符组件没有插槽内容，this.$slots不会有值，此时vnode节点为后备内容节点。</span>
      nodes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> target <span class="token operator">=</span> props <span class="token operator">&amp;&amp;</span> props<span class="token punctuation">.</span><span class="token property-access">slot</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">$createElement</span><span class="token punctuation">(</span><span class="token string">'template'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> slot<span class="token operator">:</span> target <span class="token punctuation">}</span><span class="token punctuation">,</span> nodes<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span> nodes
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<p><code>renderSlot</code>执行过程会拿到父组件需要分发的内容，最终<code>Vnode</code>树将父元素的插槽替换掉子组件的<code>slot</code>组件。</p>
<p><strong>最后一步就是子组件真实节点的渲染了，这点没有什么特别点，和以往介绍的流程一致</strong>。</p>
<p>至此，一个完整且简单的插槽流程分析完毕。接下来看插槽深层次的用法。</p>
<h2 id="102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD">10.2 具有后备内容的插槽<a class="anchor" href="#102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD">§</a></h2>
<p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。查看源码发现后备内容插槽的逻辑也很好理解。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div class="child">&lt;slot>后备内容&lt;/slot>&lt;/div></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span>
    child
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 父没有插槽内容，子的slot会渲染后备内容</span>
<span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span>后备内容<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
</code></pre>
<p>父组件没有需要分发的内容，子组件会默认显示插槽里面的内容。源码中的不同体现在下面的几点。</p>
<ol>
<li>父组件渲染过程由于没有需要分发的子节点，所以不再需要拥有<code>componentOptions.children</code>属性来记录内容。</li>
<li>因此子组件也拿不到<code>$slot</code>属性的内容.</li>
<li>子组件的<code>render</code>函数最后在<code>_t</code>函数参数会携带第二个参数，该参数以数组的形式传入<code>slot</code>插槽的后备内容。例<code>with(this){return _c('div',{staticClass:&quot;child&quot;},[_t(&quot;default&quot;,[_v(&quot;test&quot;)])],2)}</code></li>
<li>渲染子<code>Vnode</code>会执行<code>renderSlot(即：_t)</code>函数时，第二个参数<code>fallback</code>有值，且<code>this.$slots</code>没值，<code>vnode</code>会直接返回后备内容作为渲染对象。</li>
</ol>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>
    name<span class="token punctuation">,</span>
    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容(针对后备内容)</span>
    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值(作用域插槽)</span>
    bindObject
<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ···
    <span class="token punctuation">}</span><span class="token keyword control-flow">else</span><span class="token punctuation">{</span>
      <span class="token comment">//fallback为后备内容</span>
      <span class="token comment">// 如果父占位符组件没有插槽内容，this.$slots不会有值，此时vnode节点为后备内容节点。</span>
      nodes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
    
</code></pre>
<p>最终，在父组件没有提供内容时，<code>slot</code>的后备内容被渲染。</p>
<p>有了这些基础，我们再来看官网给的一条规则。</p>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
</blockquote>
<p>父组件模板的内容在父组件编译阶段就确定了,并且保存在<code>componentOptions</code>属性中，而子组件有自身初始化<code>init</code>的过程，这个过程同样会进行子作用域的模板编译，因此两部分内容是相对独立的。</p>
<h2 id="103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">10.3 具名插槽<a class="anchor" href="#103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">§</a></h2>
<p>往往我们需要灵活的使用插槽进行通用组件的开发，要求父组件每个模板对应子组件中每个插槽，这时我们可以使用<code>&lt;slot&gt;</code>的<code>name</code>属性，同样举个简单的例子。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div class="child">&lt;slot name="header">&lt;/slot>&lt;slot name="footer">&lt;/slot>&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span>
    child
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;template v-slot:header>&lt;span>头部&lt;/span>&lt;/template>&lt;template v-slot:footer>&lt;span>底部&lt;/span>&lt;/template>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>渲染结果：</p>
<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>头部<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>底部<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
</code></pre>
<p>接下来我们在普通插槽的基础上，看看源码在具名插槽实现上的区别。</p>
<h3 id="1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB">10.3.1 模板编译的差别<a class="anchor" href="#1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB">§</a></h3>
<p>父组件在编译<code>AST</code>阶段和普通节点的过程不同，具名插槽一般会在<code>template</code>模板中用<code>v-slot:</code>来标注指定插槽，这一阶段会在编译阶段特殊处理。最终的<code>AST</code>树会携带<code>scopedSlots</code>用来记录具名插槽的内容</p>
<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>
  scopedSlots： <span class="token punctuation">{</span>
    footer<span class="token operator">:</span> <span class="token punctuation">{</span> ··· <span class="token punctuation">}</span><span class="token punctuation">,</span>
    header<span class="token operator">:</span> <span class="token punctuation">{</span> ··· <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>AST</code>生成<code>render</code>函数的过程也不详细分析了，我们只分析父组件最终返回的结果(如果对<code>parse, generate</code>感兴趣的同学，可以直接看源码分析,编译阶段冗长且难以讲解，跳过这部分分析)</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>scopedSlots<span class="token operator">:</span><span class="token function">_u</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"header"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">"头部"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>proxy<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"footer"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">"底部"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>proxy<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre>
<p>很明显，父组件的插槽内容用<code>_u</code>函数封装成数组的形式，并赋值到<code>scopedSlots</code>属性中，而每一个插槽以对象形式描述，<code>key</code>代表插槽名，<code>fn</code>是一个返回执行结果的函数。</p>
<h3 id="1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">10.3.2 父组件vnode生成阶段<a class="anchor" href="#1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">§</a></h3>
<p>照例进入父组件生成<code>Vnode</code>阶段，其中<code>_u</code>函数的原形是<code>resolveScopedSlots</code>,其中第一个参数就是插槽数组。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// vnode生成阶段针对具名插槽的处理 _u      (target._u = resolveScopedSlots)</span>
  <span class="token keyword">function</span> <span class="token function">resolveScopedSlots</span> <span class="token punctuation">(</span><span class="token parameter">fns<span class="token punctuation">,</span>res<span class="token punctuation">,</span>hasDynamicKeys<span class="token punctuation">,</span>contentHashKey</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> res <span class="token operator">||</span> <span class="token punctuation">{</span> $stable<span class="token operator">:</span> <span class="token operator">!</span>hasDynamicKeys <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fns<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> slot <span class="token operator">=</span> fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// fn是数组需要递归处理。</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>slot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolveScopedSlots</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> res<span class="token punctuation">,</span> hasDynamicKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// marker for reverse proxying v-slot without scope on this.$slots</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">.</span><span class="token property-access">proxy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//  针对proxy的处理</span>
          slot<span class="token punctuation">.</span><span class="token property-access">fn</span><span class="token punctuation">.</span><span class="token property-access">proxy</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 最终返回一个对象，对象以slotname作为属性，以fn作为值</span>
        res<span class="token punctuation">[</span>slot<span class="token punctuation">.</span><span class="token property-access">key</span><span class="token punctuation">]</span> <span class="token operator">=</span> slot<span class="token punctuation">.</span><span class="token property-access">fn</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>contentHashKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">$key</span> <span class="token operator">=</span> contentHashKey<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> res
  <span class="token punctuation">}</span>
</code></pre>
<p>最终父组件的<code>vnode</code>节点的<code>data</code>属性上多了<code>scopedSlots</code>数组。<strong>回顾一下，具名插槽和普通插槽实现上有明显的不同，普通插槽是以<code>componentOptions.child</code>的形式保留在父组件中，而具名插槽是以<code>scopedSlots</code>属性的形式存储到<code>data</code>属性中。</strong></p>
<pre class="language-js"><code class="language-js"><span class="token comment">// vnode</span>
<span class="token punctuation">{</span>
  scopedSlots<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    <span class="token string">'header'</span><span class="token operator">:</span> fn<span class="token punctuation">,</span>
    <span class="token string">'footer'</span><span class="token operator">:</span> fn
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B">10.3.3 子组件渲染Vnode过程<a class="anchor" href="#1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B">§</a></h3>
<p>子组件在解析成<code>AST</code>树阶段的不同，在于对<code>slot</code>标签的<code>name</code>属性的解析,而在<code>render</code>生成<code>Vnode</code>过程中，<code>slot</code>的规范化处理针对具名插槽会进行特殊的处理，回到<code>normalizeScopedSlots</code>的代码</p>
<pre class="language-js"><code class="language-js">vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span> <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>
  _parentVnode<span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">.</span><span class="token property-access">scopedSlots</span><span class="token punctuation">,</span> <span class="token comment">// 此时的第一个参数会拿到父组件插槽相关的数据</span>
  vm<span class="token punctuation">.</span><span class="token property-access">$slots</span><span class="token punctuation">,</span> <span class="token comment">// 记录父组件的插槽内容</span>
  vm<span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
<p>最终子组件实例上的<code>$scopedSlots</code>属性会携带父组件插槽相关的内容。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 子组件Vnode</span>
<span class="token punctuation">{</span>
  $scopedSlots<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    <span class="token string">'header'</span><span class="token operator">:</span> f<span class="token punctuation">,</span>
    <span class="token string">'footer'</span><span class="token operator">:</span> f
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom">10.3.4 子组件渲染真实dom<a class="anchor" href="#1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom">§</a></h3>
<p>和普通插槽类似，子组件渲染真实节点的过程会执行子<code>render</code>函数中的<code>_t</code>方法，这部分的源码会和普通插槽走不同的分支，其中<code>this.$scopedSlots</code>根据上面分析会记录着父组件插槽内容相关的数据，所以会和普通插槽走不同的分支。而最终的核心是执行<code>nodes = scopedSlotFn(props)</code>,也就是执行<code>function(){return [_c('span',[_v(&quot;头部&quot;)])]}</code>,具名插槽之所以是函数的形式执行而不是直接返回结果，我们在后面揭晓。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">renderSlot</span> <span class="token punctuation">(</span>
    name<span class="token punctuation">,</span>
    fallback<span class="token punctuation">,</span> <span class="token comment">// slot插槽后备内容</span>
    props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值</span>
    bindObject
  <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>
    <span class="token comment">// 针对具名插槽，特点是$scopedSlots有值</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>
      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'slot v-bind without argument expects an Object'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>
      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>···
  <span class="token punctuation">}</span>
</code></pre>
<p>至此子组件通过<code>slotName</code>找到了对应父组件的插槽内容。</p>
<h2 id="104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">10.4 作用域插槽<a class="anchor" href="#104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">§</a></h2>
<p>最后说说作用域插槽，我们可以利用作用域插槽让父组件的插槽内容访问到子组件的数据，具体的用法是在子组件中以属性的方式记录在子组件中，父组件通过<code>v-slot:[name]=[props]</code>的形式拿到子组件传递的值。子组件<code>&lt;slot&gt;</code>元素上的特性称为<strong>插槽<code>Props</code></strong>,另外，vue2.6以后的版本已经弃用了<code>slot-scoped</code>，采用<code>v-slot</code>代替。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>&lt;slot :user="user">&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
      user<span class="token operator">:</span> <span class="token punctuation">{</span>
        firstname<span class="token operator">:</span> <span class="token string">'test'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span>
    child
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="app">&lt;child>&lt;template v-slot:default="slotProps">{{slotProps.user.firstname}}&lt;/template>&lt;/child>&lt;/div></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>作用域插槽和具名插槽的原理类似，我们接着往下看。</p>
<h3 id="1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">10.4.1 父组件编译阶段<a class="anchor" href="#1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">§</a></h3>
<p>作用域插槽和具名插槽在父组件的用法基本相同，区别在于<code>v-slot</code>定义了一个插槽<code>props</code>的名字，参考对于具名插槽的分析，生成<code>render</code>函数阶段<code>fn</code>函数会携带<code>props</code>参数传入。即：</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token string">"app"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>scopedSlots<span class="token operator">:</span><span class="token function">_u</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>key<span class="token operator">:</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">slotProps</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>slotProps<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">.</span><span class="token property-access">firstname</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre>
<h3 id="1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">10.4.2 子组件渲染<a class="anchor" href="#1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">§</a></h3>
<p>在子组件编译阶段，<code>:user=&quot;user&quot;</code>会以属性的形式解析，最终在<code>render</code>函数生成阶段以对象参数的形式传递<code>_t</code>函数。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword control-flow">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_t</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"user"</span><span class="token operator">:</span>user<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre>
<p>子组件渲染Vnode阶段，根据前面分析会执行<code>renderSlot</code>函数，这个函数前面分析过，对于作用域插槽的处理，集中体现在函数传入的第三个参数。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// 渲染slot组件vnode</span>
<span class="token keyword">function</span> <span class="token function">renderSlot</span><span class="token punctuation">(</span>
  name<span class="token punctuation">,</span>
  fallback<span class="token punctuation">,</span>
  props<span class="token punctuation">,</span> <span class="token comment">// 子传给父的值 { user: user }</span>
  bindObject
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// scopedSlotFn拿到父组件插槽的执行函数，默认slotname为default</span>
    <span class="token keyword">var</span> scopedSlotFn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$scopedSlots</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nodes<span class="token punctuation">;</span>
    <span class="token comment">// 具名插槽分支</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>scopedSlotFn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// scoped slot</span>
      props <span class="token operator">=</span> props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>bindObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token string">'slot v-bind without argument expects an Object'</span><span class="token punctuation">,</span>
            <span class="token keyword">this</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 合并props</span>
        props <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bindObject<span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行时将子组件传递给父组件的值传入fn</span>
      nodes <span class="token operator">=</span> <span class="token function">scopedSlotFn</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">||</span> fallback<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>最终将子组件的插槽<code>props</code>作为参数传递给执行函数执行。<strong>回过头看看为什么具名插槽是函数的形式执行而不是直接返回结果。学完作用域插槽我们发现这就是设计巧妙的地方，函数的形式让执行过程更加灵活，作用域插槽只需要以参数的形式将插槽<code>props</code>传入便可以得到想要的结果。</strong></p>
<h3 id="1043-%E6%80%9D%E8%80%83">10.4.3 思考<a class="anchor" href="#1043-%E6%80%9D%E8%80%83">§</a></h3>
<p>作用域插槽这个概念一开始我很难理解，单纯从定义和源码的结论上看，父组件的插槽内容可以访问到子组件的数据，这不是明显的子父之间的信息通信吗，在事件章节我们知道，子父组件之间的通信完全可以通过事件<code>$emit,$on</code>的形式来完成，那么为什么还需要增加一个插槽<code>props</code>的概念呢。我们看看作者的解释。</p>
<blockquote>
<p>插槽 <code>prop</code> 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 <code>prop</code> 渲染出不同的内容</p>
</blockquote>
<p>从我自身的角度理解，作用域插槽提供了一种方式，当你需要封装一个通用，可复用的逻辑模块，并且这个模块给外部使用者提供了一个便利，允许你在使用组件时自定义部分布局，这时候作用域插槽就派上大用场了，再到具体的思想，我们可以看看几个工具库<a href="https://github.com/Akryum/vue-virtual-scroller">Vue Virtual Scroller</a>, <a href="https://github.com/posva/vue-promised">Vue Promised</a>对这一思想的应用。</p></article><div class="prev_next"><a class="prev button" href="/In-depth-analysis-of-Vue/src/9.揭秘Vue的事件机制.html">«  <!-- -->9.揭秘Vue的事件机制</a><a class="next button" href="/In-depth-analysis-of-Vue/src/11.你真的了解v-model的语法糖了吗.html">11.你真的了解v-model的语法糖了吗<!-- -->  »</a></div></div><aside class="main_toc_container nav_link_container"><div class="main_toc"><nav class="toc"><ol><li><a href="#101-%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD">10.1 普通插槽</a><ol><li><a href="#1011-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">10.1.1 基础用法</a></li><li><a href="#1012-%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86">10.1.2 组件挂载原理</a></li><li><a href="#1013-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86">10.1.3 父组件处理</a></li><li><a href="#1014-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B">10.1.4 子组件流程</a></li></ol></li><li><a href="#102-%E5%85%B7%E6%9C%89%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9%E7%9A%84%E6%8F%92%E6%A7%BD">10.2 具有后备内容的插槽</a></li><li><a href="#103-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">10.3 具名插槽</a><ol><li><a href="#1031-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%AE%E5%88%AB">10.3.1 模板编译的差别</a></li><li><a href="#1032-%E7%88%B6%E7%BB%84%E4%BB%B6vnode%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">10.3.2 父组件vnode生成阶段</a></li><li><a href="#1033-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93vnode%E8%BF%87%E7%A8%8B">10.3.3 子组件渲染Vnode过程</a></li><li><a href="#1034-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9C%9F%E5%AE%9Edom">10.3.4 子组件渲染真实dom</a></li></ol></li><li><a href="#104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">10.4 作用域插槽</a><ol><li><a href="#1041-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">10.4.1 父组件编译阶段</a></li><li><a href="#1042-%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">10.4.2 子组件渲染</a></li><li><a href="#1043-%E6%80%9D%E8%80%83">10.4.3 思考</a></li></ol></li></ol></nav></div></aside></section><footer>Powered by&amp;nbsp;<a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><div class="tools flex_center hide_on_mobile"><a class="czs-angle-up-l button" href="#" style="background-image:url(&quot;/In-depth-analysis-of-Vue/assets/czs-angle-up-l.svg&quot;)"></a></div><script src="https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/In-depth-analysis-of-Vue/index.js"></script></body></html>